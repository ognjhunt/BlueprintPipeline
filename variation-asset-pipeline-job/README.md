# Variation Asset Pipeline Job

End-to-end pipeline for generating SimReady variation assets for domain randomization in Isaac Sim Replicator.

## Overview

This job orchestrates the complete pipeline:

```
replicator-job manifest.json
        ↓
┌───────────────────────────────────────┐
│   variation-asset-pipeline-job        │
│                                       │
│   1. Check asset library (optional)   │
│   2. Generate reference images        │
│      (Gemini 3.0 Pro Image)           │
│   3. Convert to 3D mesh               │
│      (SAM3D or Hunyuan3D)             │
│   4. Add physics properties           │
│      (mass, friction, collision)      │
│   5. Convert to USDZ                  │
└───────────────────────────────────────┘
        ↓
variation_assets/*.usdz (SimReady)
```

## When to Use

Use this job when you need to generate variation assets for a scene that has already been processed by `replicator-job`. The replicator-job creates a manifest of needed assets - this job creates those assets.

**Use Cases:**
- Kitchen scene needs dishes, utensils, food items
- Grocery scene needs packaged goods, produce, bottles
- Laundry scene needs clothing, towels, detergent
- Warehouse scene needs boxes, tools, containers

## Configuration

### Required Environment Variables

| Variable | Description |
|----------|-------------|
| `SCENE_ID` | Scene identifier |
| `GEMINI_API_KEY` | Google AI API key for image generation |

### Optional Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `BUCKET` | - | GCS bucket name |
| `REPLICATOR_PREFIX` | `scenes/{SCENE_ID}/replicator` | Path to replicator bundle |
| `VARIATION_ASSETS_PREFIX` | `scenes/{SCENE_ID}/variation_assets` | Output path |
| `3D_BACKEND` | `auto` | `sam3d`, `hunyuan`, or `auto` |
| `QUALITY_MODE` | `balanced` | `fast`, `balanced`, or `quality` |
| `MAX_ASSETS` | - | Limit number of assets to generate |
| `PRIORITY_FILTER` | - | `required`, `recommended`, or `optional` |
| `ASSET_LIBRARY_PATH` | - | Path to shared asset library |
| `ASSET_REGISTRY_BACKEND_URI` | - | File or Firestore-like URI used to persist registry entries (e.g., `file:///mnt/gcs/asset_registry.json`) |
| `ASSET_VECTOR_BACKEND_URI` | - | URI to vector store for semantic asset lookup (defaults to `{ASSET_LIBRARY_PATH}/index.json` when present) |
| `ASSET_VECTOR_SIMILARITY_THRESHOLD` | `0.82` | Minimum cosine similarity to accept a semantic match |
| `ASSET_VECTOR_MAX_CANDIDATES` | `5` | Max top-K candidates to consider from vector search |
| `ASSET_VECTOR_LEXICAL_FALLBACK` | `0` | Enable lexical fallback when embeddings are unavailable |
| `ASSET_VECTOR_LEXICAL_THRESHOLD` | `0.2` | Minimum token-overlap score for lexical fallback matches |
| `SKIP_EXISTING` | `1` | Skip assets that already exist |
| `REGISTER_ASSETS` | `1` | Toggle registry ingestion (automatically disabled when `DRY_RUN=1`) |
| `DRY_RUN` | `0` | Skip actual generation (for testing) |

Example storage location:

```bash
export BUCKET=blueprint-8c1ca.appspot.com
export SCENE_ID=scene_123
# Outputs land under gs://blueprint-8c1ca.appspot.com/scenes/${SCENE_ID}/variation_assets
```

### Quality Presets

| Mode | 3D Backend | Image Size | Use Case |
|------|------------|------------|----------|
| `fast` | SAM3D | 512px | Quick iteration, many simple objects |
| `balanced` | Auto | 1024px | Default - good quality/speed balance |
| `quality` | Hunyuan | 2048px | High-quality assets, hero objects |

### 3D Backend Selection

When `3D_BACKEND=auto`, the backend is selected based on asset category:

| SAM3D (Fast) | Hunyuan (Quality) |
|--------------|-------------------|
| dishes | clothing |
| utensils | food |
| cans | produce |
| bottles | tools |
| boxes | electronics |
| containers | lab_equipment |

## Input

The job reads from the replicator bundle:

```
{REPLICATOR_PREFIX}/variation_assets/manifest.json
```

Manifest structure (generated by replicator-job):

```json
{
  "scene_id": "scene_123",
  "scene_type": "kitchen",
  "assets": [
    {
      "name": "plate_ceramic_white",
      "category": "dishes",
      "description": "white ceramic dinner plate",
      "semantic_class": "dish",
      "priority": "required",
      "source_hint": "generate",
      "physics_hints": {
        "mass_range_kg": [0.2, 0.5],
        "friction": 0.4
      },
      "material_hint": "ceramic, porcelain",
      "generation_prompt_hint": "..."
    }
  ]
}
```

## Output

The job produces SimReady assets in the output directory:

```
{VARIATION_ASSETS_PREFIX}/
├── pipeline_summary.json          # Processing summary
├── simready_assets.json           # Asset manifest for downstream
├── .variation_pipeline_complete   # Completion marker
│
├── asset_registry.json            # Optional file-based registry backend (when configured)
│
├── plate_ceramic_white/
│   ├── reference.png              # Generated reference image
│   ├── model.glb                  # 3D mesh
│   ├── model.usdz                 # USD format (if conversion succeeds)
│   └── metadata.json              # SimReady physics properties
│
├── bowl_cereal_blue/
│   ├── reference.png
│   ├── model.glb
│   ├── model.usdz
│   └── metadata.json
│
└── ...
```

### Library ingestion

When `ASSET_LIBRARY_PATH` is provided, successful assets are copied into the shared library and de-duplicated:

```
{ASSET_LIBRARY_PATH}/
└── {category}/
    ├── {asset_name}.usdz        # Primary SimReady asset
    ├── {asset_name}.json        # Physics + provenance metadata
    └── {asset_name}_thumb.png   # Thumbnail (Gemini reference image)
```

Idempotency checks prevent overwriting identical files, and ingestion is automatically skipped when `DRY_RUN=1`.

### Library lookup fallback

When semantic embedding lookups are enabled, the pipeline first attempts a vector search. If embedding generation fails and `ASSET_VECTOR_LEXICAL_FALLBACK=1`, it falls back to a lightweight lexical match using the `AssetSpec` metadata (name/description/category/semantic class/variants) against library index metadata (`asset_id`, `tags`, `description`). The match is accepted when the overlap score meets `ASSET_VECTOR_LEXICAL_THRESHOLD`. 

### Registry updates

Each successful generation or library selection is recorded in a registry backend when `ASSET_REGISTRY_BACKEND_URI` is set. The default implementation writes to a JSON file, but the schema is designed to mirror Firestore-style documents:

```json
{
  "asset_id": "plate_ceramic_white",
  "category": "dishes",
  "tags": ["dishes", "dish"],
  "source_pipeline": "variation",
  "storage_uris": {
    "variation_output": "gs://<bucket>/scenes/<scene>/variation_assets/plate_ceramic_white/model.usdz",
    "library_asset": "gs://<bucket>/<library>/dishes/plate_ceramic_white.usdz"
  },
  "metadata_uri": "gs://<bucket>/<library>/dishes/plate_ceramic_white.json",
  "thumbnail_uri": "gs://<bucket>/<library>/dishes/plate_ceramic_white_thumb.png",
  "simready": true,
  "priority": "required",
  "updated_at": "2024-07-16T12:34:56Z"
}
```

Registry writes are idempotent: repeated runs update the existing entry only when fields change. Setting `REGISTER_ASSETS=0` or `DRY_RUN=1` disables registry mutations while leaving the rest of the pipeline untouched.

### SimReady Metadata

Each asset includes physics properties:

```json
{
  "asset_name": "plate_ceramic_white",
  "category": "dishes",
  "semantic_class": "dish",
  "simready": true,
  "physics": {
    "mass_kg": 0.35,
    "bulk_density_kg_per_m3": 2400,
    "static_friction": 0.4,
    "dynamic_friction": 0.35,
    "restitution": 0.1,
    "collision_shape": "convex",
    "size_m": [0.25, 0.25, 0.02],
    "volume_m3": 0.00125,
    "center_of_mass_offset": [0, 0, 0],
    "graspable": true,
    "contact_offset_m": 0.005,
    "rest_offset_m": 0.001
  }
}
```

## Integration with Replicator

After this job completes, the Replicator scripts can use the generated assets:

```python
# In Isaac Sim Script Editor
import omni.replicator.core as rep

# Load variation assets
asset_paths = [
    "./variation_assets/plate_ceramic_white/model.usdz",
    "./variation_assets/bowl_cereal_blue/model.usdz",
    # ...
]

# Scatter on placement surfaces
with rep.new_layer():
    objects = rep.create.from_usd(
        rep.distribution.choice(asset_paths),
        semantics=[("class", "dish")],
        count=10
    )

    surfaces = rep.get.prim_at_path("/PlacementRegions/counter_region/Surface")

    with objects:
        rep.randomizer.scatter_2d(
            surface_prims=surfaces,
            check_for_collisions=True
        )
```

## Asset Library (Optional)

For faster processing and asset reuse, you can configure a shared asset library:

```
{ASSET_LIBRARY_PATH}/
├── index.json                    # Searchable index
├── dishes/
│   ├── plate_white_001.usdz
│   ├── plate_white_001.json
│   └── ...
├── groceries/
│   └── ...
└── ...
```

When `ASSET_LIBRARY_PATH` is set, the pipeline will:
1. Check if the asset exists in the library
2. If found, copy it instead of generating
3. If not found, generate and (optionally) add to library

### Semantic/Vector Search

When an exact `{category}/{asset_name}.usdz` match is missing, the pipeline can fall back to a semantic search to find the closest asset in the same category:

- Point `ASSET_VECTOR_BACKEND_URI` to a vector store (e.g., `file:///mnt/gcs/<library>/index.json`, pgvector endpoint, or Vertex AI Vector Search proxy). If unset, the job automatically looks for `{ASSET_LIBRARY_PATH}/index.json`.
- The index should contain embeddings derived from asset descriptions or tags and be keyed by an `asset_id` and asset-relative `path`.
- At runtime the requested `AssetSpec` description is embedded and the vector index is queried for the top-K matches (`ASSET_VECTOR_MAX_CANDIDATES`).
- The best candidate above `ASSET_VECTOR_SIMILARITY_THRESHOLD` is copied from the library. The pipeline logs both the similarity score and the chosen asset path for observability.

## Performance

| Stage | Duration (per asset) | Notes |
|-------|---------------------|-------|
| Image Generation | 5-15s | Gemini 3.0 Pro Image (Nano Banana Pro) |
| SAM3D Conversion | 30-60s | Good for simple objects |
| Hunyuan Conversion | 2-5min | Higher quality |
| Physics Estimation | <1s | Category-based defaults |
| USDZ Conversion | 1-5s | Requires usd_from_gltf |

**Total per asset:**
- Fast mode: ~1-2 minutes
- Balanced mode: ~2-5 minutes
- Quality mode: ~5-10 minutes

## Troubleshooting

### Common Issues

1. **"Gemini API key not set"**
   - Set `GEMINI_API_KEY` environment variable

2. **"SAM3D inference not available"**
   - SAM3D requires specific checkpoints and dependencies
   - Use `3D_BACKEND=hunyuan` or ensure SAM3D is properly installed

3. **"USDZ conversion failed"**
   - `usd_from_gltf` may not be available
   - GLB files are still usable in Isaac Sim

4. **"No assets to process"**
   - Check that manifest.json exists and has assets with `source_hint="generate"`
   - Check `PRIORITY_FILTER` if set

### Debug Mode

Run with `DRY_RUN=1` to test without actual generation:

```bash
SCENE_ID=test_scene DRY_RUN=1 python run_variation_asset_pipeline.py
```

## Related Jobs

- **replicator-job**: Creates the manifest consumed by this job
- **variation-gen-job**: Reference image generation
- **simready-job**: Standalone physics property assignment
- **regen3d-job**: 3D-RE-GEN adapter for mesh generation
