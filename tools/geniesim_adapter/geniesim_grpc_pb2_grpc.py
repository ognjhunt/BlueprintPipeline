#!/usr/bin/env python3
"""
gRPC Service Stubs for Genie Sim Data Collection.

This module provides the gRPC client and server stubs for communicating with
the Genie Sim data collection server running inside Isaac Sim.

These would normally be auto-generated by grpc_tools.protoc, but are implemented
manually here for compatibility when grpc_tools is not available.

Usage:
    from geniesim_grpc_pb2_grpc import GenieSimServiceStub, create_channel

    channel = create_channel()
    stub = GenieSimServiceStub(channel)
    response = stub.GetObservation(GetObservationRequest(...))
"""

import json
import os
from typing import Any, Callable, Iterator, Optional

from .geniesim_grpc_pb2 import (
    GetObservationRequest, GetObservationResponse,
    GetJointPositionRequest, GetJointPositionResponse,
    SetJointPositionRequest, SetJointPositionResponse,
    GetEEPoseRequest, GetEEPoseResponse,
    SetGripperStateRequest, SetGripperStateResponse,
    GetObjectPoseRequest, GetObjectPoseResponse,
    SetObjectPoseRequest, SetObjectPoseResponse,
    SetTrajectoryRequest, SetTrajectoryResponse,
    StartRecordingRequest, StartRecordingResponse,
    StopRecordingRequest, StopRecordingResponse,
    ResetRequest, ResetResponse,
    CommandRequest, CommandResponse,
)


# Try to import grpc
try:
    import grpc
    GRPC_AVAILABLE = True
except ImportError:
    GRPC_AVAILABLE = False
    grpc = None


# =============================================================================
# Service Method Descriptors
# =============================================================================


class _MethodDescriptor:
    """Descriptor for a gRPC method."""

    def __init__(
        self,
        name: str,
        request_type: type,
        response_type: type,
        request_serializer: Callable,
        response_deserializer: Callable,
    ):
        self.name = name
        self.full_name = f"/geniesim.GenieSimService/{name}"
        self.request_type = request_type
        self.response_type = response_type
        self.request_serializer = request_serializer
        self.response_deserializer = response_deserializer


# Define service methods
_SERVICE_METHODS = {
    "GetObservation": _MethodDescriptor(
        "GetObservation",
        GetObservationRequest,
        GetObservationResponse,
        lambda req: req.SerializeToString(),
        GetObservationResponse.FromString,
    ),
    "GetJointPosition": _MethodDescriptor(
        "GetJointPosition",
        GetJointPositionRequest,
        GetJointPositionResponse,
        lambda req: req.SerializeToString(),
        GetJointPositionResponse.FromString,
    ),
    "SetJointPosition": _MethodDescriptor(
        "SetJointPosition",
        SetJointPositionRequest,
        SetJointPositionResponse,
        lambda req: req.SerializeToString(),
        SetJointPositionResponse.FromString,
    ),
    "GetEEPose": _MethodDescriptor(
        "GetEEPose",
        GetEEPoseRequest,
        GetEEPoseResponse,
        lambda req: req.SerializeToString(),
        GetEEPoseResponse.FromString,
    ),
    "SetGripperState": _MethodDescriptor(
        "SetGripperState",
        SetGripperStateRequest,
        SetGripperStateResponse,
        lambda req: req.SerializeToString(),
        SetGripperStateResponse.FromString,
    ),
    "GetObjectPose": _MethodDescriptor(
        "GetObjectPose",
        GetObjectPoseRequest,
        GetObjectPoseResponse,
        lambda req: req.SerializeToString(),
        GetObjectPoseResponse.FromString,
    ),
    "SetObjectPose": _MethodDescriptor(
        "SetObjectPose",
        SetObjectPoseRequest,
        SetObjectPoseResponse,
        lambda req: req.SerializeToString(),
        SetObjectPoseResponse.FromString,
    ),
    "SetTrajectory": _MethodDescriptor(
        "SetTrajectory",
        SetTrajectoryRequest,
        SetTrajectoryResponse,
        lambda req: req.SerializeToString(),
        SetTrajectoryResponse.FromString,
    ),
    "StartRecording": _MethodDescriptor(
        "StartRecording",
        StartRecordingRequest,
        StartRecordingResponse,
        lambda req: req.SerializeToString(),
        StartRecordingResponse.FromString,
    ),
    "StopRecording": _MethodDescriptor(
        "StopRecording",
        StopRecordingRequest,
        StopRecordingResponse,
        lambda req: req.SerializeToString(),
        StopRecordingResponse.FromString,
    ),
    "Reset": _MethodDescriptor(
        "Reset",
        ResetRequest,
        ResetResponse,
        lambda req: req.SerializeToString(),
        ResetResponse.FromString,
    ),
    "SendCommand": _MethodDescriptor(
        "SendCommand",
        CommandRequest,
        CommandResponse,
        lambda req: req.SerializeToString(),
        CommandResponse.FromString,
    ),
}


# =============================================================================
# Service Stub (Client)
# =============================================================================


class GenieSimServiceStub:
    """
    gRPC client stub for GenieSimService.

    Provides methods for communicating with the Genie Sim data collection
    server running inside Isaac Sim.

    Usage:
        channel = create_channel()
        stub = GenieSimServiceStub(channel)

        # Get observation
        response = stub.GetObservation(GetObservationRequest(include_images=True))

        # Set joint positions
        response = stub.SetJointPosition(SetJointPositionRequest(
            positions=[0.0, -0.5, 0.0, -2.0, 0.0, 2.5, 0.8]
        ))
    """

    def __init__(self, channel):
        """
        Initialize the stub.

        Args:
            channel: gRPC channel to use for communication
        """
        self._channel = channel

        if GRPC_AVAILABLE and channel is not None:
            # Create method stubs
            for method_name, descriptor in _SERVICE_METHODS.items():
                setattr(
                    self,
                    f"_{method_name}_stub",
                    channel.unary_unary(
                        descriptor.full_name,
                        request_serializer=descriptor.request_serializer,
                        response_deserializer=descriptor.response_deserializer,
                    )
                )

    def GetObservation(
        self,
        request: GetObservationRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetObservationResponse:
        """Get current observation from simulation."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetObservation_stub(request, timeout=timeout, metadata=metadata)

    def GetJointPosition(
        self,
        request: GetJointPositionRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetJointPositionResponse:
        """Get current joint positions."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetJointPosition_stub(request, timeout=timeout, metadata=metadata)

    def SetJointPosition(
        self,
        request: SetJointPositionRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetJointPositionResponse:
        """Set robot joint positions."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetJointPosition_stub(request, timeout=timeout, metadata=metadata)

    def GetEEPose(
        self,
        request: GetEEPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetEEPoseResponse:
        """Get end-effector pose."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetEEPose_stub(request, timeout=timeout, metadata=metadata)

    def SetGripperState(
        self,
        request: SetGripperStateRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetGripperStateResponse:
        """Set gripper state (width and force)."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetGripperState_stub(request, timeout=timeout, metadata=metadata)

    def GetObjectPose(
        self,
        request: GetObjectPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetObjectPoseResponse:
        """Get object pose."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetObjectPose_stub(request, timeout=timeout, metadata=metadata)

    def SetObjectPose(
        self,
        request: SetObjectPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetObjectPoseResponse:
        """Set object pose."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetObjectPose_stub(request, timeout=timeout, metadata=metadata)

    def SetTrajectory(
        self,
        request: SetTrajectoryRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetTrajectoryResponse:
        """Execute a trajectory."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetTrajectory_stub(request, timeout=timeout, metadata=metadata)

    def StartRecording(
        self,
        request: StartRecordingRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> StartRecordingResponse:
        """Start recording an episode."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._StartRecording_stub(request, timeout=timeout, metadata=metadata)

    def StopRecording(
        self,
        request: StopRecordingRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> StopRecordingResponse:
        """Stop recording current episode."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._StopRecording_stub(request, timeout=timeout, metadata=metadata)

    def Reset(
        self,
        request: ResetRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> ResetResponse:
        """Reset the simulation environment."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._Reset_stub(request, timeout=timeout, metadata=metadata)

    def SendCommand(
        self,
        request: CommandRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> CommandResponse:
        """Send a generic command."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SendCommand_stub(request, timeout=timeout, metadata=metadata)


# =============================================================================
# Service Servicer (Server - for reference/testing)
# =============================================================================


class GenieSimServiceServicer:
    """
    Base class for GenieSimService server implementation.

    Override these methods to implement the server-side logic.
    This is primarily useful for testing and for understanding the expected
    server behavior.
    """

    def GetObservation(
        self,
        request: GetObservationRequest,
        context,
    ) -> GetObservationResponse:
        """Get current observation from simulation."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def GetJointPosition(
        self,
        request: GetJointPositionRequest,
        context,
    ) -> GetJointPositionResponse:
        """Get current joint positions."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def SetJointPosition(
        self,
        request: SetJointPositionRequest,
        context,
    ) -> SetJointPositionResponse:
        """Set robot joint positions."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def GetEEPose(
        self,
        request: GetEEPoseRequest,
        context,
    ) -> GetEEPoseResponse:
        """Get end-effector pose."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def SetGripperState(
        self,
        request: SetGripperStateRequest,
        context,
    ) -> SetGripperStateResponse:
        """Set gripper state."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def GetObjectPose(
        self,
        request: GetObjectPoseRequest,
        context,
    ) -> GetObjectPoseResponse:
        """Get object pose."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def SetObjectPose(
        self,
        request: SetObjectPoseRequest,
        context,
    ) -> SetObjectPoseResponse:
        """Set object pose."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def SetTrajectory(
        self,
        request: SetTrajectoryRequest,
        context,
    ) -> SetTrajectoryResponse:
        """Execute a trajectory."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def StartRecording(
        self,
        request: StartRecordingRequest,
        context,
    ) -> StartRecordingResponse:
        """Start recording an episode."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def StopRecording(
        self,
        request: StopRecordingRequest,
        context,
    ) -> StopRecordingResponse:
        """Stop recording current episode."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def Reset(
        self,
        request: ResetRequest,
        context,
    ) -> ResetResponse:
        """Reset the simulation environment."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")

    def SendCommand(
        self,
        request: CommandRequest,
        context,
    ) -> CommandResponse:
        """Send a generic command."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED if grpc else None)
        context.set_details("Method not implemented")
        raise NotImplementedError("Method not implemented!")


def add_GenieSimServiceServicer_to_server(servicer: GenieSimServiceServicer, server):
    """
    Add a GenieSimServiceServicer to a gRPC server.

    Args:
        servicer: The servicer implementation
        server: The gRPC server to add the servicer to
    """
    if not GRPC_AVAILABLE:
        raise RuntimeError("gRPC not available")

    rpc_method_handlers = {}

    for method_name, descriptor in _SERVICE_METHODS.items():
        handler_fn = getattr(servicer, method_name)
        rpc_method_handlers[method_name] = grpc.unary_unary_rpc_method_handler(
            handler_fn,
            request_deserializer=lambda data, t=descriptor.request_type: t.FromString(data) if hasattr(t, 'FromString') else t(),
            response_serializer=descriptor.request_serializer,
        )

    generic_handler = grpc.method_handlers_generic_handler(
        "geniesim.GenieSimService",
        rpc_method_handlers,
    )
    server.add_generic_rpc_handlers((generic_handler,))


# =============================================================================
# Utility Functions
# =============================================================================


def is_grpc_available() -> bool:
    """Check if gRPC is available."""
    return GRPC_AVAILABLE


def create_channel(
    host: Optional[str] = None,
    port: Optional[int] = None,
    options: Optional[list] = None,
) -> Any:
    """
    Create a gRPC channel.

    Args:
        host: Server hostname (defaults to GENIESIM_HOST or "localhost")
        port: Server port (defaults to GENIESIM_PORT or 50051)
        options: Optional channel options

    Returns:
        gRPC channel or None if gRPC not available
    """
    if not GRPC_AVAILABLE:
        return None

    if host is None:
        host = os.getenv("GENIESIM_HOST", "localhost")
    if port is None:
        port = int(os.getenv("GENIESIM_PORT", "50051"))

    if options is None:
        options = [
            ('grpc.max_receive_message_length', 16 * 1024 * 1024),
            ('grpc.max_send_message_length', 16 * 1024 * 1024),
        ]

    return grpc.insecure_channel(f"{host}:{port}", options=options)
