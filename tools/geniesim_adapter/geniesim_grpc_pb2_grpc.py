#!/usr/bin/env python3
"""
gRPC Service Stubs for Genie Sim Data Collection.

This module provides the gRPC client and server stubs for communicating with
the Genie Sim data collection server running inside Isaac Sim.

These would normally be auto-generated by grpc_tools.protoc, but are implemented
manually here for compatibility when grpc_tools is not available.

Usage:
    from geniesim_grpc_pb2_grpc import GenieSimServiceStub, create_channel

    channel = create_channel()
    stub = GenieSimServiceStub(channel)
    response = stub.GetObservation(GetObservationRequest(...))
"""

import json
import logging
import os
import threading
import time
from pathlib import Path
from typing import Any, Callable, Iterator, Optional

from .geniesim_grpc_pb2 import (
    AddCameraRequest, AddCameraResponse,
    AttachObjectRequest, AttachObjectResponse,
    CameraObservation,
    CommandRequest, CommandResponse,
    CommandType,
    DetachObjectRequest, DetachObjectResponse,
    GetEEPoseRequest, GetEEPoseResponse,
    GetGripperStateRequest, GetGripperStateResponse,
    GetIKStatusRequest, GetIKStatusResponse,
    GetJointPositionRequest, GetJointPositionResponse,
    GetObjectPoseRequest, GetObjectPoseResponse,
    GetObservationRequest, GetObservationResponse,
    InitRobotRequest, InitRobotResponse,
    JointState,
    LinearMoveRequest, LinearMoveResponse,
    Pose,
    Quaternion,
    ResetRequest, ResetResponse,
    RobotState,
    SceneState,
    SetGripperStateRequest, SetGripperStateResponse,
    SetJointPositionRequest, SetJointPositionResponse,
    SetObjectPoseRequest, SetObjectPoseResponse,
    SetTrajectoryRequest, SetTrajectoryResponse,
    StartRecordingRequest, StartRecordingResponse,
    StopRecordingRequest, StopRecordingResponse,
    TaskStatusRequest, TaskStatusResponse,
    TrajectoryPoint,
    Vector3,
)


# Try to import grpc
try:
    import grpc
    GRPC_AVAILABLE = True
except ImportError:
    GRPC_AVAILABLE = False
    grpc = None

logger = logging.getLogger(__name__)


# =============================================================================
# Service Method Descriptors
# =============================================================================


class _MethodDescriptor:
    """Descriptor for a gRPC method."""

    def __init__(
        self,
        name: str,
        request_type: type,
        response_type: type,
        request_serializer: Callable,
        response_deserializer: Callable,
        response_streaming: bool = False,
    ):
        self.name = name
        self.full_name = f"/geniesim.GenieSimService/{name}"
        self.request_type = request_type
        self.response_type = response_type
        self.request_serializer = request_serializer
        self.response_deserializer = response_deserializer
        self.response_streaming = response_streaming


# Define service methods
_SERVICE_METHODS = {
    "GetObservation": _MethodDescriptor(
        "GetObservation",
        GetObservationRequest,
        GetObservationResponse,
        lambda req: req.SerializeToString(),
        GetObservationResponse.FromString,
    ),
    "GetJointPosition": _MethodDescriptor(
        "GetJointPosition",
        GetJointPositionRequest,
        GetJointPositionResponse,
        lambda req: req.SerializeToString(),
        GetJointPositionResponse.FromString,
    ),
    "SetJointPosition": _MethodDescriptor(
        "SetJointPosition",
        SetJointPositionRequest,
        SetJointPositionResponse,
        lambda req: req.SerializeToString(),
        SetJointPositionResponse.FromString,
    ),
    "GetEEPose": _MethodDescriptor(
        "GetEEPose",
        GetEEPoseRequest,
        GetEEPoseResponse,
        lambda req: req.SerializeToString(),
        GetEEPoseResponse.FromString,
    ),
    "GetGripperState": _MethodDescriptor(
        "GetGripperState",
        GetGripperStateRequest,
        GetGripperStateResponse,
        lambda req: req.SerializeToString(),
        GetGripperStateResponse.FromString,
    ),
    "GetIKStatus": _MethodDescriptor(
        "GetIKStatus",
        GetIKStatusRequest,
        GetIKStatusResponse,
        lambda req: req.SerializeToString(),
        GetIKStatusResponse.FromString,
    ),
    "GetTaskStatus": _MethodDescriptor(
        "GetTaskStatus",
        TaskStatusRequest,
        TaskStatusResponse,
        lambda req: req.SerializeToString(),
        TaskStatusResponse.FromString,
    ),
    "LinearMove": _MethodDescriptor(
        "LinearMove",
        LinearMoveRequest,
        LinearMoveResponse,
        lambda req: req.SerializeToString(),
        LinearMoveResponse.FromString,
    ),
    "SetGripperState": _MethodDescriptor(
        "SetGripperState",
        SetGripperStateRequest,
        SetGripperStateResponse,
        lambda req: req.SerializeToString(),
        SetGripperStateResponse.FromString,
    ),
    "GetObjectPose": _MethodDescriptor(
        "GetObjectPose",
        GetObjectPoseRequest,
        GetObjectPoseResponse,
        lambda req: req.SerializeToString(),
        GetObjectPoseResponse.FromString,
    ),
    "SetObjectPose": _MethodDescriptor(
        "SetObjectPose",
        SetObjectPoseRequest,
        SetObjectPoseResponse,
        lambda req: req.SerializeToString(),
        SetObjectPoseResponse.FromString,
    ),
    "InitRobot": _MethodDescriptor(
        "InitRobot",
        InitRobotRequest,
        InitRobotResponse,
        lambda req: req.SerializeToString(),
        InitRobotResponse.FromString,
    ),
    "AttachObject": _MethodDescriptor(
        "AttachObject",
        AttachObjectRequest,
        AttachObjectResponse,
        lambda req: req.SerializeToString(),
        AttachObjectResponse.FromString,
    ),
    "DetachObject": _MethodDescriptor(
        "DetachObject",
        DetachObjectRequest,
        DetachObjectResponse,
        lambda req: req.SerializeToString(),
        DetachObjectResponse.FromString,
    ),
    "SetTrajectory": _MethodDescriptor(
        "SetTrajectory",
        SetTrajectoryRequest,
        SetTrajectoryResponse,
        lambda req: req.SerializeToString(),
        SetTrajectoryResponse.FromString,
    ),
    "StartRecording": _MethodDescriptor(
        "StartRecording",
        StartRecordingRequest,
        StartRecordingResponse,
        lambda req: req.SerializeToString(),
        StartRecordingResponse.FromString,
    ),
    "StopRecording": _MethodDescriptor(
        "StopRecording",
        StopRecordingRequest,
        StopRecordingResponse,
        lambda req: req.SerializeToString(),
        StopRecordingResponse.FromString,
    ),
    "Reset": _MethodDescriptor(
        "Reset",
        ResetRequest,
        ResetResponse,
        lambda req: req.SerializeToString(),
        ResetResponse.FromString,
    ),
    "AddCamera": _MethodDescriptor(
        "AddCamera",
        AddCameraRequest,
        AddCameraResponse,
        lambda req: req.SerializeToString(),
        AddCameraResponse.FromString,
    ),
    "SendCommand": _MethodDescriptor(
        "SendCommand",
        CommandRequest,
        CommandResponse,
        lambda req: req.SerializeToString(),
        CommandResponse.FromString,
    ),
    "StreamObservations": _MethodDescriptor(
        "StreamObservations",
        GetObservationRequest,
        GetObservationResponse,
        lambda req: req.SerializeToString(),
        GetObservationResponse.FromString,
        response_streaming=True,
    ),
}


# =============================================================================
# Service Stub (Client)
# =============================================================================


class GenieSimServiceStub:
    """
    gRPC client stub for GenieSimService.

    Provides methods for communicating with the Genie Sim data collection
    server running inside Isaac Sim.

    Usage:
        channel = create_channel()
        stub = GenieSimServiceStub(channel)

        # Get observation
        response = stub.GetObservation(GetObservationRequest(include_images=True))

        # Set joint positions
        response = stub.SetJointPosition(SetJointPositionRequest(
            positions=[0.0, -0.5, 0.0, -2.0, 0.0, 2.5, 0.8]
        ))
    """

    def __init__(self, channel):
        """
        Initialize the stub.

        Args:
            channel: gRPC channel to use for communication
        """
        self._channel = channel

        if GRPC_AVAILABLE and channel is not None:
            # Create method stubs
            for method_name, descriptor in _SERVICE_METHODS.items():
                handler_factory = channel.unary_stream if descriptor.response_streaming else channel.unary_unary
                setattr(
                    self,
                    f"_{method_name}_stub",
                    handler_factory(
                        descriptor.full_name,
                        request_serializer=descriptor.request_serializer,
                        response_deserializer=descriptor.response_deserializer,
                    )
                )

    def GetObservation(
        self,
        request: GetObservationRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetObservationResponse:
        """Get current observation from simulation."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetObservation_stub(request, timeout=timeout, metadata=metadata)

    def GetJointPosition(
        self,
        request: GetJointPositionRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetJointPositionResponse:
        """Get current joint positions."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetJointPosition_stub(request, timeout=timeout, metadata=metadata)

    def SetJointPosition(
        self,
        request: SetJointPositionRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetJointPositionResponse:
        """Set robot joint positions."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetJointPosition_stub(request, timeout=timeout, metadata=metadata)

    def GetEEPose(
        self,
        request: GetEEPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetEEPoseResponse:
        """Get end-effector pose."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetEEPose_stub(request, timeout=timeout, metadata=metadata)

    def GetGripperState(
        self,
        request: GetGripperStateRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetGripperStateResponse:
        """Get gripper state."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetGripperState_stub(request, timeout=timeout, metadata=metadata)

    def GetIKStatus(
        self,
        request: GetIKStatusRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetIKStatusResponse:
        """Get IK solver status."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetIKStatus_stub(request, timeout=timeout, metadata=metadata)

    def GetTaskStatus(
        self,
        request: TaskStatusRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> TaskStatusResponse:
        """Get task status."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetTaskStatus_stub(request, timeout=timeout, metadata=metadata)

    def SetGripperState(
        self,
        request: SetGripperStateRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetGripperStateResponse:
        """Set gripper state (width and force)."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetGripperState_stub(request, timeout=timeout, metadata=metadata)

    def LinearMove(
        self,
        request: LinearMoveRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> LinearMoveResponse:
        """Execute a linear move."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._LinearMove_stub(request, timeout=timeout, metadata=metadata)

    def GetObjectPose(
        self,
        request: GetObjectPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetObjectPoseResponse:
        """Get object pose."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._GetObjectPose_stub(request, timeout=timeout, metadata=metadata)

    def InitRobot(
        self,
        request: InitRobotRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> InitRobotResponse:
        """Initialize robot."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._InitRobot_stub(request, timeout=timeout, metadata=metadata)

    def SetObjectPose(
        self,
        request: SetObjectPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetObjectPoseResponse:
        """Set object pose."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetObjectPose_stub(request, timeout=timeout, metadata=metadata)

    def AttachObject(
        self,
        request: AttachObjectRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> AttachObjectResponse:
        """Attach an object to a robot link."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._AttachObject_stub(request, timeout=timeout, metadata=metadata)

    def DetachObject(
        self,
        request: DetachObjectRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> DetachObjectResponse:
        """Detach an object from a robot link."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._DetachObject_stub(request, timeout=timeout, metadata=metadata)

    def SetTrajectory(
        self,
        request: SetTrajectoryRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetTrajectoryResponse:
        """Execute a trajectory."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SetTrajectory_stub(request, timeout=timeout, metadata=metadata)

    def StartRecording(
        self,
        request: StartRecordingRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> StartRecordingResponse:
        """Start recording an episode."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._StartRecording_stub(request, timeout=timeout, metadata=metadata)

    def StopRecording(
        self,
        request: StopRecordingRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> StopRecordingResponse:
        """Stop recording current episode."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._StopRecording_stub(request, timeout=timeout, metadata=metadata)

    def Reset(
        self,
        request: ResetRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> ResetResponse:
        """Reset the simulation environment."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._Reset_stub(request, timeout=timeout, metadata=metadata)

    def AddCamera(
        self,
        request: AddCameraRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> AddCameraResponse:
        """Add a camera to the simulation."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._AddCamera_stub(request, timeout=timeout, metadata=metadata)

    def SendCommand(
        self,
        request: CommandRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> CommandResponse:
        """Send a generic command."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._SendCommand_stub(request, timeout=timeout, metadata=metadata)

    def StreamObservations(
        self,
        request: GetObservationRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> Iterator[GetObservationResponse]:
        """Stream observations from simulation."""
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        return self._StreamObservations_stub(request, timeout=timeout, metadata=metadata)

# =============================================================================
# Service Servicer (Server - for reference/testing)
# =============================================================================


class GenieSimServiceServicer:
    """
    Base class for GenieSimService server implementation.

    Override these methods to implement the server-side logic.
    This is primarily useful for testing and for understanding the expected
    server behavior.
    """

    def __init__(self, joint_count: int = 7, delegate: Optional[Any] = None) -> None:
        self._delegate = delegate
        self._state_lock = threading.Lock()
        self._joint_positions = [0.0] * joint_count
        self._joint_velocities = [0.0] * joint_count
        self._joint_efforts = [0.0] * joint_count
        self._joint_names = [f"joint_{idx}" for idx in range(joint_count)]
        self._object_poses = {}
        self._attached_objects = {}
        self._cameras = {}
        self._ee_pose = self._default_pose()
        self._gripper_width = 0.0
        self._gripper_force = 0.0
        self._gripper_is_grasping = False
        self._recording = None

    def GetObservation(
        self,
        request: GetObservationRequest,
        context,
    ) -> GetObservationResponse:
        """Get current observation from simulation."""
        delegate = self._resolve_delegate("GetObservation")
        if delegate:
            return self._call_delegate(delegate, request, context, GetObservationResponse(success=False))
        with self._state_lock:
            joint_state = self._build_joint_state()
            ee_pose = self._ee_pose
        robot_state = RobotState(
            joint_state=joint_state,
            end_effector_pose=ee_pose,
            gripper_width=self._gripper_width,
            gripper_is_grasping=self._gripper_is_grasping,
            link_poses=[],
            link_names=[],
        )
        scene_state = SceneState(objects=[], simulation_time=time.time(), step_count=0)
        camera_observation = CameraObservation(images=[])
        return GetObservationResponse(
            success=True,
            robot_state=robot_state,
            scene_state=scene_state,
            camera_observation=camera_observation,
            timestamp=time.time(),
        )

    def GetJointPosition(
        self,
        request: GetJointPositionRequest,
        context,
    ) -> GetJointPositionResponse:
        """Get current joint positions."""
        delegate = self._resolve_delegate("GetJointPosition")
        if delegate:
            return self._call_delegate(delegate, request, context, GetJointPositionResponse(success=False))
        with self._state_lock:
            joint_state = self._build_joint_state()
        return GetJointPositionResponse(success=True, joint_state=joint_state)

    def SetJointPosition(
        self,
        request: SetJointPositionRequest,
        context,
    ) -> SetJointPositionResponse:
        """Set robot joint positions."""
        delegate = self._resolve_delegate("SetJointPosition")
        if delegate:
            return self._call_delegate(delegate, request, context, SetJointPositionResponse(success=False))
        if not request.positions:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "No joint positions provided")
            return SetJointPositionResponse(success=False, error_message="No joint positions provided")
        with self._state_lock:
            self._joint_positions = list(request.positions)
            self._joint_velocities = list(request.velocities) or [0.0] * len(self._joint_positions)
            self._joint_efforts = [0.0] * len(self._joint_positions)
            joint_state = self._build_joint_state()
        return SetJointPositionResponse(success=True, current_state=joint_state)

    def GetEEPose(
        self,
        request: GetEEPoseRequest,
        context,
    ) -> GetEEPoseResponse:
        """Get end-effector pose."""
        delegate = self._resolve_delegate("GetEEPose")
        if delegate:
            return self._call_delegate(delegate, request, context, GetEEPoseResponse(success=False))
        with self._state_lock:
            pose = self._ee_pose
        return GetEEPoseResponse(success=True, pose=pose)

    def GetGripperState(
        self,
        request: GetGripperStateRequest,
        context,
    ) -> GetGripperStateResponse:
        """Get gripper state."""
        delegate = self._resolve_delegate("GetGripperState")
        if delegate:
            return self._call_delegate(delegate, request, context, GetGripperStateResponse(success=False))
        with self._state_lock:
            width = self._gripper_width
            force = self._gripper_force
            is_grasping = self._gripper_is_grasping
        return GetGripperStateResponse(success=True, width=width, is_grasping=is_grasping, force=force)

    def GetIKStatus(
        self,
        request: GetIKStatusRequest,
        context,
    ) -> GetIKStatusResponse:
        """Get IK status."""
        delegate = self._resolve_delegate("GetIKStatus")
        if delegate:
            return self._call_delegate(delegate, request, context, GetIKStatusResponse(success=False))
        return self._unsupported_method(
            "GetIKStatus",
            context,
            GetIKStatusResponse(success=False, ik_solvable=False, error_message="IK solver not available"),
        )

    def GetTaskStatus(
        self,
        request: TaskStatusRequest,
        context,
    ) -> TaskStatusResponse:
        """Get task status."""
        delegate = self._resolve_delegate("GetTaskStatus")
        if delegate:
            return self._call_delegate(delegate, request, context, TaskStatusResponse(success=False))
        return self._unsupported_method(
            "GetTaskStatus",
            context,
            TaskStatusResponse(success=False, status="unknown", progress=0.0, error_message="Task status unavailable"),
        )

    def SetGripperState(
        self,
        request: SetGripperStateRequest,
        context,
    ) -> SetGripperStateResponse:
        """Set gripper state."""
        delegate = self._resolve_delegate("SetGripperState")
        if delegate:
            return self._call_delegate(delegate, request, context, SetGripperStateResponse(success=False))
        with self._state_lock:
            self._gripper_width = request.width
            self._gripper_force = request.force
            self._gripper_is_grasping = request.force > 0.0 and request.width <= 0.02
        return SetGripperStateResponse(
            success=True,
            current_width=self._gripper_width,
            is_grasping=self._gripper_is_grasping,
        )

    def LinearMove(
        self,
        request: LinearMoveRequest,
        context,
    ) -> LinearMoveResponse:
        """Move the end-effector linearly to a target pose."""
        delegate = self._resolve_delegate("LinearMove")
        if delegate:
            return self._call_delegate(delegate, request, context, LinearMoveResponse(success=False))
        if request.target_pose is None:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "target_pose is required")
            return LinearMoveResponse(
                success=False,
                error_message="target_pose is required",
                planning_success=False,
                execution_success=False,
            )
        with self._state_lock:
            self._ee_pose = request.target_pose
        return LinearMoveResponse(
            success=True,
            planning_success=True,
            execution_success=True,
        )

    def GetObjectPose(
        self,
        request: GetObjectPoseRequest,
        context,
    ) -> GetObjectPoseResponse:
        """Get object pose."""
        delegate = self._resolve_delegate("GetObjectPose")
        if delegate:
            return self._call_delegate(delegate, request, context, GetObjectPoseResponse(success=False))
        if not request.object_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id is required")
            return GetObjectPoseResponse(success=False, error_message="object_id is required")
        with self._state_lock:
            pose = self._object_poses.get(request.object_id)
        if pose is None:
            self._set_context_status(context, self._grpc_status("NOT_FOUND"), "object not found")
            return GetObjectPoseResponse(success=False, error_message="object not found")
        return GetObjectPoseResponse(success=True, pose=pose)

    def SetObjectPose(
        self,
        request: SetObjectPoseRequest,
        context,
    ) -> SetObjectPoseResponse:
        """Set object pose."""
        delegate = self._resolve_delegate("SetObjectPose")
        if delegate:
            return self._call_delegate(delegate, request, context, SetObjectPoseResponse(success=False))
        if not request.object_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id is required")
            return SetObjectPoseResponse(success=False, error_message="object_id is required")
        if request.pose is None:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "pose is required")
            return SetObjectPoseResponse(success=False, error_message="pose is required")
        with self._state_lock:
            self._object_poses[request.object_id] = request.pose
        return SetObjectPoseResponse(success=True)

    def InitRobot(
        self,
        request: InitRobotRequest,
        context,
    ) -> InitRobotResponse:
        """Initialize the robot model."""
        delegate = self._resolve_delegate("InitRobot")
        if delegate:
            return self._call_delegate(delegate, request, context, InitRobotResponse(success=False))
        with self._state_lock:
            if request.initial_joint_positions:
                joint_count = len(request.initial_joint_positions)
                self._joint_positions = list(request.initial_joint_positions)
                self._joint_velocities = [0.0] * joint_count
                self._joint_efforts = [0.0] * joint_count
                self._joint_names = [f"joint_{idx}" for idx in range(joint_count)]
            num_joints = len(self._joint_positions)
            joint_names = list(self._joint_names)
        return InitRobotResponse(
            success=True,
            num_joints=num_joints,
            joint_names=joint_names,
        )

    def AttachObject(
        self,
        request: AttachObjectRequest,
        context,
    ) -> AttachObjectResponse:
        """Attach an object to a robot link."""
        delegate = self._resolve_delegate("AttachObject")
        if delegate:
            return self._call_delegate(delegate, request, context, AttachObjectResponse(success=False))
        if not request.object_id or not request.link_name:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id and link_name required")
            return AttachObjectResponse(success=False, error_message="object_id and link_name required")
        with self._state_lock:
            self._attached_objects[request.object_id] = request.link_name
        return AttachObjectResponse(success=True)

    def DetachObject(
        self,
        request: DetachObjectRequest,
        context,
    ) -> DetachObjectResponse:
        """Detach an object from a robot link."""
        delegate = self._resolve_delegate("DetachObject")
        if delegate:
            return self._call_delegate(delegate, request, context, DetachObjectResponse(success=False))
        if not request.object_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id required")
            return DetachObjectResponse(success=False, error_message="object_id required")
        with self._state_lock:
            if request.object_id not in self._attached_objects:
                self._set_context_status(context, self._grpc_status("NOT_FOUND"), "object not attached")
                return DetachObjectResponse(success=False, error_message="object not attached")
            self._attached_objects.pop(request.object_id, None)
        return DetachObjectResponse(success=True)

    def SetTrajectory(
        self,
        request: SetTrajectoryRequest,
        context,
    ) -> SetTrajectoryResponse:
        """Execute a trajectory."""
        delegate = self._resolve_delegate("SetTrajectory")
        if delegate:
            return self._call_delegate(delegate, request, context, SetTrajectoryResponse(success=False))
        if not request.points:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "Trajectory points are required")
            return SetTrajectoryResponse(success=False, error_message="Trajectory points are required")
        last_point: TrajectoryPoint = request.points[-1]
        with self._state_lock:
            if last_point.positions:
                self._joint_positions = list(last_point.positions)
                self._joint_velocities = list(last_point.velocities) or [0.0] * len(self._joint_positions)
                self._joint_efforts = [0.0] * len(self._joint_positions)
        execution_time = max(last_point.time_from_start, 0.0)
        return SetTrajectoryResponse(
            success=True,
            points_executed=len(request.points),
            execution_time=execution_time,
        )

    def StartRecording(
        self,
        request: StartRecordingRequest,
        context,
    ) -> StartRecordingResponse:
        """Start recording an episode."""
        delegate = self._resolve_delegate("StartRecording")
        if delegate:
            return self._call_delegate(delegate, request, context, StartRecordingResponse(success=False))
        episode_id = request.episode_id or f"episode-{int(time.time())}"
        output_dir = Path(request.output_directory or "/tmp/geniesim_recordings")
        recording_path = output_dir / episode_id
        try:
            recording_path.mkdir(parents=True, exist_ok=True)
        except OSError as exc:
            self._set_context_status(context, self._grpc_status("INTERNAL"), "Failed to create recording directory")
            return StartRecordingResponse(success=False, error_message=str(exc))
        with self._state_lock:
            self._recording = {
                "episode_id": episode_id,
                "output_directory": recording_path,
                "started_at": time.time(),
                "frames_recorded": 0,
            }
        return StartRecordingResponse(success=True, recording_path=str(recording_path))

    def StopRecording(
        self,
        request: StopRecordingRequest,
        context,
    ) -> StopRecordingResponse:
        """Stop recording current episode."""
        delegate = self._resolve_delegate("StopRecording")
        if delegate:
            return self._call_delegate(delegate, request, context, StopRecordingResponse(success=False))
        with self._state_lock:
            recording = self._recording
            self._recording = None
        if recording is None:
            self._set_context_status(context, self._grpc_status("FAILED_PRECONDITION"), "No active recording")
            return StopRecordingResponse(success=False, error_message="No active recording")
        duration = max(time.time() - recording["started_at"], 0.0)
        return StopRecordingResponse(
            success=True,
            frames_recorded=recording["frames_recorded"],
            duration_seconds=duration,
            recording_path=str(recording["output_directory"]),
        )

    def Reset(
        self,
        request: ResetRequest,
        context,
    ) -> ResetResponse:
        """Reset the simulation environment."""
        delegate = self._resolve_delegate("Reset")
        if delegate:
            return self._call_delegate(delegate, request, context, ResetResponse(success=False))
        with self._state_lock:
            self._joint_positions = [0.0] * len(self._joint_positions)
            self._joint_velocities = [0.0] * len(self._joint_positions)
            self._joint_efforts = [0.0] * len(self._joint_positions)
            self._ee_pose = self._default_pose()
            self._gripper_width = 0.0
            self._gripper_force = 0.0
            self._gripper_is_grasping = False
            self._object_poses.clear()
            self._attached_objects.clear()
            self._cameras.clear()
            self._recording = None
        return ResetResponse(success=True)

    def AddCamera(
        self,
        request: AddCameraRequest,
        context,
    ) -> AddCameraResponse:
        """Add a camera to the scene."""
        delegate = self._resolve_delegate("AddCamera")
        if delegate:
            return self._call_delegate(delegate, request, context, AddCameraResponse(success=False))
        if not request.camera_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "camera_id is required")
            return AddCameraResponse(success=False, error_message="camera_id is required")
        with self._state_lock:
            self._cameras[request.camera_id] = request
        return AddCameraResponse(success=True)

    def SendCommand(
        self,
        request: CommandRequest,
        context,
    ) -> CommandResponse:
        """Send a generic command."""
        delegate = self._resolve_delegate("SendCommand")
        if delegate:
            return self._call_delegate(delegate, request, context, CommandResponse(success=False))
        payload_data = {}
        if request.payload:
            try:
                payload_data = json.loads(request.payload.decode())
            except json.JSONDecodeError:
                self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "Invalid JSON payload")
                return CommandResponse(success=False, error_message="Invalid JSON payload")
        command_type = request.command_type
        try:
            if command_type == CommandType.GET_OBSERVATION:
                response = self.GetObservation(
                    GetObservationRequest(
                        include_images=payload_data.get("include_images", False),
                        include_depth=payload_data.get("include_depth", False),
                        include_semantic=payload_data.get("include_semantic", False),
                        camera_ids=payload_data.get("camera_ids", []),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_observation(response)).encode(),
                )
            if command_type == CommandType.GET_JOINT_POSITION:
                response = self.GetJointPosition(GetJointPositionRequest(), context)
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_joint_state(response)).encode(),
                )
            if command_type == CommandType.SET_JOINT_POSITION:
                response = self.SetJointPosition(
                    SetJointPositionRequest(
                        positions=payload_data.get("positions", []),
                        velocities=payload_data.get("velocities", []),
                        duration=payload_data.get("duration", 0.0),
                        wait_for_completion=payload_data.get("wait_for_completion", False),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_set_joint(response)).encode(),
                )
            if command_type == CommandType.GET_EE_POSE:
                response = self.GetEEPose(
                    GetEEPoseRequest(ee_link_name=payload_data.get("ee_link_name", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_pose(response.pose)).encode(),
                )
            if command_type == CommandType.GET_GRIPPER_STATE:
                response = self.GetGripperState(GetGripperStateRequest(), context)
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_gripper_state(response)).encode(),
                )
            if command_type == CommandType.SET_GRIPPER_STATE:
                response = self.SetGripperState(
                    SetGripperStateRequest(
                        width=payload_data.get("width", 0.0),
                        force=payload_data.get("force", 0.0),
                        wait_for_completion=payload_data.get("wait_for_completion", False),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_gripper(response)).encode(),
                )
            if command_type == CommandType.LINEAR_MOVE:
                target_pose_payload = payload_data.get("target_pose")
                response = self.LinearMove(
                    LinearMoveRequest(
                        target_pose=self._pose_from_payload(target_pose_payload) if target_pose_payload else None,
                        velocity=payload_data.get("velocity", 0.0),
                        acceleration=payload_data.get("acceleration", 0.0),
                        wait_for_completion=payload_data.get("wait_for_completion", False),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_linear_move(response)).encode(),
                )
            if command_type == CommandType.GET_OBJECT_POSE:
                response = self.GetObjectPose(
                    GetObjectPoseRequest(object_id=payload_data.get("object_id", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_object_pose(response)).encode(),
                )
            if command_type == CommandType.SET_OBJECT_POSE:
                response = self.SetObjectPose(
                    SetObjectPoseRequest(
                        object_id=payload_data.get("object_id", ""),
                        pose=self._pose_from_payload(payload_data.get("pose")),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.ATTACH_OBJ:
                response = self.AttachObject(
                    AttachObjectRequest(
                        object_id=payload_data.get("object_id", ""),
                        link_name=payload_data.get("link_name", ""),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.DETACH_OBJ:
                response = self.DetachObject(
                    DetachObjectRequest(object_id=payload_data.get("object_id", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.GET_IK_STATUS:
                response = self.GetIKStatus(
                    GetIKStatusRequest(
                        target_pose=self._pose_from_payload(payload_data.get("target_pose")),
                        seed_positions=payload_data.get("seed_positions", []),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_ik_status(response)).encode(),
                )
            if command_type == CommandType.TASK_STATUS:
                response = self.GetTaskStatus(
                    TaskStatusRequest(task_id=payload_data.get("task_id", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_task_status(response)).encode(),
                )
            if command_type == CommandType.INIT_ROBOT:
                response = self.InitRobot(
                    InitRobotRequest(
                        robot_type=payload_data.get("robot_type", ""),
                        urdf_path=payload_data.get("urdf_path", ""),
                        base_pose=self._pose_from_payload(payload_data.get("base_pose")),
                        initial_joint_positions=payload_data.get("initial_joint_positions", []),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_init_robot(response)).encode(),
                )
            if command_type == CommandType.ADD_CAMERA:
                response = self.AddCamera(
                    AddCameraRequest(
                        camera_id=payload_data.get("camera_id", ""),
                        pose=self._pose_from_payload(payload_data.get("pose")),
                        parent_link=payload_data.get("parent_link", ""),
                        width=payload_data.get("width", 0),
                        height=payload_data.get("height", 0),
                        fov=payload_data.get("fov", 0.0),
                        near_clip=payload_data.get("near_clip", 0.0),
                        far_clip=payload_data.get("far_clip", 0.0),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.RESET:
                response = self.Reset(ResetRequest(), context)
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
        except Exception as exc:
            self._set_context_status(context, self._grpc_status("INTERNAL"), "Command handling failed")
            return CommandResponse(success=False, error_message=str(exc))
        self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "Unsupported command type")
        return CommandResponse(success=False, error_message="Unsupported command type")

    def StreamObservations(
        self,
        request: GetObservationRequest,
        context,
    ) -> Iterator[GetObservationResponse]:
        """Stream observations from simulation."""
        delegate = self._resolve_delegate("StreamObservations")
        if delegate:
            return self._call_delegate(delegate, request, context, iter(()))
        logger.warning("StreamObservations is not implemented in the test servicer.")
        self._set_context_status(context, self._grpc_status("UNIMPLEMENTED"), "StreamObservations not implemented")
        return iter(())

    def _resolve_delegate(self, method_name: str) -> Optional[Callable]:
        if self._delegate is None:
            return None
        handler = getattr(self._delegate, method_name, None)
        if handler is None:
            return None
        base_handler = getattr(GenieSimServiceServicer, method_name, None)
        if base_handler and getattr(handler, "__func__", None) is base_handler:
            return None
        return handler

    def _call_delegate(self, handler: Callable, request: Any, context: Any, fallback_response: Any) -> Any:
        try:
            return handler(request, context)
        except Exception as exc:
            self._set_context_status(context, self._grpc_status("INTERNAL"), "Delegate failure")
            if hasattr(fallback_response, "error_message"):
                fallback_response.error_message = str(exc)
            return fallback_response

    def _unsupported_method(self, method_name: str, context: Any, fallback_response: Any) -> Any:
        logger.warning("%s is not implemented in the test servicer.", method_name)
        self._set_context_status(context, self._grpc_status("UNIMPLEMENTED"), f"{method_name} not implemented")
        if hasattr(fallback_response, "error_message") and not fallback_response.error_message:
            fallback_response.error_message = f"{method_name} not implemented"
        return fallback_response

    @staticmethod
    def _set_context_status(context: Any, code: Any, details: str) -> None:
        if context is None:
            return
        if grpc is not None and code is not None:
            try:
                context.set_code(code)
            except Exception:
                return
        try:
            context.set_details(details)
        except Exception:
            return

    @staticmethod
    def _payload_for_observation(response: GetObservationResponse) -> dict:
        return {
            "success": response.success,
            "robot_state": response.robot_state.to_dict() if response.robot_state else {},
            "scene_state": response.scene_state.to_dict() if response.scene_state else {},
            "timestamp": response.timestamp,
        }

    @staticmethod
    def _payload_for_joint_state(response: GetJointPositionResponse) -> dict:
        return {
            "success": response.success,
            "joint_state": response.joint_state.to_dict() if response.joint_state else {},
        }

    @staticmethod
    def _payload_for_set_joint(response: SetJointPositionResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "current_state": response.current_state.to_dict() if response.current_state else {},
        }

    @staticmethod
    def _payload_for_pose(pose: Optional[Pose]) -> dict:
        return {"pose": pose.to_dict() if pose else {}}

    @staticmethod
    def _payload_for_gripper(response: SetGripperStateResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "current_width": response.current_width,
            "is_grasping": response.is_grasping,
        }

    @staticmethod
    def _payload_for_gripper_state(response: GetGripperStateResponse) -> dict:
        return {
            "success": response.success,
            "width": response.width,
            "is_grasping": response.is_grasping,
            "force": response.force,
        }

    @staticmethod
    def _payload_for_object_pose(response: GetObjectPoseResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "pose": response.pose.to_dict() if response.pose else {},
        }

    @staticmethod
    def _payload_for_linear_move(response: LinearMoveResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "planning_success": response.planning_success,
            "execution_success": response.execution_success,
        }

    @staticmethod
    def _payload_for_ik_status(response: GetIKStatusResponse) -> dict:
        return {
            "success": response.success,
            "ik_solvable": response.ik_solvable,
            "solution": response.solution,
            "error_message": response.error_message,
        }

    @staticmethod
    def _payload_for_task_status(response: TaskStatusResponse) -> dict:
        return {
            "success": response.success,
            "status": response.status,
            "progress": response.progress,
            "error_message": response.error_message,
        }

    @staticmethod
    def _payload_for_init_robot(response: InitRobotResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "num_joints": response.num_joints,
            "joint_names": response.joint_names,
        }

    @staticmethod
    def _payload_for_simple(success: bool, error_message: str) -> dict:
        return {"success": success, "error_message": error_message}

    @staticmethod
    def _grpc_status(code_name: str) -> Any:
        if grpc is None:
            return None
        return getattr(grpc.StatusCode, code_name, None)

    def _build_joint_state(self) -> JointState:
        return JointState(
            positions=list(self._joint_positions),
            velocities=list(self._joint_velocities),
            efforts=list(self._joint_efforts),
            names=list(self._joint_names),
        )

    @staticmethod
    def _default_pose() -> Pose:
        return Pose(
            position=Vector3(x=0.0, y=0.0, z=0.0),
            orientation=Quaternion(w=1.0, x=0.0, y=0.0, z=0.0),
        )

    @classmethod
    def _pose_from_payload(cls, payload: Optional[dict]) -> Pose:
        if not payload:
            return cls._default_pose()
        position = payload.get("position") or {}
        orientation = payload.get("orientation") or {}
        return Pose(
            position=Vector3(
                x=float(position.get("x", 0.0)),
                y=float(position.get("y", 0.0)),
                z=float(position.get("z", 0.0)),
            ),
            orientation=Quaternion(
                w=float(orientation.get("w", 1.0)),
                x=float(orientation.get("x", 0.0)),
                y=float(orientation.get("y", 0.0)),
                z=float(orientation.get("z", 0.0)),
            ),
        )


def add_GenieSimServiceServicer_to_server(servicer: GenieSimServiceServicer, server):
    """
    Add a GenieSimServiceServicer to a gRPC server.

    Args:
        servicer: The servicer implementation
        server: The gRPC server to add the servicer to
    """
    if not GRPC_AVAILABLE:
        raise RuntimeError("gRPC not available")

    rpc_method_handlers = {}

    for method_name, descriptor in _SERVICE_METHODS.items():
        handler_fn = getattr(servicer, method_name)
        deserializer = lambda data, t=descriptor.request_type: t.FromString(data) if hasattr(t, "FromString") else t()
        if descriptor.response_streaming:
            rpc_method_handlers[method_name] = grpc.unary_stream_rpc_method_handler(
                handler_fn,
                request_deserializer=deserializer,
                response_serializer=descriptor.request_serializer,
            )
        else:
            rpc_method_handlers[method_name] = grpc.unary_unary_rpc_method_handler(
                handler_fn,
                request_deserializer=deserializer,
                response_serializer=descriptor.request_serializer,
            )

    generic_handler = grpc.method_handlers_generic_handler(
        "geniesim.GenieSimService",
        rpc_method_handlers,
    )
    server.add_generic_rpc_handlers((generic_handler,))


# =============================================================================
# Utility Functions
# =============================================================================


def is_grpc_available() -> bool:
    """Check if gRPC is available."""
    return GRPC_AVAILABLE


def create_channel(
    host: Optional[str] = None,
    port: Optional[int] = None,
    options: Optional[list] = None,
) -> Any:
    """
    Create a gRPC channel.

    Args:
        host: Server hostname (defaults to GENIESIM_HOST or adapter default)
        port: Server port (defaults to GENIESIM_PORT or adapter default)
        options: Optional channel options

    Returns:
        gRPC channel or None if gRPC not available
    """
    if not GRPC_AVAILABLE:
        return None

    if host is None or port is None:
        from tools.geniesim_adapter.config import get_geniesim_host, get_geniesim_port

    if host is None:
        host = get_geniesim_host()
    if port is None:
        port = get_geniesim_port()

    if options is None:
        options = [
            ('grpc.max_receive_message_length', 16 * 1024 * 1024),
            ('grpc.max_send_message_length', 16 * 1024 * 1024),
        ]

    return grpc.insecure_channel(f"{host}:{port}", options=options)
