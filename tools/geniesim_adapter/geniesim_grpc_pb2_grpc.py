#!/usr/bin/env python3
"""
gRPC Service Stubs for Genie Sim Data Collection.

This module provides the gRPC client and server stubs for communicating with
the Genie Sim data collection server running inside Isaac Sim.

Note:
    The base ``GenieSimServiceServicer`` does not implement an IK solver.
    Production deployments must supply a delegate that implements
    ``GetIKStatus``; otherwise the servicer raises a runtime error when that
    RPC is invoked.

These would normally be auto-generated by grpc_tools.protoc, but are implemented
manually here for compatibility when grpc_tools is not available.

Usage:
    from geniesim_grpc_pb2_grpc import GenieSimServiceStub, create_channel

    channel = create_channel()
    stub = GenieSimServiceStub(channel)
    response = stub.GetObservation(GetObservationRequest(...))
"""

import json
import logging
import os
import threading
import time
from collections import namedtuple
from pathlib import Path
from typing import Any, Callable, Iterator, Optional, Tuple

from .geniesim_grpc_pb2 import (
    AddCameraRequest, AddCameraResponse,
    AttachObjectRequest, AttachObjectResponse,
    CameraObservation,
    CommandRequest, CommandResponse,
    CommandType,
    DetachObjectRequest, DetachObjectResponse,
    GetEEPoseRequest, GetEEPoseResponse,
    GetGripperStateRequest, GetGripperStateResponse,
    GetIKStatusRequest, GetIKStatusResponse,
    GetJointPositionRequest, GetJointPositionResponse,
    GetObjectPoseRequest, GetObjectPoseResponse,
    GetObservationRequest, GetObservationResponse,
    InitRobotRequest, InitRobotResponse,
    JointState,
    LinearMoveRequest, LinearMoveResponse,
    Pose,
    Quaternion,
    ResetRequest, ResetResponse,
    RobotState,
    SceneState,
    SetGripperStateRequest, SetGripperStateResponse,
    SetJointPositionRequest, SetJointPositionResponse,
    SetObjectPoseRequest, SetObjectPoseResponse,
    SetTrajectoryRequest, SetTrajectoryResponse,
    StartRecordingRequest, StartRecordingResponse,
    StopRecordingRequest, StopRecordingResponse,
    TaskStatusRequest, TaskStatusResponse,
    TrajectoryPoint,
    Vector3,
)


# Try to import grpc
try:
    import grpc
    GRPC_AVAILABLE = True
except ImportError:
    GRPC_AVAILABLE = False
    grpc = None

logger = logging.getLogger(__name__)

_ClientCallDetails = namedtuple(
    "_ClientCallDetails",
    ("method", "timeout", "metadata", "credentials", "wait_for_ready", "compression"),
)


# =============================================================================
# Service Method Descriptors
# =============================================================================


class _MethodDescriptor:
    """Descriptor for a gRPC method."""

    def __init__(
        self,
        name: str,
        request_type: type,
        response_type: type,
        request_serializer: Callable,
        response_deserializer: Callable,
        response_streaming: bool = False,
    ):
        self.name = name
        self.full_name = f"/geniesim.GenieSimService/{name}"
        self.request_type = request_type
        self.response_type = response_type
        self.request_serializer = request_serializer
        self.response_deserializer = response_deserializer
        self.response_streaming = response_streaming


# Define service methods
_SERVICE_METHODS = {
    "GetObservation": _MethodDescriptor(
        "GetObservation",
        GetObservationRequest,
        GetObservationResponse,
        lambda req: req.SerializeToString(),
        GetObservationResponse.FromString,
    ),
    "GetJointPosition": _MethodDescriptor(
        "GetJointPosition",
        GetJointPositionRequest,
        GetJointPositionResponse,
        lambda req: req.SerializeToString(),
        GetJointPositionResponse.FromString,
    ),
    "SetJointPosition": _MethodDescriptor(
        "SetJointPosition",
        SetJointPositionRequest,
        SetJointPositionResponse,
        lambda req: req.SerializeToString(),
        SetJointPositionResponse.FromString,
    ),
    "GetEEPose": _MethodDescriptor(
        "GetEEPose",
        GetEEPoseRequest,
        GetEEPoseResponse,
        lambda req: req.SerializeToString(),
        GetEEPoseResponse.FromString,
    ),
    "GetGripperState": _MethodDescriptor(
        "GetGripperState",
        GetGripperStateRequest,
        GetGripperStateResponse,
        lambda req: req.SerializeToString(),
        GetGripperStateResponse.FromString,
    ),
    "GetIKStatus": _MethodDescriptor(
        "GetIKStatus",
        GetIKStatusRequest,
        GetIKStatusResponse,
        lambda req: req.SerializeToString(),
        GetIKStatusResponse.FromString,
    ),
    "GetTaskStatus": _MethodDescriptor(
        "GetTaskStatus",
        TaskStatusRequest,
        TaskStatusResponse,
        lambda req: req.SerializeToString(),
        TaskStatusResponse.FromString,
    ),
    "LinearMove": _MethodDescriptor(
        "LinearMove",
        LinearMoveRequest,
        LinearMoveResponse,
        lambda req: req.SerializeToString(),
        LinearMoveResponse.FromString,
    ),
    "SetGripperState": _MethodDescriptor(
        "SetGripperState",
        SetGripperStateRequest,
        SetGripperStateResponse,
        lambda req: req.SerializeToString(),
        SetGripperStateResponse.FromString,
    ),
    "GetObjectPose": _MethodDescriptor(
        "GetObjectPose",
        GetObjectPoseRequest,
        GetObjectPoseResponse,
        lambda req: req.SerializeToString(),
        GetObjectPoseResponse.FromString,
    ),
    "SetObjectPose": _MethodDescriptor(
        "SetObjectPose",
        SetObjectPoseRequest,
        SetObjectPoseResponse,
        lambda req: req.SerializeToString(),
        SetObjectPoseResponse.FromString,
    ),
    "InitRobot": _MethodDescriptor(
        "InitRobot",
        InitRobotRequest,
        InitRobotResponse,
        lambda req: req.SerializeToString(),
        InitRobotResponse.FromString,
    ),
    "AttachObject": _MethodDescriptor(
        "AttachObject",
        AttachObjectRequest,
        AttachObjectResponse,
        lambda req: req.SerializeToString(),
        AttachObjectResponse.FromString,
    ),
    "DetachObject": _MethodDescriptor(
        "DetachObject",
        DetachObjectRequest,
        DetachObjectResponse,
        lambda req: req.SerializeToString(),
        DetachObjectResponse.FromString,
    ),
    "SetTrajectory": _MethodDescriptor(
        "SetTrajectory",
        SetTrajectoryRequest,
        SetTrajectoryResponse,
        lambda req: req.SerializeToString(),
        SetTrajectoryResponse.FromString,
    ),
    "StartRecording": _MethodDescriptor(
        "StartRecording",
        StartRecordingRequest,
        StartRecordingResponse,
        lambda req: req.SerializeToString(),
        StartRecordingResponse.FromString,
    ),
    "StopRecording": _MethodDescriptor(
        "StopRecording",
        StopRecordingRequest,
        StopRecordingResponse,
        lambda req: req.SerializeToString(),
        StopRecordingResponse.FromString,
    ),
    "Reset": _MethodDescriptor(
        "Reset",
        ResetRequest,
        ResetResponse,
        lambda req: req.SerializeToString(),
        ResetResponse.FromString,
    ),
    "AddCamera": _MethodDescriptor(
        "AddCamera",
        AddCameraRequest,
        AddCameraResponse,
        lambda req: req.SerializeToString(),
        AddCameraResponse.FromString,
    ),
    "SendCommand": _MethodDescriptor(
        "SendCommand",
        CommandRequest,
        CommandResponse,
        lambda req: req.SerializeToString(),
        CommandResponse.FromString,
    ),
    "StreamObservations": _MethodDescriptor(
        "StreamObservations",
        GetObservationRequest,
        GetObservationResponse,
        lambda req: req.SerializeToString(),
        GetObservationResponse.FromString,
        response_streaming=True,
    ),
}


# =============================================================================
# Service Stub (Client)
# =============================================================================


class GenieSimServiceStub:
    """
    gRPC client stub for GenieSimService.

    Provides methods for communicating with the Genie Sim data collection
    server running inside Isaac Sim.

    Usage:
        channel = create_channel()
        stub = GenieSimServiceStub(channel)

        # Get observation
        response = stub.GetObservation(GetObservationRequest(include_images=True))

        # Set joint positions
        response = stub.SetJointPosition(SetJointPositionRequest(
            positions=[0.0, -0.5, 0.0, -2.0, 0.0, 2.5, 0.8]
        ))
    """

    def __init__(self, channel):
        """
        Initialize the stub.

        Args:
            channel: gRPC channel to use for communication
        """
        self._channel = channel
        self._cb_lock = threading.Lock()
        self._cb_failure_count = 0
        self._cb_tripped_until = 0.0
        self._cb_failure_threshold = None
        self._cb_backoff_seconds = None

        if GRPC_AVAILABLE:
            from tools.geniesim_adapter.config import (
                get_geniesim_circuit_breaker_backoff_seconds,
                get_geniesim_circuit_breaker_failure_threshold,
            )

            self._cb_failure_threshold = get_geniesim_circuit_breaker_failure_threshold()
            self._cb_backoff_seconds = get_geniesim_circuit_breaker_backoff_seconds()

        if GRPC_AVAILABLE and channel is not None:
            # Create method stubs
            for method_name, descriptor in _SERVICE_METHODS.items():
                handler_factory = channel.unary_stream if descriptor.response_streaming else channel.unary_unary
                setattr(
                    self,
                    f"_{method_name}_stub",
                    handler_factory(
                        descriptor.full_name,
                        request_serializer=descriptor.request_serializer,
                        response_deserializer=descriptor.response_deserializer,
                    )
                )

    def _wait_for_circuit(self, method_name: str) -> None:
        if not self._cb_failure_threshold or self._cb_failure_threshold <= 0:
            return
        sleep_for = 0.0
        with self._cb_lock:
            now = time.time()
            if self._cb_tripped_until > now:
                sleep_for = self._cb_tripped_until - now
                self._cb_tripped_until = 0.0
                self._cb_failure_count = 0
        if sleep_for > 0:
            logger.warning(
                "Circuit breaker tripped for %s; backing off for %.2fs.",
                method_name,
                sleep_for,
            )
            time.sleep(sleep_for)

    def _record_failure(self, method_name: str, exc: Exception) -> None:
        if not self._cb_failure_threshold or self._cb_failure_threshold <= 0:
            return
        with self._cb_lock:
            self._cb_failure_count += 1
            if self._cb_failure_count >= self._cb_failure_threshold:
                backoff = self._cb_backoff_seconds or 0.0
                self._cb_tripped_until = time.time() + backoff
                logger.warning(
                    "Circuit breaker tripped after %s failures for %s; backing off for %.2fs.",
                    self._cb_failure_count,
                    method_name,
                    backoff,
                )

    def _record_success(self) -> None:
        if not self._cb_failure_threshold or self._cb_failure_threshold <= 0:
            return
        with self._cb_lock:
            self._cb_failure_count = 0
            self._cb_tripped_until = 0.0

    def _call(self, method_name: str, handler: Callable, request: Any, timeout: Optional[float], metadata: Optional[tuple]):
        if not GRPC_AVAILABLE or self._channel is None:
            raise RuntimeError("gRPC not available or channel not connected")
        self._wait_for_circuit(method_name)
        try:
            response = handler(request, timeout=timeout, metadata=metadata)
        except Exception as exc:
            self._record_failure(method_name, exc)
            raise
        self._record_success()
        return response

    def GetObservation(
        self,
        request: GetObservationRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetObservationResponse:
        """Get current observation from simulation."""
        return self._call("GetObservation", self._GetObservation_stub, request, timeout, metadata)

    def GetJointPosition(
        self,
        request: GetJointPositionRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetJointPositionResponse:
        """Get current joint positions."""
        return self._call("GetJointPosition", self._GetJointPosition_stub, request, timeout, metadata)

    def SetJointPosition(
        self,
        request: SetJointPositionRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetJointPositionResponse:
        """Set robot joint positions."""
        return self._call("SetJointPosition", self._SetJointPosition_stub, request, timeout, metadata)

    def GetEEPose(
        self,
        request: GetEEPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetEEPoseResponse:
        """Get end-effector pose."""
        return self._call("GetEEPose", self._GetEEPose_stub, request, timeout, metadata)

    def GetGripperState(
        self,
        request: GetGripperStateRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetGripperStateResponse:
        """Get gripper state."""
        return self._call("GetGripperState", self._GetGripperState_stub, request, timeout, metadata)

    def GetIKStatus(
        self,
        request: GetIKStatusRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetIKStatusResponse:
        """Get IK solver status."""
        return self._call("GetIKStatus", self._GetIKStatus_stub, request, timeout, metadata)

    def GetTaskStatus(
        self,
        request: TaskStatusRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> TaskStatusResponse:
        """Get task status."""
        return self._call("GetTaskStatus", self._GetTaskStatus_stub, request, timeout, metadata)

    def SetGripperState(
        self,
        request: SetGripperStateRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetGripperStateResponse:
        """Set gripper state (width and force)."""
        return self._call("SetGripperState", self._SetGripperState_stub, request, timeout, metadata)

    def LinearMove(
        self,
        request: LinearMoveRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> LinearMoveResponse:
        """Execute a linear move."""
        return self._call("LinearMove", self._LinearMove_stub, request, timeout, metadata)

    def GetObjectPose(
        self,
        request: GetObjectPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> GetObjectPoseResponse:
        """Get object pose."""
        return self._call("GetObjectPose", self._GetObjectPose_stub, request, timeout, metadata)

    def InitRobot(
        self,
        request: InitRobotRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> InitRobotResponse:
        """Initialize robot."""
        return self._call("InitRobot", self._InitRobot_stub, request, timeout, metadata)

    def SetObjectPose(
        self,
        request: SetObjectPoseRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetObjectPoseResponse:
        """Set object pose."""
        return self._call("SetObjectPose", self._SetObjectPose_stub, request, timeout, metadata)

    def AttachObject(
        self,
        request: AttachObjectRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> AttachObjectResponse:
        """Attach an object to a robot link."""
        return self._call("AttachObject", self._AttachObject_stub, request, timeout, metadata)

    def DetachObject(
        self,
        request: DetachObjectRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> DetachObjectResponse:
        """Detach an object from a robot link."""
        return self._call("DetachObject", self._DetachObject_stub, request, timeout, metadata)

    def SetTrajectory(
        self,
        request: SetTrajectoryRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> SetTrajectoryResponse:
        """Execute a trajectory."""
        return self._call("SetTrajectory", self._SetTrajectory_stub, request, timeout, metadata)

    def StartRecording(
        self,
        request: StartRecordingRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> StartRecordingResponse:
        """Start recording an episode."""
        return self._call("StartRecording", self._StartRecording_stub, request, timeout, metadata)

    def StopRecording(
        self,
        request: StopRecordingRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> StopRecordingResponse:
        """Stop recording current episode."""
        return self._call("StopRecording", self._StopRecording_stub, request, timeout, metadata)

    def Reset(
        self,
        request: ResetRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> ResetResponse:
        """Reset the simulation environment."""
        return self._call("Reset", self._Reset_stub, request, timeout, metadata)

    def AddCamera(
        self,
        request: AddCameraRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> AddCameraResponse:
        """Add a camera to the simulation."""
        return self._call("AddCamera", self._AddCamera_stub, request, timeout, metadata)

    def SendCommand(
        self,
        request: CommandRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> CommandResponse:
        """Send a generic command."""
        return self._call("SendCommand", self._SendCommand_stub, request, timeout, metadata)

    def StreamObservations(
        self,
        request: GetObservationRequest,
        timeout: Optional[float] = None,
        metadata: Optional[tuple] = None,
    ) -> Iterator[GetObservationResponse]:
        """Stream observations from simulation."""
        return self._call("StreamObservations", self._StreamObservations_stub, request, timeout, metadata)

# =============================================================================
# Service Servicer (Server - for reference/testing)
# =============================================================================


class GenieSimServiceServicer:
    """
    Base class for GenieSimService server implementation.

    Override these methods to implement the server-side logic.
    This is primarily useful for testing and for understanding the expected
    server behavior.
    """

    def __init__(self, joint_count: int = 7, delegate: Optional[Any] = None) -> None:
        self._delegate = delegate
        self._state_lock = threading.Lock()
        self._task_registry_lock = threading.Lock()
        self._task_registry = {}
        self._joint_positions = [0.0] * joint_count
        self._joint_velocities = [0.0] * joint_count
        self._joint_efforts = [0.0] * joint_count
        self._joint_names = [f"joint_{idx}" for idx in range(joint_count)]
        self._object_poses = {}
        self._attached_objects = {}
        self._cameras = {}
        self._ee_pose = self._default_pose()
        self._gripper_width = 0.0
        self._gripper_force = 0.0
        self._gripper_is_grasping = False
        self._recording = None
        self._ik_delegate = self._resolve_delegate("GetIKStatus")

    def GetObservation(
        self,
        request: GetObservationRequest,
        context,
    ) -> GetObservationResponse:
        """Get current observation from simulation."""
        delegate = self._resolve_delegate("GetObservation")
        if delegate:
            return self._call_delegate(delegate, request, context, GetObservationResponse(success=False))
        with self._state_lock:
            joint_state = self._build_joint_state()
            ee_pose = self._ee_pose
        robot_state = RobotState(
            joint_state=joint_state,
            end_effector_pose=ee_pose,
            gripper_width=self._gripper_width,
            gripper_is_grasping=self._gripper_is_grasping,
            link_poses=[],
            link_names=[],
        )
        scene_state = SceneState(objects=[], simulation_time=time.time(), step_count=0)
        camera_observation = CameraObservation(images=[])
        return GetObservationResponse(
            success=True,
            robot_state=robot_state,
            scene_state=scene_state,
            camera_observation=camera_observation,
            timestamp=time.time(),
        )

    def GetJointPosition(
        self,
        request: GetJointPositionRequest,
        context,
    ) -> GetJointPositionResponse:
        """Get current joint positions."""
        delegate = self._resolve_delegate("GetJointPosition")
        if delegate:
            return self._call_delegate(delegate, request, context, GetJointPositionResponse(success=False))
        with self._state_lock:
            joint_state = self._build_joint_state()
        return GetJointPositionResponse(success=True, joint_state=joint_state)

    def SetJointPosition(
        self,
        request: SetJointPositionRequest,
        context,
    ) -> SetJointPositionResponse:
        """Set robot joint positions."""
        delegate = self._resolve_delegate("SetJointPosition")
        if delegate:
            return self._call_delegate(delegate, request, context, SetJointPositionResponse(success=False))
        if not request.positions:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "No joint positions provided")
            return SetJointPositionResponse(success=False, error_message="No joint positions provided")
        with self._state_lock:
            self._joint_positions = list(request.positions)
            self._joint_velocities = list(request.velocities) or [0.0] * len(self._joint_positions)
            self._joint_efforts = [0.0] * len(self._joint_positions)
            joint_state = self._build_joint_state()
        return SetJointPositionResponse(success=True, current_state=joint_state)

    def GetEEPose(
        self,
        request: GetEEPoseRequest,
        context,
    ) -> GetEEPoseResponse:
        """Get end-effector pose."""
        delegate = self._resolve_delegate("GetEEPose")
        if delegate:
            return self._call_delegate(delegate, request, context, GetEEPoseResponse(success=False))
        with self._state_lock:
            pose = self._ee_pose
        return GetEEPoseResponse(success=True, pose=pose)

    def GetGripperState(
        self,
        request: GetGripperStateRequest,
        context,
    ) -> GetGripperStateResponse:
        """Get gripper state."""
        delegate = self._resolve_delegate("GetGripperState")
        if delegate:
            return self._call_delegate(delegate, request, context, GetGripperStateResponse(success=False))
        with self._state_lock:
            width = self._gripper_width
            force = self._gripper_force
            is_grasping = self._gripper_is_grasping
        return GetGripperStateResponse(success=True, width=width, is_grasping=is_grasping, force=force)

    def GetIKStatus(
        self,
        request: GetIKStatusRequest,
        context,
    ) -> GetIKStatusResponse:
        """Get IK status."""
        self._require_ik_delegate()
        return self._call_delegate(self._ik_delegate, request, context, GetIKStatusResponse(success=False))

    def GetTaskStatus(
        self,
        request: TaskStatusRequest,
        context,
    ) -> TaskStatusResponse:
        """Get task status."""
        delegate = self._resolve_delegate("GetTaskStatus")
        if delegate:
            return self._call_delegate(delegate, request, context, TaskStatusResponse(success=False))
        if not request.task_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "task_id is required")
            return TaskStatusResponse(
                success=False,
                status="unknown",
                progress=0.0,
                error_message="task_id is required",
            )
        task = self._get_task_status(request.task_id)
        if task is None:
            self._set_context_status(context, self._grpc_status("NOT_FOUND"), "task_id not found")
            return TaskStatusResponse(
                success=False,
                status="unknown",
                progress=0.0,
                error_message="task_id not found",
            )
        return TaskStatusResponse(
            success=True,
            status=task["status"],
            progress=task["progress"],
            error_message=task["error_message"],
        )

    def SetGripperState(
        self,
        request: SetGripperStateRequest,
        context,
    ) -> SetGripperStateResponse:
        """Set gripper state."""
        delegate = self._resolve_delegate("SetGripperState")
        if delegate:
            return self._call_delegate(delegate, request, context, SetGripperStateResponse(success=False))
        with self._state_lock:
            self._gripper_width = request.width
            self._gripper_force = request.force
            self._gripper_is_grasping = request.force > 0.0 and request.width <= 0.02
        return SetGripperStateResponse(
            success=True,
            current_width=self._gripper_width,
            is_grasping=self._gripper_is_grasping,
        )

    def LinearMove(
        self,
        request: LinearMoveRequest,
        context,
    ) -> LinearMoveResponse:
        """Move the end-effector linearly to a target pose."""
        delegate = self._resolve_delegate("LinearMove")
        if delegate:
            return self._call_delegate(delegate, request, context, LinearMoveResponse(success=False))
        if request.target_pose is None:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "target_pose is required")
            return LinearMoveResponse(
                success=False,
                error_message="target_pose is required",
                planning_success=False,
                execution_success=False,
            )
        with self._state_lock:
            self._ee_pose = request.target_pose
        task_id = getattr(request, "task_id", "")
        if task_id:
            self._set_task_status(task_id, "completed", 1.0, "")
        return LinearMoveResponse(
            success=True,
            planning_success=True,
            execution_success=True,
        )

    def GetObjectPose(
        self,
        request: GetObjectPoseRequest,
        context,
    ) -> GetObjectPoseResponse:
        """Get object pose."""
        delegate = self._resolve_delegate("GetObjectPose")
        if delegate:
            return self._call_delegate(delegate, request, context, GetObjectPoseResponse(success=False))
        if not request.object_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id is required")
            return GetObjectPoseResponse(success=False, error_message="object_id is required")
        with self._state_lock:
            pose = self._object_poses.get(request.object_id)
        if pose is None:
            self._set_context_status(context, self._grpc_status("NOT_FOUND"), "object not found")
            return GetObjectPoseResponse(success=False, error_message="object not found")
        return GetObjectPoseResponse(success=True, pose=pose)

    def SetObjectPose(
        self,
        request: SetObjectPoseRequest,
        context,
    ) -> SetObjectPoseResponse:
        """Set object pose."""
        delegate = self._resolve_delegate("SetObjectPose")
        if delegate:
            return self._call_delegate(delegate, request, context, SetObjectPoseResponse(success=False))
        if not request.object_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id is required")
            return SetObjectPoseResponse(success=False, error_message="object_id is required")
        if request.pose is None:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "pose is required")
            return SetObjectPoseResponse(success=False, error_message="pose is required")
        with self._state_lock:
            self._object_poses[request.object_id] = request.pose
        return SetObjectPoseResponse(success=True)

    def InitRobot(
        self,
        request: InitRobotRequest,
        context,
    ) -> InitRobotResponse:
        """Initialize the robot model."""
        delegate = self._resolve_delegate("InitRobot")
        if delegate:
            return self._call_delegate(delegate, request, context, InitRobotResponse(success=False))
        with self._state_lock:
            if request.initial_joint_positions:
                joint_count = len(request.initial_joint_positions)
                self._joint_positions = list(request.initial_joint_positions)
                self._joint_velocities = [0.0] * joint_count
                self._joint_efforts = [0.0] * joint_count
                self._joint_names = [f"joint_{idx}" for idx in range(joint_count)]
            num_joints = len(self._joint_positions)
            joint_names = list(self._joint_names)
        return InitRobotResponse(
            success=True,
            num_joints=num_joints,
            joint_names=joint_names,
        )

    def AttachObject(
        self,
        request: AttachObjectRequest,
        context,
    ) -> AttachObjectResponse:
        """Attach an object to a robot link."""
        delegate = self._resolve_delegate("AttachObject")
        if delegate:
            return self._call_delegate(delegate, request, context, AttachObjectResponse(success=False))
        if not request.object_id or not request.link_name:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id and link_name required")
            return AttachObjectResponse(success=False, error_message="object_id and link_name required")
        with self._state_lock:
            self._attached_objects[request.object_id] = request.link_name
        return AttachObjectResponse(success=True)

    def DetachObject(
        self,
        request: DetachObjectRequest,
        context,
    ) -> DetachObjectResponse:
        """Detach an object from a robot link."""
        delegate = self._resolve_delegate("DetachObject")
        if delegate:
            return self._call_delegate(delegate, request, context, DetachObjectResponse(success=False))
        if not request.object_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "object_id required")
            return DetachObjectResponse(success=False, error_message="object_id required")
        with self._state_lock:
            if request.object_id not in self._attached_objects:
                self._set_context_status(context, self._grpc_status("NOT_FOUND"), "object not attached")
                return DetachObjectResponse(success=False, error_message="object not attached")
            self._attached_objects.pop(request.object_id, None)
        return DetachObjectResponse(success=True)

    def SetTrajectory(
        self,
        request: SetTrajectoryRequest,
        context,
    ) -> SetTrajectoryResponse:
        """Execute a trajectory."""
        delegate = self._resolve_delegate("SetTrajectory")
        if delegate:
            return self._call_delegate(delegate, request, context, SetTrajectoryResponse(success=False))
        if not request.points:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "Trajectory points are required")
            return SetTrajectoryResponse(success=False, error_message="Trajectory points are required")
        last_point: TrajectoryPoint = request.points[-1]
        with self._state_lock:
            if last_point.positions:
                self._joint_positions = list(last_point.positions)
                self._joint_velocities = list(last_point.velocities) or [0.0] * len(self._joint_positions)
                self._joint_efforts = [0.0] * len(self._joint_positions)
        execution_time = max(last_point.time_from_start, 0.0)
        task_id = getattr(request, "task_id", "")
        if task_id:
            self._set_task_status(task_id, "completed", 1.0, "")
        return SetTrajectoryResponse(
            success=True,
            points_executed=len(request.points),
            execution_time=execution_time,
        )

    def StartRecording(
        self,
        request: StartRecordingRequest,
        context,
    ) -> StartRecordingResponse:
        """Start recording an episode."""
        delegate = self._resolve_delegate("StartRecording")
        if delegate:
            return self._call_delegate(delegate, request, context, StartRecordingResponse(success=False))
        episode_id = request.episode_id or f"episode-{int(time.time())}"
        output_dir = Path(request.output_directory or "/tmp/geniesim_recordings")
        recording_path = output_dir / episode_id
        try:
            recording_path.mkdir(parents=True, exist_ok=True)
        except OSError as exc:
            self._set_context_status(context, self._grpc_status("INTERNAL"), "Failed to create recording directory")
            self._set_task_status(episode_id, "failed", 0.0, str(exc))
            return StartRecordingResponse(success=False, error_message=str(exc))
        with self._state_lock:
            self._recording = {
                "episode_id": episode_id,
                "output_directory": recording_path,
                "started_at": time.time(),
                "frames_recorded": 0,
            }
        self._set_task_status(episode_id, "running", 0.0, "")
        return StartRecordingResponse(success=True, recording_path=str(recording_path))

    def StopRecording(
        self,
        request: StopRecordingRequest,
        context,
    ) -> StopRecordingResponse:
        """Stop recording current episode."""
        delegate = self._resolve_delegate("StopRecording")
        if delegate:
            return self._call_delegate(delegate, request, context, StopRecordingResponse(success=False))
        with self._state_lock:
            recording = self._recording
            self._recording = None
        if recording is None:
            self._set_context_status(context, self._grpc_status("FAILED_PRECONDITION"), "No active recording")
            return StopRecordingResponse(success=False, error_message="No active recording")
        duration = max(time.time() - recording["started_at"], 0.0)
        self._set_task_status(recording.get("episode_id", ""), "completed", 1.0, "")
        return StopRecordingResponse(
            success=True,
            frames_recorded=recording["frames_recorded"],
            duration_seconds=duration,
            recording_path=str(recording["output_directory"]),
        )

    def Reset(
        self,
        request: ResetRequest,
        context,
    ) -> ResetResponse:
        """Reset the simulation environment."""
        delegate = self._resolve_delegate("Reset")
        if delegate:
            return self._call_delegate(delegate, request, context, ResetResponse(success=False))
        with self._state_lock:
            self._joint_positions = [0.0] * len(self._joint_positions)
            self._joint_velocities = [0.0] * len(self._joint_positions)
            self._joint_efforts = [0.0] * len(self._joint_positions)
            self._ee_pose = self._default_pose()
            self._gripper_width = 0.0
            self._gripper_force = 0.0
            self._gripper_is_grasping = False
            self._object_poses.clear()
            self._attached_objects.clear()
            self._cameras.clear()
            self._recording = None
        self._clear_task_registry()
        return ResetResponse(success=True)

    def AddCamera(
        self,
        request: AddCameraRequest,
        context,
    ) -> AddCameraResponse:
        """Add a camera to the scene."""
        delegate = self._resolve_delegate("AddCamera")
        if delegate:
            return self._call_delegate(delegate, request, context, AddCameraResponse(success=False))
        if not request.camera_id:
            self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "camera_id is required")
            return AddCameraResponse(success=False, error_message="camera_id is required")
        with self._state_lock:
            self._cameras[request.camera_id] = request
        return AddCameraResponse(success=True)

    def SendCommand(
        self,
        request: CommandRequest,
        context,
    ) -> CommandResponse:
        """Send a generic command."""
        delegate = self._resolve_delegate("SendCommand")
        if delegate:
            return self._call_delegate(delegate, request, context, CommandResponse(success=False))
        payload_data = {}
        if request.payload:
            try:
                payload_data = json.loads(request.payload.decode())
            except json.JSONDecodeError:
                self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "Invalid JSON payload")
                return CommandResponse(success=False, error_message="Invalid JSON payload")
        command_type = request.command_type
        task_id = payload_data.get("task_id", "")
        try:
            if command_type == CommandType.GET_OBSERVATION:
                response = self.GetObservation(
                    GetObservationRequest(
                        include_images=payload_data.get("include_images", False),
                        include_depth=payload_data.get("include_depth", False),
                        include_semantic=payload_data.get("include_semantic", False),
                        camera_ids=payload_data.get("camera_ids", []),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_observation(response)).encode(),
                )
            if command_type == CommandType.GET_JOINT_POSITION:
                response = self.GetJointPosition(GetJointPositionRequest(), context)
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_joint_state(response)).encode(),
                )
            if command_type == CommandType.SET_JOINT_POSITION:
                response = self.SetJointPosition(
                    SetJointPositionRequest(
                        positions=payload_data.get("positions", []),
                        velocities=payload_data.get("velocities", []),
                        duration=payload_data.get("duration", 0.0),
                        wait_for_completion=payload_data.get("wait_for_completion", False),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_set_joint(response)).encode(),
                )
            if command_type == CommandType.GET_EE_POSE:
                response = self.GetEEPose(
                    GetEEPoseRequest(ee_link_name=payload_data.get("ee_link_name", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_pose(response.pose)).encode(),
                )
            if command_type == CommandType.GET_GRIPPER_STATE:
                response = self.GetGripperState(GetGripperStateRequest(), context)
                return CommandResponse(
                    success=response.success,
                    payload=json.dumps(self._payload_for_gripper_state(response)).encode(),
                )
            if command_type == CommandType.SET_GRIPPER_STATE:
                response = self.SetGripperState(
                    SetGripperStateRequest(
                        width=payload_data.get("width", 0.0),
                        force=payload_data.get("force", 0.0),
                        wait_for_completion=payload_data.get("wait_for_completion", False),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_gripper(response)).encode(),
                )
            if command_type == CommandType.LINEAR_MOVE:
                target_pose_payload = payload_data.get("target_pose")
                linear_request = LinearMoveRequest(
                    target_pose=self._pose_from_payload(target_pose_payload) if target_pose_payload else None,
                    velocity=payload_data.get("velocity", 0.0),
                    acceleration=payload_data.get("acceleration", 0.0),
                    wait_for_completion=payload_data.get("wait_for_completion", False),
                )
                if task_id:
                    setattr(linear_request, "task_id", task_id)
                response = self.LinearMove(
                    linear_request,
                    context,
                )
                if task_id:
                    self._set_task_status(task_id, "completed" if response.success else "failed", 1.0, response.error_message)
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_linear_move(response)).encode(),
                )
            if command_type == CommandType.GET_OBJECT_POSE:
                response = self.GetObjectPose(
                    GetObjectPoseRequest(object_id=payload_data.get("object_id", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_object_pose(response)).encode(),
                )
            if command_type == CommandType.SET_OBJECT_POSE:
                response = self.SetObjectPose(
                    SetObjectPoseRequest(
                        object_id=payload_data.get("object_id", ""),
                        pose=self._pose_from_payload(payload_data.get("pose")),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.ATTACH_OBJ:
                response = self.AttachObject(
                    AttachObjectRequest(
                        object_id=payload_data.get("object_id", ""),
                        link_name=payload_data.get("link_name", ""),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.DETACH_OBJ:
                response = self.DetachObject(
                    DetachObjectRequest(object_id=payload_data.get("object_id", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.GET_IK_STATUS:
                response = self.GetIKStatus(
                    GetIKStatusRequest(
                        target_pose=self._pose_from_payload(payload_data.get("target_pose")),
                        seed_positions=payload_data.get("seed_positions", []),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_ik_status(response)).encode(),
                )
            if command_type == CommandType.TASK_STATUS:
                response = self.GetTaskStatus(
                    TaskStatusRequest(task_id=payload_data.get("task_id", "")),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_task_status(response)).encode(),
                )
            if command_type == CommandType.INIT_ROBOT:
                response = self.InitRobot(
                    InitRobotRequest(
                        robot_type=payload_data.get("robot_type", ""),
                        urdf_path=payload_data.get("urdf_path", ""),
                        base_pose=self._pose_from_payload(payload_data.get("base_pose")),
                        initial_joint_positions=payload_data.get("initial_joint_positions", []),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_init_robot(response)).encode(),
                )
            if command_type == CommandType.ADD_CAMERA:
                response = self.AddCamera(
                    AddCameraRequest(
                        camera_id=payload_data.get("camera_id", ""),
                        pose=self._pose_from_payload(payload_data.get("pose")),
                        parent_link=payload_data.get("parent_link", ""),
                        width=payload_data.get("width", 0),
                        height=payload_data.get("height", 0),
                        fov=payload_data.get("fov", 0.0),
                        near_clip=payload_data.get("near_clip", 0.0),
                        far_clip=payload_data.get("far_clip", 0.0),
                    ),
                    context,
                )
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
            if command_type == CommandType.RESET:
                response = self.Reset(ResetRequest(), context)
                return CommandResponse(
                    success=response.success,
                    error_message=response.error_message,
                    payload=json.dumps(self._payload_for_simple(response.success, response.error_message)).encode(),
                )
        except Exception as exc:
            self._set_context_status(context, self._grpc_status("INTERNAL"), "Command handling failed")
            return CommandResponse(success=False, error_message=str(exc))
        self._set_context_status(context, self._grpc_status("INVALID_ARGUMENT"), "Unsupported command type")
        return CommandResponse(success=False, error_message="Unsupported command type")

    def StreamObservations(
        self,
        request: GetObservationRequest,
        context,
    ) -> Iterator[GetObservationResponse]:
        """Stream observations from simulation."""
        delegate = self._resolve_delegate("StreamObservations")
        if delegate:
            return self._call_delegate(delegate, request, context, iter(()))
        logger.warning("StreamObservations is not implemented in the test servicer.")
        self._set_context_status(context, self._grpc_status("UNIMPLEMENTED"), "StreamObservations not implemented")
        return iter(())

    def _resolve_delegate(self, method_name: str) -> Optional[Callable]:
        if self._delegate is None:
            return None
        handler = getattr(self._delegate, method_name, None)
        if handler is None:
            return None
        base_handler = getattr(GenieSimServiceServicer, method_name, None)
        if base_handler and getattr(handler, "__func__", None) is base_handler:
            return None
        return handler

    def _require_ik_delegate(self) -> None:
        if self._ik_delegate is None:
            raise RuntimeError(
                "GetIKStatus requires a delegate implementation; configure a servicer delegate that "
                "implements GetIKStatus."
            )

    def _call_delegate(self, handler: Callable, request: Any, context: Any, fallback_response: Any) -> Any:
        try:
            return handler(request, context)
        except Exception as exc:
            self._set_context_status(context, self._grpc_status("INTERNAL"), "Delegate failure")
            if hasattr(fallback_response, "error_message"):
                fallback_response.error_message = str(exc)
            return fallback_response

    def _unsupported_method(self, method_name: str, context: Any, fallback_response: Any) -> Any:
        logger.warning("%s is not implemented in the test servicer.", method_name)
        self._set_context_status(context, self._grpc_status("UNIMPLEMENTED"), f"{method_name} not implemented")
        if hasattr(fallback_response, "error_message") and not fallback_response.error_message:
            fallback_response.error_message = f"{method_name} not implemented"
        return fallback_response

    @staticmethod
    def _set_context_status(context: Any, code: Any, details: str) -> None:
        if context is None:
            return
        if grpc is not None and code is not None:
            try:
                context.set_code(code)
            except Exception:
                return
        try:
            context.set_details(details)
        except Exception:
            return

    @staticmethod
    def _payload_for_observation(response: GetObservationResponse) -> dict:
        return {
            "success": response.success,
            "robot_state": response.robot_state.to_dict() if response.robot_state else {},
            "scene_state": response.scene_state.to_dict() if response.scene_state else {},
            "timestamp": response.timestamp,
        }

    @staticmethod
    def _payload_for_joint_state(response: GetJointPositionResponse) -> dict:
        return {
            "success": response.success,
            "joint_state": response.joint_state.to_dict() if response.joint_state else {},
        }

    @staticmethod
    def _payload_for_set_joint(response: SetJointPositionResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "current_state": response.current_state.to_dict() if response.current_state else {},
        }

    @staticmethod
    def _payload_for_pose(pose: Optional[Pose]) -> dict:
        return {"pose": pose.to_dict() if pose else {}}

    @staticmethod
    def _payload_for_gripper(response: SetGripperStateResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "current_width": response.current_width,
            "is_grasping": response.is_grasping,
        }

    @staticmethod
    def _payload_for_gripper_state(response: GetGripperStateResponse) -> dict:
        return {
            "success": response.success,
            "width": response.width,
            "is_grasping": response.is_grasping,
            "force": response.force,
        }

    @staticmethod
    def _payload_for_object_pose(response: GetObjectPoseResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "pose": response.pose.to_dict() if response.pose else {},
        }

    @staticmethod
    def _payload_for_linear_move(response: LinearMoveResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "planning_success": response.planning_success,
            "execution_success": response.execution_success,
        }

    @staticmethod
    def _payload_for_ik_status(response: GetIKStatusResponse) -> dict:
        return {
            "success": response.success,
            "ik_solvable": response.ik_solvable,
            "solution": response.solution,
            "error_message": response.error_message,
        }

    @staticmethod
    def _payload_for_task_status(response: TaskStatusResponse) -> dict:
        return {
            "success": response.success,
            "status": response.status,
            "progress": response.progress,
            "error_message": response.error_message,
        }

    def _set_task_status(self, task_id: str, status: str, progress: float, error_message: str) -> None:
        if not task_id:
            return
        with self._task_registry_lock:
            self._task_registry[task_id] = {
                "status": status,
                "progress": float(progress),
                "error_message": error_message or "",
                "updated_at": time.time(),
            }

    def _get_task_status(self, task_id: str) -> Optional[dict]:
        with self._task_registry_lock:
            task = self._task_registry.get(task_id)
            return dict(task) if task else None

    def _clear_task_registry(self) -> None:
        with self._task_registry_lock:
            self._task_registry.clear()

    @staticmethod
    def _payload_for_init_robot(response: InitRobotResponse) -> dict:
        return {
            "success": response.success,
            "error_message": response.error_message,
            "num_joints": response.num_joints,
            "joint_names": response.joint_names,
        }

    @staticmethod
    def _payload_for_simple(success: bool, error_message: str) -> dict:
        return {"success": success, "error_message": error_message}

    @staticmethod
    def _grpc_status(code_name: str) -> Any:
        if grpc is None:
            return None
        return getattr(grpc.StatusCode, code_name, None)

    def _build_joint_state(self) -> JointState:
        return JointState(
            positions=list(self._joint_positions),
            velocities=list(self._joint_velocities),
            efforts=list(self._joint_efforts),
            names=list(self._joint_names),
        )

    @staticmethod
    def _default_pose() -> Pose:
        return Pose(
            position=Vector3(x=0.0, y=0.0, z=0.0),
            orientation=Quaternion(w=1.0, x=0.0, y=0.0, z=0.0),
        )

    @classmethod
    def _pose_from_payload(cls, payload: Optional[dict]) -> Pose:
        if not payload:
            return cls._default_pose()
        position = payload.get("position") or {}
        orientation = payload.get("orientation") or {}
        return Pose(
            position=Vector3(
                x=float(position.get("x", 0.0)),
                y=float(position.get("y", 0.0)),
                z=float(position.get("z", 0.0)),
            ),
            orientation=Quaternion(
                w=float(orientation.get("w", 1.0)),
                x=float(orientation.get("x", 0.0)),
                y=float(orientation.get("y", 0.0)),
                z=float(orientation.get("z", 0.0)),
            ),
        )


def add_GenieSimServiceServicer_to_server(servicer: GenieSimServiceServicer, server):
    """
    Add a GenieSimServiceServicer to a gRPC server.

    Args:
        servicer: The servicer implementation
        server: The gRPC server to add the servicer to
    """
    if not GRPC_AVAILABLE:
        raise RuntimeError("gRPC not available")

    rpc_method_handlers = {}

    for method_name, descriptor in _SERVICE_METHODS.items():
        handler_fn = getattr(servicer, method_name)
        deserializer = lambda data, t=descriptor.request_type: t.FromString(data) if hasattr(t, "FromString") else t()
        if descriptor.response_streaming:
            rpc_method_handlers[method_name] = grpc.unary_stream_rpc_method_handler(
                handler_fn,
                request_deserializer=deserializer,
                response_serializer=descriptor.request_serializer,
            )
        else:
            rpc_method_handlers[method_name] = grpc.unary_unary_rpc_method_handler(
                handler_fn,
                request_deserializer=deserializer,
                response_serializer=descriptor.request_serializer,
            )

    generic_handler = grpc.method_handlers_generic_handler(
        "geniesim.GenieSimService",
        rpc_method_handlers,
    )
    server.add_generic_rpc_handlers((generic_handler,))


# =============================================================================
# Utility Functions
# =============================================================================


def is_grpc_available() -> bool:
    """Check if gRPC is available."""
    return GRPC_AVAILABLE


if GRPC_AVAILABLE:
    class _AuthInterceptor(grpc.UnaryUnaryClientInterceptor, grpc.UnaryStreamClientInterceptor):
        """Inject auth metadata on outbound requests."""

        def __init__(self, metadata: Tuple[Tuple[str, str], ...]):
            self._metadata = metadata

        def _augment_details(self, client_call_details):
            base_metadata = []
            if client_call_details.metadata:
                base_metadata.extend(client_call_details.metadata)
            base_metadata.extend(self._metadata)
            return _ClientCallDetails(
                method=client_call_details.method,
                timeout=client_call_details.timeout,
                metadata=tuple(base_metadata),
                credentials=client_call_details.credentials,
                wait_for_ready=client_call_details.wait_for_ready,
                compression=client_call_details.compression,
            )

        def intercept_unary_unary(self, continuation, client_call_details, request):
            return continuation(self._augment_details(client_call_details), request)

        def intercept_unary_stream(self, continuation, client_call_details, request):
            return continuation(self._augment_details(client_call_details), request)
else:
    class _AuthInterceptor:
        """No-op interceptor placeholder when gRPC is unavailable."""

        def __init__(self, metadata: Tuple[Tuple[str, str], ...]):
            self._metadata = metadata


def _load_file_bytes(path_value: Optional[str]) -> Optional[bytes]:
    if not path_value:
        return None
    return Path(path_value).read_bytes()


def _load_file_text(path_value: Optional[str]) -> Optional[str]:
    if not path_value:
        return None
    return Path(path_value).read_text()


def _build_auth_metadata() -> Tuple[Tuple[str, str], ...]:
    from tools.geniesim_adapter.config import (
        get_geniesim_auth_cert_path,
        get_geniesim_auth_key_path,
        get_geniesim_auth_token,
        get_geniesim_auth_token_path,
    )

    token = get_geniesim_auth_token()
    token_path = get_geniesim_auth_token_path()
    if not token and token_path:
        token = _load_file_text(token_path)

    metadata = []
    if token:
        metadata.append(("authorization", f"Bearer {token.strip()}"))

    auth_cert_path = get_geniesim_auth_cert_path()
    auth_key_path = get_geniesim_auth_key_path()
    if auth_cert_path:
        metadata.append(("x-geniesim-client-cert", _load_file_text(auth_cert_path) or ""))
    if auth_key_path:
        metadata.append(("x-geniesim-client-key", _load_file_text(auth_key_path) or ""))

    return tuple(metadata)


def create_channel(
    host: Optional[str] = None,
    port: Optional[int] = None,
    options: Optional[list] = None,
) -> Any:
    """
    Create a gRPC channel.

    Args:
        host: Server hostname (defaults to GENIESIM_HOST or adapter default)
        port: Server port (defaults to GENIESIM_PORT or adapter default)
        options: Optional channel options

    Returns:
        gRPC channel or None if gRPC not available
    """
    if not GRPC_AVAILABLE:
        return None

    if host is None or port is None:
        from tools.geniesim_adapter.config import get_geniesim_host, get_geniesim_port

    if host is None:
        host = get_geniesim_host()
    if port is None:
        port = get_geniesim_port()

    if options is None:
        options = [
            ('grpc.max_receive_message_length', 16 * 1024 * 1024),
            ('grpc.max_send_message_length', 16 * 1024 * 1024),
        ]

    from tools.geniesim_adapter.config import (
        get_geniesim_tls_ca_path,
        get_geniesim_tls_cert_path,
        get_geniesim_tls_key_path,
    )

    tls_cert_path = get_geniesim_tls_cert_path()
    tls_key_path = get_geniesim_tls_key_path()
    tls_ca_path = get_geniesim_tls_ca_path()
    use_tls = any([tls_cert_path, tls_key_path, tls_ca_path])

    if use_tls:
        root_certificates = _load_file_bytes(tls_ca_path)
        private_key = _load_file_bytes(tls_key_path)
        certificate_chain = _load_file_bytes(tls_cert_path)
        credentials = grpc.ssl_channel_credentials(
            root_certificates=root_certificates,
            private_key=private_key,
            certificate_chain=certificate_chain,
        )
        channel = grpc.secure_channel(f"{host}:{port}", credentials, options=options)
    else:
        channel = grpc.insecure_channel(f"{host}:{port}", options=options)

    auth_metadata = _build_auth_metadata()
    if auth_metadata:
        channel = grpc.intercept_channel(channel, _AuthInterceptor(auth_metadata))

    return channel
