#!/usr/bin/env python3
"""
Generated Protocol Buffer messages for Genie Sim gRPC service.

This module provides the Python message classes for communicating with the
Genie Sim data collection server. These would normally be auto-generated by
protoc, but are implemented manually here for compatibility.

Usage:
    from geniesim_grpc_pb2 import (
        Vector3, Quaternion, Pose,
        GetObservationRequest, GetObservationResponse,
        SetJointPositionRequest, SetJointPositionResponse,
        ...
    )
"""

from dataclasses import dataclass, field
from enum import IntEnum
from typing import List, Optional, Any
import json
import struct


# =============================================================================
# Enums
# =============================================================================


class CommandType(IntEnum):
    """Command types for Genie Sim gRPC service."""
    COMMAND_UNKNOWN = 0
    GET_CAMERA_DATA = 1
    LINEAR_MOVE = 2
    SET_JOINT_POSITION = 3
    GET_GRIPPER_STATE = 4
    GET_OBJECT_POSE = 5
    ADD_OBJECT = 6
    GET_ROBOT_LINK_POSE = 7
    GET_JOINT_POSITION = 8
    SET_GRIPPER_STATE = 9
    GET_OBSERVATION = 11
    RESET = 12
    ATTACH_OBJ = 13
    DETACH_OBJ = 14
    TASK_STATUS = 16
    EXIT = 17
    GET_EE_POSE = 18
    GET_IK_STATUS = 19
    INIT_ROBOT = 21
    ADD_CAMERA = 22
    SET_OBJECT_POSE = 24
    SET_TRAJECTORY_LIST = 25
    GET_OBJECT_JOINT = 26
    SET_TARGET_POINT = 27
    SET_FRAME_STATE = 28
    SET_LIGHT = 30
    GET_PART_DOF_JOINT = 32
    SET_LINEAR_VELOCITY = 33
    SET_CODE_FACE_ORIENTATION = 34
    ATTACH_OBJ_TO_PARENT = 50
    DETACH_OBJ_FROM_PARENT = 51
    REMOVE_OBJS_FROM_OBSTACLE = 52
    SET_TASK_METRIC = 53
    STORE_CURRENT_STATE = 54
    PLAYBACK = 55
    GET_CHECKER_STATUS = 56


# =============================================================================
# Common Types
# =============================================================================


@dataclass
class Vector3:
    """3D vector for positions."""
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0

    def to_list(self) -> List[float]:
        return [self.x, self.y, self.z]

    @classmethod
    def from_list(cls, v: List[float]) -> "Vector3":
        return cls(x=v[0], y=v[1], z=v[2])

    def SerializeToString(self) -> bytes:
        return json.dumps({"x": self.x, "y": self.y, "z": self.z}).encode()

    @classmethod
    def FromString(cls, data: bytes) -> "Vector3":
        d = json.loads(data)
        return cls(x=d.get("x", 0), y=d.get("y", 0), z=d.get("z", 0))


@dataclass
class Quaternion:
    """Quaternion for orientations (w, x, y, z)."""
    w: float = 1.0
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0

    def to_list(self) -> List[float]:
        return [self.w, self.x, self.y, self.z]

    @classmethod
    def from_list(cls, v: List[float]) -> "Quaternion":
        return cls(w=v[0], x=v[1], y=v[2], z=v[3])

    def SerializeToString(self) -> bytes:
        return json.dumps({"w": self.w, "x": self.x, "y": self.y, "z": self.z}).encode()

    @classmethod
    def FromString(cls, data: bytes) -> "Quaternion":
        d = json.loads(data)
        return cls(w=d.get("w", 1), x=d.get("x", 0), y=d.get("y", 0), z=d.get("z", 0))


@dataclass
class Pose:
    """6D pose (position + orientation)."""
    position: Optional[Vector3] = None
    orientation: Optional[Quaternion] = None

    def __post_init__(self):
        if self.position is None:
            self.position = Vector3()
        if self.orientation is None:
            self.orientation = Quaternion()

    def to_dict(self) -> dict:
        return {
            "position": self.position.to_list(),
            "orientation": self.orientation.to_list(),
        }

    @classmethod
    def from_dict(cls, d: dict) -> "Pose":
        return cls(
            position=Vector3.from_list(d.get("position", [0, 0, 0])),
            orientation=Quaternion.from_list(d.get("orientation", [1, 0, 0, 0])),
        )

    def SerializeToString(self) -> bytes:
        return json.dumps(self.to_dict()).encode()

    @classmethod
    def FromString(cls, data: bytes) -> "Pose":
        return cls.from_dict(json.loads(data))


@dataclass
class JointState:
    """Joint state."""
    positions: List[float] = field(default_factory=list)
    velocities: List[float] = field(default_factory=list)
    efforts: List[float] = field(default_factory=list)
    names: List[str] = field(default_factory=list)

    def to_dict(self) -> dict:
        return {
            "positions": self.positions,
            "velocities": self.velocities,
            "efforts": self.efforts,
            "names": self.names,
        }

    @classmethod
    def from_dict(cls, d: dict) -> "JointState":
        return cls(
            positions=d.get("positions", []),
            velocities=d.get("velocities", []),
            efforts=d.get("efforts", []),
            names=d.get("names", []),
        )

    def SerializeToString(self) -> bytes:
        return json.dumps(self.to_dict()).encode()

    @classmethod
    def FromString(cls, data: bytes) -> "JointState":
        return cls.from_dict(json.loads(data))


@dataclass
class CameraImage:
    """Camera image data."""
    rgb_data: bytes = b""
    depth_data: bytes = b""
    semantic_data: bytes = b""
    instance_data: bytes = b""
    width: int = 0
    height: int = 0
    encoding: str = "rgb8"
    camera_id: str = ""
    camera_pose: Optional[Pose] = None
    timestamp: float = 0.0

    def to_dict(self) -> dict:
        return {
            "rgb_data_b64": self.rgb_data.hex() if self.rgb_data else "",
            "depth_data_b64": self.depth_data.hex() if self.depth_data else "",
            "semantic_data_b64": self.semantic_data.hex() if self.semantic_data else "",
            "instance_data_b64": self.instance_data.hex() if self.instance_data else "",
            "width": self.width,
            "height": self.height,
            "encoding": self.encoding,
            "camera_id": self.camera_id,
            "camera_pose": self.camera_pose.to_dict() if self.camera_pose else None,
            "timestamp": self.timestamp,
        }


@dataclass
class CameraObservation:
    """Multi-camera observation."""
    images: List[CameraImage] = field(default_factory=list)


@dataclass
class RobotState:
    """Full robot state observation."""
    joint_state: Optional[JointState] = None
    end_effector_pose: Optional[Pose] = None
    gripper_width: float = 0.04
    gripper_is_grasping: bool = False
    link_poses: List[Pose] = field(default_factory=list)
    link_names: List[str] = field(default_factory=list)

    def __post_init__(self):
        if self.joint_state is None:
            self.joint_state = JointState()
        if self.end_effector_pose is None:
            self.end_effector_pose = Pose()

    def to_dict(self) -> dict:
        return {
            "joint_state": self.joint_state.to_dict() if self.joint_state else {},
            "end_effector_pose": self.end_effector_pose.to_dict() if self.end_effector_pose else {},
            "gripper_width": self.gripper_width,
            "gripper_is_grasping": self.gripper_is_grasping,
            "link_names": self.link_names,
        }

    @classmethod
    def from_dict(cls, d: dict) -> "RobotState":
        return cls(
            joint_state=JointState.from_dict(d.get("joint_state", {})),
            end_effector_pose=Pose.from_dict(d.get("end_effector_pose", {})),
            gripper_width=d.get("gripper_width", 0.04),
            gripper_is_grasping=d.get("gripper_is_grasping", False),
            link_names=d.get("link_names", []),
        )


@dataclass
class ObjectState:
    """Object state in scene."""
    object_id: str = ""
    pose: Optional[Pose] = None
    linear_velocity: Optional[Vector3] = None
    angular_velocity: Optional[Vector3] = None
    dimensions: Optional[Vector3] = None
    category: str = ""
    is_articulated: bool = False
    joint_positions: List[float] = field(default_factory=list)

    def __post_init__(self):
        if self.pose is None:
            self.pose = Pose()
        if self.linear_velocity is None:
            self.linear_velocity = Vector3()
        if self.angular_velocity is None:
            self.angular_velocity = Vector3()
        if self.dimensions is None:
            self.dimensions = Vector3(x=0.1, y=0.1, z=0.1)

    def to_dict(self) -> dict:
        return {
            "object_id": self.object_id,
            "pose": self.pose.to_dict() if self.pose else {},
            "linear_velocity": self.linear_velocity.to_list() if self.linear_velocity else [0, 0, 0],
            "angular_velocity": self.angular_velocity.to_list() if self.angular_velocity else [0, 0, 0],
            "dimensions": self.dimensions.to_list() if self.dimensions else [0.1, 0.1, 0.1],
            "category": self.category,
            "is_articulated": self.is_articulated,
            "joint_positions": self.joint_positions,
        }

    @classmethod
    def from_dict(cls, d: dict) -> "ObjectState":
        return cls(
            object_id=d.get("object_id", ""),
            pose=Pose.from_dict(d.get("pose", {})),
            linear_velocity=Vector3.from_list(d.get("linear_velocity", [0, 0, 0])),
            angular_velocity=Vector3.from_list(d.get("angular_velocity", [0, 0, 0])),
            dimensions=Vector3.from_list(d.get("dimensions", [0.1, 0.1, 0.1])),
            category=d.get("category", ""),
            is_articulated=d.get("is_articulated", False),
            joint_positions=d.get("joint_positions", []),
        )


@dataclass
class SceneState:
    """Scene state (all objects)."""
    objects: List[ObjectState] = field(default_factory=list)
    simulation_time: float = 0.0
    step_count: int = 0

    def to_dict(self) -> dict:
        return {
            "objects": [o.to_dict() for o in self.objects],
            "simulation_time": self.simulation_time,
            "step_count": self.step_count,
        }

    @classmethod
    def from_dict(cls, d: dict) -> "SceneState":
        return cls(
            objects=[ObjectState.from_dict(o) for o in d.get("objects", [])],
            simulation_time=d.get("simulation_time", 0.0),
            step_count=d.get("step_count", 0),
        )


# =============================================================================
# Request/Response Messages
# =============================================================================


@dataclass
class CommandRequest:
    """Generic command request."""
    command_type: CommandType = CommandType.COMMAND_UNKNOWN
    payload: bytes = b""

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "command_type": int(self.command_type),
            "payload": self.payload.hex() if self.payload else "",
        }).encode()


@dataclass
class CommandResponse:
    """Generic command response."""
    success: bool = False
    error_message: str = ""
    payload: bytes = b""

    @classmethod
    def FromString(cls, data: bytes) -> "CommandResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            payload=bytes.fromhex(d.get("payload", "")) if d.get("payload") else b"",
        )


@dataclass
class GetObservationRequest:
    """Request for observation."""
    include_images: bool = True
    include_depth: bool = True
    include_semantic: bool = False
    camera_ids: List[str] = field(default_factory=list)

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "include_images": self.include_images,
            "include_depth": self.include_depth,
            "include_semantic": self.include_semantic,
            "camera_ids": self.camera_ids,
        }).encode()


@dataclass
class GetObservationResponse:
    """Response with observation data."""
    success: bool = False
    robot_state: Optional[RobotState] = None
    scene_state: Optional[SceneState] = None
    camera_observation: Optional[CameraObservation] = None
    timestamp: float = 0.0

    def __post_init__(self):
        if self.robot_state is None:
            self.robot_state = RobotState()
        if self.scene_state is None:
            self.scene_state = SceneState()

    @classmethod
    def FromString(cls, data: bytes) -> "GetObservationResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            robot_state=RobotState.from_dict(d.get("robot_state", {})),
            scene_state=SceneState.from_dict(d.get("scene_state", {})),
            timestamp=d.get("timestamp", 0.0),
        )


@dataclass
class SetJointPositionRequest:
    """Request to set joint positions."""
    positions: List[float] = field(default_factory=list)
    velocities: List[float] = field(default_factory=list)
    duration: float = 0.0
    wait_for_completion: bool = True

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "positions": self.positions,
            "velocities": self.velocities,
            "duration": self.duration,
            "wait_for_completion": self.wait_for_completion,
        }).encode()


@dataclass
class SetJointPositionResponse:
    """Response from setting joint positions."""
    success: bool = False
    error_message: str = ""
    current_state: Optional[JointState] = None

    @classmethod
    def FromString(cls, data: bytes) -> "SetJointPositionResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            current_state=JointState.from_dict(d.get("current_state", {})),
        )


@dataclass
class GetJointPositionRequest:
    """Request to get joint positions."""
    pass

    def SerializeToString(self) -> bytes:
        return b"{}"


@dataclass
class GetJointPositionResponse:
    """Response with joint positions."""
    success: bool = False
    joint_state: Optional[JointState] = None

    @classmethod
    def FromString(cls, data: bytes) -> "GetJointPositionResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            joint_state=JointState.from_dict(d.get("joint_state", {})),
        )


@dataclass
class GetEEPoseRequest:
    """Request for end-effector pose."""
    ee_link_name: str = ""

    def SerializeToString(self) -> bytes:
        return json.dumps({"ee_link_name": self.ee_link_name}).encode()


@dataclass
class GetEEPoseResponse:
    """Response with end-effector pose."""
    success: bool = False
    pose: Optional[Pose] = None

    @classmethod
    def FromString(cls, data: bytes) -> "GetEEPoseResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            pose=Pose.from_dict(d.get("pose", {})),
        )


@dataclass
class LinearMoveRequest:
    """Request to move linearly to a target pose."""
    target_pose: Optional[Pose] = None
    velocity: float = 0.0
    acceleration: float = 0.0
    wait_for_completion: bool = True

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "target_pose": self.target_pose.to_dict() if self.target_pose else {},
            "velocity": self.velocity,
            "acceleration": self.acceleration,
            "wait_for_completion": self.wait_for_completion,
        }).encode()


@dataclass
class LinearMoveResponse:
    """Response from linear move."""
    success: bool = False
    error_message: str = ""
    planning_success: bool = False
    execution_success: bool = False

    @classmethod
    def FromString(cls, data: bytes) -> "LinearMoveResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            planning_success=d.get("planning_success", False),
            execution_success=d.get("execution_success", False),
        )


@dataclass
class SetGripperStateRequest:
    """Request to set gripper state."""
    width: float = 0.04
    force: float = 40.0
    wait_for_completion: bool = True

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "width": self.width,
            "force": self.force,
            "wait_for_completion": self.wait_for_completion,
        }).encode()


@dataclass
class SetGripperStateResponse:
    """Response from setting gripper state."""
    success: bool = False
    error_message: str = ""
    current_width: float = 0.0
    is_grasping: bool = False

    @classmethod
    def FromString(cls, data: bytes) -> "SetGripperStateResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            current_width=d.get("current_width", 0.0),
            is_grasping=d.get("is_grasping", False),
        )


@dataclass
class GetGripperStateRequest:
    """Request to get gripper state."""

    def SerializeToString(self) -> bytes:
        return json.dumps({}).encode()


@dataclass
class GetGripperStateResponse:
    """Response with gripper state."""
    success: bool = False
    width: float = 0.0
    is_grasping: bool = False
    force: float = 0.0

    @classmethod
    def FromString(cls, data: bytes) -> "GetGripperStateResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            width=d.get("width", 0.0),
            is_grasping=d.get("is_grasping", False),
            force=d.get("force", 0.0),
        )


@dataclass
class TrajectoryPoint:
    """Single point in a trajectory."""
    positions: List[float] = field(default_factory=list)
    velocities: List[float] = field(default_factory=list)
    accelerations: List[float] = field(default_factory=list)
    time_from_start: float = 0.0

    def to_dict(self) -> dict:
        return {
            "positions": self.positions,
            "velocities": self.velocities,
            "accelerations": self.accelerations,
            "time_from_start": self.time_from_start,
        }


@dataclass
class SetTrajectoryRequest:
    """Request to execute a trajectory."""
    points: List[TrajectoryPoint] = field(default_factory=list)
    execution_speed: float = 1.0
    wait_for_completion: bool = True

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "points": [p.to_dict() for p in self.points],
            "execution_speed": self.execution_speed,
            "wait_for_completion": self.wait_for_completion,
        }).encode()


@dataclass
class SetTrajectoryResponse:
    """Response from trajectory execution."""
    success: bool = False
    error_message: str = ""
    points_executed: int = 0
    execution_time: float = 0.0

    @classmethod
    def FromString(cls, data: bytes) -> "SetTrajectoryResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            points_executed=d.get("points_executed", 0),
            execution_time=d.get("execution_time", 0.0),
        )


@dataclass
class StartRecordingRequest:
    """Request to start recording."""
    episode_id: str = ""
    output_directory: str = ""
    camera_ids: List[str] = field(default_factory=list)
    fps: float = 30.0
    include_depth: bool = True
    include_semantic: bool = False

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "episode_id": self.episode_id,
            "output_directory": self.output_directory,
            "camera_ids": self.camera_ids,
            "fps": self.fps,
            "include_depth": self.include_depth,
            "include_semantic": self.include_semantic,
        }).encode()


@dataclass
class StartRecordingResponse:
    """Response from starting recording."""
    success: bool = False
    error_message: str = ""
    recording_path: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "StartRecordingResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            recording_path=d.get("recording_path", ""),
        )


@dataclass
class StopRecordingRequest:
    """Request to stop recording."""
    save_metadata: bool = True

    def SerializeToString(self) -> bytes:
        return json.dumps({"save_metadata": self.save_metadata}).encode()


@dataclass
class StopRecordingResponse:
    """Response from stopping recording."""
    success: bool = False
    error_message: str = ""
    frames_recorded: int = 0
    duration_seconds: float = 0.0
    recording_path: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "StopRecordingResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            frames_recorded=d.get("frames_recorded", 0),
            duration_seconds=d.get("duration_seconds", 0.0),
            recording_path=d.get("recording_path", ""),
        )


@dataclass
class ResetRequest:
    """Request to reset environment."""
    reset_robot: bool = True
    reset_objects: bool = True
    scene_path: str = ""

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "reset_robot": self.reset_robot,
            "reset_objects": self.reset_objects,
            "scene_path": self.scene_path,
        }).encode()


@dataclass
class ResetResponse:
    """Response from reset."""
    success: bool = False
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "ResetResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
        )


@dataclass
class GetObjectPoseRequest:
    """Request for object pose."""
    object_id: str = ""

    def SerializeToString(self) -> bytes:
        return json.dumps({"object_id": self.object_id}).encode()


@dataclass
class GetObjectPoseResponse:
    """Response with object pose."""
    success: bool = False
    pose: Optional[Pose] = None
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "GetObjectPoseResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            pose=Pose.from_dict(d.get("pose", {})) if d.get("pose") else None,
            error_message=d.get("error_message", ""),
        )


@dataclass
class SetObjectPoseRequest:
    """Request to set object pose."""
    object_id: str = ""
    pose: Optional[Pose] = None

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "object_id": self.object_id,
            "pose": self.pose.to_dict() if self.pose else {},
        }).encode()


@dataclass
class SetObjectPoseResponse:
    """Response from setting object pose."""
    success: bool = False
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "SetObjectPoseResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
        )


@dataclass
class AttachObjectRequest:
    """Request to attach an object to a robot link."""
    object_id: str = ""
    link_name: str = ""

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "object_id": self.object_id,
            "link_name": self.link_name,
        }).encode()


@dataclass
class AttachObjectResponse:
    """Response from attaching an object."""
    success: bool = False
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "AttachObjectResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
        )


@dataclass
class DetachObjectRequest:
    """Request to detach an object."""
    object_id: str = ""

    def SerializeToString(self) -> bytes:
        return json.dumps({"object_id": self.object_id}).encode()


@dataclass
class DetachObjectResponse:
    """Response from detaching an object."""
    success: bool = False
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "DetachObjectResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
        )


@dataclass
class InitRobotRequest:
    """Request to initialize a robot."""
    robot_type: str = ""
    urdf_path: str = ""
    base_pose: Optional[Pose] = None
    initial_joint_positions: List[float] = field(default_factory=list)

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "robot_type": self.robot_type,
            "urdf_path": self.urdf_path,
            "base_pose": self.base_pose.to_dict() if self.base_pose else {},
            "initial_joint_positions": self.initial_joint_positions,
        }).encode()


@dataclass
class InitRobotResponse:
    """Response from initializing a robot."""
    success: bool = False
    error_message: str = ""
    num_joints: int = 0
    joint_names: List[str] = field(default_factory=list)

    @classmethod
    def FromString(cls, data: bytes) -> "InitRobotResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
            num_joints=d.get("num_joints", 0),
            joint_names=d.get("joint_names", []),
        )


@dataclass
class AddCameraRequest:
    """Request to add a camera."""
    camera_id: str = ""
    pose: Optional[Pose] = None
    parent_link: str = ""
    width: int = 0
    height: int = 0
    fov: float = 0.0
    near_clip: float = 0.0
    far_clip: float = 0.0

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "camera_id": self.camera_id,
            "pose": self.pose.to_dict() if self.pose else {},
            "parent_link": self.parent_link,
            "width": self.width,
            "height": self.height,
            "fov": self.fov,
            "near_clip": self.near_clip,
            "far_clip": self.far_clip,
        }).encode()


@dataclass
class AddCameraResponse:
    """Response from adding a camera."""
    success: bool = False
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "AddCameraResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            error_message=d.get("error_message", ""),
        )


@dataclass
class GetIKStatusRequest:
    """Request to get IK status."""
    target_pose: Optional[Pose] = None
    seed_positions: List[float] = field(default_factory=list)

    def SerializeToString(self) -> bytes:
        return json.dumps({
            "target_pose": self.target_pose.to_dict() if self.target_pose else {},
            "seed_positions": self.seed_positions,
        }).encode()


@dataclass
class GetIKStatusResponse:
    """Response with IK status."""
    success: bool = False
    ik_solvable: bool = False
    solution: List[float] = field(default_factory=list)
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "GetIKStatusResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            ik_solvable=d.get("ik_solvable", False),
            solution=d.get("solution", []),
            error_message=d.get("error_message", ""),
        )


@dataclass
class TaskStatusRequest:
    """Request to get task status."""
    task_id: str = ""

    def SerializeToString(self) -> bytes:
        return json.dumps({"task_id": self.task_id}).encode()


@dataclass
class TaskStatusResponse:
    """Response with task status."""
    success: bool = False
    status: str = ""
    progress: float = 0.0
    error_message: str = ""

    @classmethod
    def FromString(cls, data: bytes) -> "TaskStatusResponse":
        d = json.loads(data)
        return cls(
            success=d.get("success", False),
            status=d.get("status", ""),
            progress=d.get("progress", 0.0),
            error_message=d.get("error_message", ""),
        )
