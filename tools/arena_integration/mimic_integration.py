"""
Isaac Lab-Mimic Integration for Demonstration Scaling.

This module integrates with Isaac Lab-Mimic to scale demonstrations
generated by Genie Sim through constraint-preserving augmentation.

Key Relationship with Genie Sim:
- Genie Sim: GENERATES base demonstrations (100-500 demos)
- Isaac Lab-Mimic: SCALES demos via augmentation (10-100x multiplier)

This is COMPLEMENTARY, not redundant:
1. Genie Sim generates diverse base demos with different strategies
2. Mimic augments each demo while preserving physics constraints
3. Combined output: massive dataset with both diversity AND scale

Features:
- Constraint-preserving trajectory augmentation
- Physics-validated demo scaling
- Integration with Genie Sim episode format
- LeRobot v2.0 compatible output
- Configurable augmentation strategies

Usage:
    from tools.arena_integration.mimic_integration import (
        MimicAugmenter,
        MimicConfig,
        augment_genie_sim_episodes
    )

    # Scale Genie Sim episodes 10x
    config = MimicConfig(scale_factor=10)
    augmenter = MimicAugmenter(config)
    scaled_episodes = augmenter.augment(genie_sim_episodes)
"""

from __future__ import annotations

import json
import os
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Optional

import numpy as np

from .components import ArenaScene, ArenaTask
from tools.lerobot_format import LeRobotExportFormat, parse_lerobot_export_format


# =============================================================================
# CONFIGURATION
# =============================================================================

class AugmentationStrategy(str, Enum):
    """Augmentation strategies for demo scaling."""
    SPATIAL_PERTURBATION = "spatial"       # Perturb object positions
    TEMPORAL_SCALING = "temporal"          # Speed up/slow down
    VIEWPOINT_VARIATION = "viewpoint"      # Camera pose changes
    LIGHTING_VARIATION = "lighting"        # Lighting condition changes
    NOISE_INJECTION = "noise"              # Sensor/action noise
    OBJECT_SWAP = "object_swap"            # Replace with similar objects
    CONSTRAINT_PRESERVING = "cpgen"        # CP-Gen style augmentation


@dataclass
class MimicConfig:
    """Configuration for Isaac Lab-Mimic integration."""
    # Scaling
    scale_factor: int = 10                          # Multiplier for demos
    min_demos_out: int = 1000                       # Minimum output demos
    max_demos_out: int = 50000                      # Maximum output demos

    # Augmentation strategies (enabled by default)
    strategies: list[AugmentationStrategy] = field(default_factory=lambda: [
        AugmentationStrategy.SPATIAL_PERTURBATION,
        AugmentationStrategy.TEMPORAL_SCALING,
        AugmentationStrategy.NOISE_INJECTION,
        AugmentationStrategy.CONSTRAINT_PRESERVING,
    ])

    # Spatial perturbation settings
    position_noise_std: float = 0.02                # meters
    rotation_noise_std: float = 0.05                # radians
    preserve_contact_constraints: bool = True       # Maintain grasps

    # Temporal settings
    time_scale_range: tuple[float, float] = (0.8, 1.2)  # Speed variation

    # Noise settings
    action_noise_std: float = 0.01
    observation_noise_std: float = 0.005

    # Constraint preservation (CP-Gen style)
    constraint_tolerance: float = 0.001             # Max constraint violation
    physics_validation: bool = True                 # Validate in simulation
    collision_check: bool = True                    # Check for collisions

    # Output format
    output_format: LeRobotExportFormat = LeRobotExportFormat.LEROBOT_V2  # lerobot_v2, lerobot_v3, parquet
    include_original: bool = True                   # Include original demo

    # Resource settings
    num_workers: int = 4
    batch_size: int = 100
    device: str = "cuda:0"


@dataclass
class DemonstrationMetadata:
    """Metadata for a demonstration."""
    demo_id: str
    source: str                                     # "genie_sim", "teleoperation", etc.
    task_id: str
    embodiment: str
    episode_length: int
    success: bool
    quality_score: float
    augmentation_history: list[str] = field(default_factory=list)


@dataclass
class Demonstration:
    """A single demonstration trajectory."""
    metadata: DemonstrationMetadata
    observations: dict[str, np.ndarray]             # {key: [T, ...]}
    actions: np.ndarray                             # [T, action_dim]
    rewards: np.ndarray                             # [T]
    timestamps: np.ndarray                          # [T]

    # Optional fields
    language_instruction: Optional[str] = None
    keypoints: Optional[list[dict[str, Any]]] = None
    contacts: Optional[np.ndarray] = None

    def __len__(self) -> int:
        return len(self.actions)


@dataclass
class AugmentationResult:
    """Result of augmentation operation."""
    success: bool
    original_count: int
    augmented_count: int
    total_count: int
    scale_achieved: float
    demos: list[Demonstration]
    validation_stats: dict[str, Any]
    errors: list[str] = field(default_factory=list)


# =============================================================================
# AUGMENTATION TRANSFORMS
# =============================================================================

class AugmentationTransform(ABC):
    """Base class for augmentation transforms."""

    def __init__(self, config: MimicConfig):
        self.config = config

    @abstractmethod
    def apply(
        self,
        demo: Demonstration,
        scene: Optional[ArenaScene] = None
    ) -> Optional[Demonstration]:
        """
        Apply augmentation to demonstration.

        Args:
            demo: Input demonstration
            scene: Optional scene for constraint checking

        Returns:
            Augmented demonstration or None if invalid
        """
        raise NotImplementedError


class SpatialPerturbation(AugmentationTransform):
    """Perturb spatial positions while preserving constraints."""

    def apply(
        self,
        demo: Demonstration,
        scene: Optional[ArenaScene] = None
    ) -> Optional[Demonstration]:
        """Apply spatial perturbation."""
        # Deep copy observations
        new_obs = {k: v.copy() for k, v in demo.observations.items()}

        # Perturb relevant position observations
        for key in ["object_pos", "target_pos", "ee_pos"]:
            if key in new_obs:
                noise = np.random.normal(
                    0, self.config.position_noise_std, new_obs[key].shape
                )
                new_obs[key] = new_obs[key] + noise

        # Perturb rotations
        for key in ["object_quat", "ee_quat"]:
            if key in new_obs:
                # Small rotation perturbation
                noise = np.random.normal(
                    0, self.config.rotation_noise_std, new_obs[key].shape
                )
                new_obs[key] = new_obs[key] + noise
                # Renormalize quaternions
                norms = np.linalg.norm(new_obs[key], axis=-1, keepdims=True)
                new_obs[key] = new_obs[key] / (norms + 1e-8)

        # Create new metadata
        new_metadata = DemonstrationMetadata(
            demo_id=f"{demo.metadata.demo_id}_spatial_{np.random.randint(10000)}",
            source="mimic_augmented",
            task_id=demo.metadata.task_id,
            embodiment=demo.metadata.embodiment,
            episode_length=demo.metadata.episode_length,
            success=demo.metadata.success,
            quality_score=demo.metadata.quality_score * 0.95,  # Slight quality reduction
            augmentation_history=demo.metadata.augmentation_history + ["spatial"],
        )

        return Demonstration(
            metadata=new_metadata,
            observations=new_obs,
            actions=demo.actions.copy(),
            rewards=demo.rewards.copy(),
            timestamps=demo.timestamps.copy(),
            language_instruction=demo.language_instruction,
            keypoints=demo.keypoints,
            contacts=demo.contacts.copy() if demo.contacts is not None else None,
        )


class TemporalScaling(AugmentationTransform):
    """Scale trajectory timing while preserving dynamics."""

    def apply(
        self,
        demo: Demonstration,
        scene: Optional[ArenaScene] = None
    ) -> Optional[Demonstration]:
        """Apply temporal scaling."""
        # Random time scale
        scale = np.random.uniform(
            self.config.time_scale_range[0],
            self.config.time_scale_range[1]
        )

        # Interpolate or subsample trajectory
        T = len(demo)
        new_T = int(T * scale)
        if new_T < 10:
            return None  # Too short

        # Interpolate observations
        old_times = np.linspace(0, 1, T)
        new_times = np.linspace(0, 1, new_T)

        new_obs = {}
        for key, value in demo.observations.items():
            if len(value.shape) == 1:
                new_obs[key] = np.interp(new_times, old_times, value)
            else:
                # Interpolate each dimension
                interp_value = np.zeros((new_T,) + value.shape[1:])
                for i in range(value.shape[1] if len(value.shape) > 1 else 1):
                    if len(value.shape) > 1:
                        interp_value[:, i] = np.interp(new_times, old_times, value[:, i])
                    else:
                        interp_value = np.interp(new_times, old_times, value)
                new_obs[key] = interp_value

        # Interpolate actions
        new_actions = np.zeros((new_T, demo.actions.shape[1]))
        for i in range(demo.actions.shape[1]):
            new_actions[:, i] = np.interp(new_times, old_times, demo.actions[:, i])

        # Scale rewards (sum should be similar)
        new_rewards = np.interp(new_times, old_times, demo.rewards)

        # New timestamps
        new_timestamps = demo.timestamps[0] + (demo.timestamps[-1] - demo.timestamps[0]) * new_times

        new_metadata = DemonstrationMetadata(
            demo_id=f"{demo.metadata.demo_id}_temporal_{np.random.randint(10000)}",
            source="mimic_augmented",
            task_id=demo.metadata.task_id,
            embodiment=demo.metadata.embodiment,
            episode_length=new_T,
            success=demo.metadata.success,
            quality_score=demo.metadata.quality_score * 0.98,
            augmentation_history=demo.metadata.augmentation_history + [f"temporal_{scale:.2f}"],
        )

        return Demonstration(
            metadata=new_metadata,
            observations=new_obs,
            actions=new_actions,
            rewards=new_rewards,
            timestamps=new_timestamps,
            language_instruction=demo.language_instruction,
            keypoints=demo.keypoints,
        )


class NoiseInjection(AugmentationTransform):
    """Inject realistic sensor and action noise."""

    def apply(
        self,
        demo: Demonstration,
        scene: Optional[ArenaScene] = None
    ) -> Optional[Demonstration]:
        """Apply noise injection."""
        new_obs = {}
        for key, value in demo.observations.items():
            noise = np.random.normal(
                0, self.config.observation_noise_std, value.shape
            )
            new_obs[key] = value + noise

        # Action noise
        action_noise = np.random.normal(
            0, self.config.action_noise_std, demo.actions.shape
        )
        new_actions = demo.actions + action_noise

        new_metadata = DemonstrationMetadata(
            demo_id=f"{demo.metadata.demo_id}_noise_{np.random.randint(10000)}",
            source="mimic_augmented",
            task_id=demo.metadata.task_id,
            embodiment=demo.metadata.embodiment,
            episode_length=demo.metadata.episode_length,
            success=demo.metadata.success,
            quality_score=demo.metadata.quality_score * 0.97,
            augmentation_history=demo.metadata.augmentation_history + ["noise"],
        )

        return Demonstration(
            metadata=new_metadata,
            observations=new_obs,
            actions=new_actions,
            rewards=demo.rewards.copy(),
            timestamps=demo.timestamps.copy(),
            language_instruction=demo.language_instruction,
            keypoints=demo.keypoints,
            contacts=demo.contacts.copy() if demo.contacts is not None else None,
        )


class ConstraintPreservingAugmentation(AugmentationTransform):
    """
    CP-Gen style constraint-preserving augmentation.

    Augments trajectories while maintaining:
    - Grasp constraints (gripper-object contact)
    - Placement constraints (object-surface contact)
    - Collision avoidance
    - Joint limits
    """

    def apply(
        self,
        demo: Demonstration,
        scene: Optional[ArenaScene] = None
    ) -> Optional[Demonstration]:
        """Apply constraint-preserving augmentation."""
        # Identify constraint keyframes
        keyframes = self._identify_constraint_keyframes(demo)

        if not keyframes:
            # No constraints found, fall back to spatial perturbation
            return SpatialPerturbation(self.config).apply(demo, scene)

        # Perturb trajectory while preserving constraints at keyframes
        new_obs = self._perturb_with_constraints(demo.observations, keyframes)

        if new_obs is None:
            return None

        # Recompute actions for perturbed trajectory (inverse kinematics)
        new_actions = self._recompute_actions(new_obs, demo.actions)

        if new_actions is None:
            return None

        new_metadata = DemonstrationMetadata(
            demo_id=f"{demo.metadata.demo_id}_cpgen_{np.random.randint(10000)}",
            source="mimic_augmented",
            task_id=demo.metadata.task_id,
            embodiment=demo.metadata.embodiment,
            episode_length=demo.metadata.episode_length,
            success=demo.metadata.success,
            quality_score=demo.metadata.quality_score * 0.99,  # High quality preservation
            augmentation_history=demo.metadata.augmentation_history + ["cpgen"],
        )

        return Demonstration(
            metadata=new_metadata,
            observations=new_obs,
            actions=new_actions,
            rewards=demo.rewards.copy(),
            timestamps=demo.timestamps.copy(),
            language_instruction=demo.language_instruction,
            keypoints=demo.keypoints,
            contacts=demo.contacts.copy() if demo.contacts is not None else None,
        )

    def _identify_constraint_keyframes(
        self,
        demo: Demonstration
    ) -> list[dict[str, Any]]:
        """Identify frames with active constraints."""
        keyframes = []

        # Check for grasp events (gripper state change)
        if "gripper_state" in demo.observations:
            gripper = demo.observations["gripper_state"]
            for t in range(1, len(gripper)):
                if gripper[t] != gripper[t - 1]:
                    keyframes.append({
                        "frame": t,
                        "type": "grasp" if gripper[t] < gripper[t - 1] else "release",
                    })

        # Check for contact events
        if demo.contacts is not None:
            for t in range(1, len(demo.contacts)):
                if np.any(demo.contacts[t] != demo.contacts[t - 1]):
                    keyframes.append({
                        "frame": t,
                        "type": "contact_change",
                    })

        return keyframes

    def _perturb_with_constraints(
        self,
        observations: dict[str, np.ndarray],
        keyframes: list[dict[str, Any]]
    ) -> Optional[dict[str, np.ndarray]]:
        """Perturb observations while preserving keyframe constraints."""
        new_obs = {k: v.copy() for k, v in observations.items()}

        # Get keyframe indices
        keyframe_indices = {kf["frame"] for kf in keyframes}

        # Apply perturbation to non-keyframe positions
        for key in ["object_pos", "target_pos"]:
            if key not in new_obs:
                continue

            for t in range(len(new_obs[key])):
                if t not in keyframe_indices:
                    # Apply perturbation
                    noise = np.random.normal(0, self.config.position_noise_std / 2, 3)
                    new_obs[key][t] += noise

            # Smooth trajectory to maintain continuity
            new_obs[key] = self._smooth_trajectory(new_obs[key])

        return new_obs

    def _smooth_trajectory(self, trajectory: np.ndarray) -> np.ndarray:
        """Apply smoothing to maintain trajectory continuity."""
        # Simple moving average smoothing
        kernel_size = 3
        if len(trajectory) < kernel_size:
            return trajectory

        smoothed = trajectory.copy()
        for i in range(1, len(trajectory) - 1):
            smoothed[i] = (trajectory[i - 1] + trajectory[i] + trajectory[i + 1]) / 3

        return smoothed

    def _recompute_actions(
        self,
        observations: dict[str, np.ndarray],
        original_actions: np.ndarray
    ) -> Optional[np.ndarray]:
        """Recompute actions for perturbed trajectory."""
        # For now, apply small corrections to original actions
        # Full implementation would use inverse kinematics
        T, action_dim = original_actions.shape

        new_actions = original_actions.copy()

        # Apply small corrections based on observation changes
        if "ee_pos" in observations:
            # Estimate position corrections needed
            for t in range(T - 1):
                # Add small action corrections
                correction = np.random.normal(0, 0.001, action_dim)
                new_actions[t] += correction

        return new_actions


# =============================================================================
# MIMIC AUGMENTER
# =============================================================================

class MimicAugmenter:
    """
    Isaac Lab-Mimic style demonstration augmenter.

    Scales demonstrations from Genie Sim through constraint-preserving
    augmentation while maintaining physics validity.
    """

    def __init__(self, config: MimicConfig):
        self.config = config
        self.transforms = self._create_transforms()

    def _create_transforms(self) -> list[AugmentationTransform]:
        """Create augmentation transforms based on config."""
        strategy_map = {
            AugmentationStrategy.SPATIAL_PERTURBATION: SpatialPerturbation,
            AugmentationStrategy.TEMPORAL_SCALING: TemporalScaling,
            AugmentationStrategy.NOISE_INJECTION: NoiseInjection,
            AugmentationStrategy.CONSTRAINT_PRESERVING: ConstraintPreservingAugmentation,
        }

        transforms = []
        for strategy in self.config.strategies:
            transform_cls = strategy_map.get(strategy)
            if transform_cls:
                transforms.append(transform_cls(self.config))

        return transforms

    def augment(
        self,
        demos: list[Demonstration],
        scene: Optional[ArenaScene] = None,
        progress_callback: Optional[callable] = None,
    ) -> AugmentationResult:
        """
        Augment demonstrations to achieve target scale.

        Args:
            demos: Input demonstrations (from Genie Sim)
            scene: Optional scene for constraint validation
            progress_callback: Optional callback(completed, total)

        Returns:
            AugmentationResult with scaled demonstrations
        """
        original_count = len(demos)
        target_count = min(
            max(original_count * self.config.scale_factor, self.config.min_demos_out),
            self.config.max_demos_out
        )

        augmented_demos: list[Demonstration] = []
        errors: list[str] = []
        validation_stats = {
            "transforms_applied": {t.__class__.__name__: 0 for t in self.transforms},
            "validation_failures": 0,
            "successful_augmentations": 0,
        }

        # Include originals if configured
        if self.config.include_original:
            augmented_demos.extend(demos)

        # Augment until we reach target
        attempts = 0
        max_attempts = target_count * 3  # Allow 3x attempts to reach target

        while len(augmented_demos) < target_count and attempts < max_attempts:
            # Select random source demo
            source_demo = demos[np.random.randint(len(demos))]

            # Select random transform
            transform = self.transforms[np.random.randint(len(self.transforms))]

            try:
                augmented = transform.apply(source_demo, scene)

                if augmented is not None:
                    # Validate if configured
                    if self.config.physics_validation:
                        valid = self._validate_demo(augmented, scene)
                    else:
                        valid = True

                    if valid:
                        augmented_demos.append(augmented)
                        validation_stats["transforms_applied"][transform.__class__.__name__] += 1
                        validation_stats["successful_augmentations"] += 1
                    else:
                        validation_stats["validation_failures"] += 1
                else:
                    validation_stats["validation_failures"] += 1

            except Exception as e:
                errors.append(f"Augmentation failed: {e}")

            attempts += 1

            if progress_callback and attempts % 100 == 0:
                progress_callback(len(augmented_demos), target_count)

        return AugmentationResult(
            success=len(augmented_demos) >= self.config.min_demos_out,
            original_count=original_count,
            augmented_count=len(augmented_demos) - original_count if self.config.include_original else len(augmented_demos),
            total_count=len(augmented_demos),
            scale_achieved=len(augmented_demos) / original_count if original_count > 0 else 0,
            demos=augmented_demos,
            validation_stats=validation_stats,
            errors=errors,
        )

    def _validate_demo(
        self,
        demo: Demonstration,
        scene: Optional[ArenaScene]
    ) -> bool:
        """Validate augmented demonstration."""
        # Check for NaN/Inf
        for key, value in demo.observations.items():
            if np.any(np.isnan(value)) or np.any(np.isinf(value)):
                return False

        if np.any(np.isnan(demo.actions)) or np.any(np.isinf(demo.actions)):
            return False

        # Check trajectory smoothness (no sudden jumps)
        for key in ["ee_pos", "object_pos"]:
            if key in demo.observations:
                traj = demo.observations[key]
                velocities = np.diff(traj, axis=0)
                max_velocity = np.max(np.linalg.norm(velocities, axis=-1))
                if max_velocity > 1.0:  # 1 m/step is too fast
                    return False

        return True

    def augment_from_genie_sim_output(
        self,
        genie_sim_dir: Path,
        output_dir: Path,
        scene: Optional[ArenaScene] = None,
    ) -> AugmentationResult:
        """
        Augment demonstrations from Genie Sim output directory.

        Args:
            genie_sim_dir: Path to Genie Sim episode output
            output_dir: Output directory for augmented demos
            scene: Optional scene for validation

        Returns:
            AugmentationResult
        """
        # Load Genie Sim episodes
        demos = self._load_genie_sim_episodes(genie_sim_dir)

        if not demos:
            return AugmentationResult(
                success=False,
                original_count=0,
                augmented_count=0,
                total_count=0,
                scale_achieved=0.0,
                demos=[],
                validation_stats={},
                errors=["No demonstrations found in Genie Sim output"],
            )

        # Augment
        result = self.augment(demos, scene)

        # Save augmented demos
        if result.success:
            self._save_augmented_demos(result.demos, output_dir)

        return result

    def _load_genie_sim_episodes(self, genie_sim_dir: Path) -> list[Demonstration]:
        """Load demonstrations from Genie Sim output."""
        demos = []

        dataset_root = self._resolve_lerobot_root(genie_sim_dir)
        if dataset_root is None:
            return demos

        meta_dir = dataset_root / "meta"
        data_dir = dataset_root / "data"

        info = self._load_lerobot_info(meta_dir / "info.json")
        format_value = info.get("export_format") or info.get("format")
        if format_value in (None, "lerobot"):
            export_format = (
                LeRobotExportFormat.LEROBOT_V3
                if str(info.get("version", "")).startswith("3")
                else LeRobotExportFormat.LEROBOT_V2
            )
        else:
            export_format = parse_lerobot_export_format(
                format_value,
                default=LeRobotExportFormat.LEROBOT_V2,
            )

        # Look for episode files
        episode_files = list(data_dir.glob("*.parquet"))
        if not episode_files:
            episode_files = list((data_dir / "chunk-000").glob("*.parquet"))

        # Also check for JSON episode metadata
        meta_file = meta_dir / "episodes.json"
        if meta_file.exists():
            with open(meta_file) as f:
                episode_meta = json.load(f)
        else:
            episode_meta = {}

        if export_format == LeRobotExportFormat.LEROBOT_V3:
            demos.extend(self._load_v3_episodes(episode_files, episode_meta))
        else:
            # Load each episode
            for ep_file in episode_files:
                try:
                    demo = self._load_parquet_episode(ep_file, episode_meta)
                    if demo:
                        demos.append(demo)
                except Exception as e:
                    print(f"Warning: Failed to load {ep_file}: {e}")

        return demos

    def _resolve_lerobot_root(self, genie_sim_dir: Path) -> Optional[Path]:
        """Resolve the LeRobot dataset root directory."""
        if (genie_sim_dir / "meta" / "info.json").exists():
            return genie_sim_dir
        candidate = genie_sim_dir / "episodes" / "lerobot"
        if (candidate / "meta" / "info.json").exists():
            return candidate
        return None

    @staticmethod
    def _load_lerobot_info(path: Path) -> dict[str, Any]:
        if path.exists():
            with open(path) as f:
                return json.load(f)
        return {}

    def _load_v3_episodes(
        self,
        episode_files: list[Path],
        episode_meta: dict[str, Any],
    ) -> list[Demonstration]:
        """Load LeRobot v3 multi-episode parquet files."""
        demos: list[Demonstration] = []
        if not episode_files:
            return demos
        try:
            import pandas as pd
        except ImportError:
            return demos

        for ep_file in episode_files:
            try:
                df = pd.read_parquet(ep_file)
            except Exception as e:
                print(f"Warning: Failed to load {ep_file}: {e}")
                continue
            if "episode_id" not in df.columns:
                demo = self._load_parquet_episode(ep_file, episode_meta)
                if demo:
                    demos.append(demo)
                continue
            for episode_id, group in df.groupby("episode_id", sort=False):
                demo = self._build_demo_from_dataframe(group, str(episode_id), episode_meta)
                if demo:
                    demos.append(demo)
        return demos

    def _load_parquet_episode(
        self,
        path: Path,
        episode_meta: dict[str, Any]
    ) -> Optional[Demonstration]:
        """Load a single episode from parquet file."""
        try:
            import pandas as pd
            df = pd.read_parquet(path)
            ep_id = path.stem
            return self._build_demo_from_dataframe(df, ep_id, episode_meta)

        except Exception:
            return None

    def _build_demo_from_dataframe(
        self,
        df: Any,
        episode_id: str,
        episode_meta: dict[str, Any],
    ) -> Optional[Demonstration]:
        """Build a demonstration from a dataframe."""
        observations = self._extract_observations(df)
        actions = self._extract_actions(df)

        rewards = df["reward"].values if "reward" in df.columns else np.zeros(len(df))
        timestamps = (
            df["timestamp"].values
            if "timestamp" in df.columns
            else np.arange(len(df)) / 120.0
        )

        meta = episode_meta.get(episode_id, {})
        metadata = DemonstrationMetadata(
            demo_id=episode_id,
            source="genie_sim",
            task_id=meta.get("task_id", "unknown"),
            embodiment=meta.get("robot", "franka"),
            episode_length=len(df),
            success=meta.get("success", True),
            quality_score=meta.get("quality_score", 0.9),
        )

        return Demonstration(
            metadata=metadata,
            observations=observations,
            actions=actions,
            rewards=rewards,
            timestamps=timestamps,
            language_instruction=meta.get("language_instruction"),
        )

    @staticmethod
    def _extract_observations(df: Any) -> dict[str, np.ndarray]:
        if "observation" in df.columns:
            obs_list = [json.loads(v) if isinstance(v, str) else v for v in df["observation"]]
            observations: dict[str, list[Any]] = {}
            for entry in obs_list:
                if isinstance(entry, dict):
                    for key, value in entry.items():
                        observations.setdefault(key, []).append(value)
            return {key: np.array(values) for key, values in observations.items()}

        obs_columns = [c for c in df.columns if c.startswith("observation.")]
        observations = {}
        for col in obs_columns:
            key = col.replace("observation.", "")
            observations[key] = df[col].values
        return observations

    @staticmethod
    def _extract_actions(df: Any) -> np.ndarray:
        if "action" in df.columns:
            action_list = [json.loads(v) if isinstance(v, str) else v for v in df["action"]]
            return np.array(action_list)

        action_columns = [c for c in df.columns if c.startswith("action.")]
        if action_columns:
            return np.stack([df[c].values for c in sorted(action_columns)], axis=1)
        return np.zeros((len(df), 7))

    def _save_augmented_demos(
        self,
        demos: list[Demonstration],
        output_dir: Path
    ) -> None:
        """Save augmented demonstrations."""
        output_dir.mkdir(parents=True, exist_ok=True)
        export_format = parse_lerobot_export_format(self.config.output_format)
        if export_format in (LeRobotExportFormat.LEROBOT_V2, LeRobotExportFormat.LEROBOT_V0_3_3):
            self._save_lerobot_format(demos, output_dir, export_format=export_format)
        elif export_format == LeRobotExportFormat.LEROBOT_V3:
            self._save_lerobot_v3_format(demos, output_dir)
        else:
            self._save_parquet_format(demos, output_dir)

    def _save_lerobot_format(
        self,
        demos: list[Demonstration],
        output_dir: Path,
        export_format: LeRobotExportFormat = LeRobotExportFormat.LEROBOT_V2,
    ) -> None:
        """Save in LeRobot v2.0 format."""
        import pandas as pd

        data_dir = output_dir / "data"
        data_dir.mkdir(exist_ok=True)

        meta_dir = output_dir / "meta"
        meta_dir.mkdir(exist_ok=True)

        episode_metadata = {}

        for i, demo in enumerate(demos):
            # Create dataframe
            df_data = {}

            # Add observations
            for key, value in demo.observations.items():
                if len(value.shape) == 1:
                    df_data[f"observation.{key}"] = value
                else:
                    for j in range(value.shape[1]):
                        df_data[f"observation.{key}.{j}"] = value[:, j]

            # Add actions
            for j in range(demo.actions.shape[1]):
                df_data[f"action.{j}"] = demo.actions[:, j]

            # Add rewards
            df_data["reward"] = demo.rewards

            # Add timestamps
            df_data["timestamp"] = demo.timestamps

            # Add episode index
            df_data["episode_index"] = i

            df = pd.DataFrame(df_data)
            df.to_parquet(data_dir / f"episode_{i:06d}.parquet")

            # Store metadata
            episode_metadata[f"episode_{i:06d}"] = {
                "demo_id": demo.metadata.demo_id,
                "task_id": demo.metadata.task_id,
                "embodiment": demo.metadata.embodiment,
                "success": demo.metadata.success,
                "quality_score": demo.metadata.quality_score,
                "source": demo.metadata.source,
                "augmentation_history": demo.metadata.augmentation_history,
                "language_instruction": demo.language_instruction,
            }

        # Save metadata
        with open(meta_dir / "episodes.json", "w") as f:
            json.dump(episode_metadata, f, indent=2)

        # Save info
        info = {
            "codebase_version": "2.0",
            "format": "lerobot",
            "export_format": export_format.value,
            "version": "0.3.3" if export_format == LeRobotExportFormat.LEROBOT_V0_3_3 else "2.0",
            "total_episodes": len(demos),
            "total_frames": sum(len(d) for d in demos),
            "fps": 120,
            "robot_type": demos[0].metadata.embodiment if demos else "unknown",
        }
        with open(meta_dir / "info.json", "w") as f:
            json.dump(info, f, indent=2)

    def _save_lerobot_v3_format(
        self,
        demos: list[Demonstration],
        output_dir: Path,
    ) -> None:
        """Save in LeRobot v3 multi-episode format."""
        import pandas as pd

        def _to_json_serializable(value: Any) -> Any:
            if isinstance(value, dict):
                return {k: _to_json_serializable(v) for k, v in value.items()}
            if isinstance(value, (list, tuple)):
                return [_to_json_serializable(v) for v in value]
            if isinstance(value, np.ndarray):
                return value.tolist()
            if isinstance(value, (np.floating, np.integer)):
                return value.item()
            return value

        data_dir = output_dir / "data" / "chunk-000"
        data_dir.mkdir(parents=True, exist_ok=True)

        meta_dir = output_dir / "meta"
        meta_dir.mkdir(exist_ok=True)

        episode_index = {}
        rows = []
        for i, demo in enumerate(demos):
            episode_id = f"episode_{i:06d}"
            episode_index[episode_id] = {
                "demo_id": demo.metadata.demo_id,
                "task_id": demo.metadata.task_id,
                "embodiment": demo.metadata.embodiment,
                "success": demo.metadata.success,
                "quality_score": demo.metadata.quality_score,
                "source": demo.metadata.source,
                "augmentation_history": demo.metadata.augmentation_history,
                "language_instruction": demo.language_instruction,
                "frame_count": len(demo),
            }
            for frame_index in range(len(demo)):
                observation_payload = {
                    k: _to_json_serializable(v[frame_index]) for k, v in demo.observations.items()
                }
                rows.append(
                    {
                        "episode_id": episode_id,
                        "frame_index": frame_index,
                        "timestamp": float(demo.timestamps[frame_index]),
                        "observation": json.dumps(observation_payload),
                        "action": json.dumps(_to_json_serializable(demo.actions[frame_index])),
                        "reward": float(demo.rewards[frame_index]),
                        "done": bool(frame_index == len(demo) - 1),
                        "task_id": demo.metadata.task_id,
                        "task_name": demo.metadata.task_id,
                    }
                )

        df = pd.DataFrame(rows)
        df.to_parquet(data_dir / "episodes.parquet")

        with open(meta_dir / "episode_index.json", "w") as f:
            json.dump(episode_index, f, indent=2)

        info = {
            "codebase_version": "2.0",
            "format": "lerobot",
            "export_format": LeRobotExportFormat.LEROBOT_V3.value,
            "version": "3.0",
            "layout": "multi-episode",
            "total_episodes": len(demos),
            "total_frames": sum(len(d) for d in demos),
            "fps": 120,
            "robot_type": demos[0].metadata.embodiment if demos else "unknown",
            "data_path": "data",
            "chunking": {
                "strategy": "aggregated",
                "chunk_dir": "chunk-000",
                "files": [{"path": "chunk-000/episodes.parquet", "episodes": len(demos)}],
            },
            "episode_index": "meta/episode_index.json",
        }
        with open(meta_dir / "info.json", "w") as f:
            json.dump(info, f, indent=2)

    def _save_parquet_format(
        self,
        demos: list[Demonstration],
        output_dir: Path
    ) -> None:
        """Save in simple parquet format."""
        import pandas as pd

        for i, demo in enumerate(demos):
            df_data = {}
            for key, value in demo.observations.items():
                df_data[f"obs_{key}"] = list(value)
            df_data["actions"] = list(demo.actions)
            df_data["rewards"] = demo.rewards

            df = pd.DataFrame(df_data)
            df.to_parquet(output_dir / f"demo_{i:06d}.parquet")


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def augment_genie_sim_episodes(
    genie_sim_dir: Path,
    output_dir: Path,
    scale_factor: int = 10,
    scene: Optional[ArenaScene] = None,
) -> AugmentationResult:
    """
    Convenience function to augment Genie Sim episodes.

    Args:
        genie_sim_dir: Path to Genie Sim output
        output_dir: Output directory
        scale_factor: Demo multiplication factor
        scene: Optional scene for validation

    Returns:
        AugmentationResult
    """
    config = MimicConfig(scale_factor=scale_factor)
    augmenter = MimicAugmenter(config)
    return augmenter.augment_from_genie_sim_output(genie_sim_dir, output_dir, scene)
