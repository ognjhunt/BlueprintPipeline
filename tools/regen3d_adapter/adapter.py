"""3D-RE-GEN to BlueprintPipeline adapter.

Converts 3D-RE-GEN reconstruction outputs into formats expected by downstream jobs.

3D-RE-GEN (arXiv:2512.17459) is a modular, compositional pipeline that generates
separable objects + a comprehensive background mesh, then assembles them with
explicit physical constraints (4-DoF ground contact, anti-penetration) for
sim-ready scene reconstruction.

Expected 3D-RE-GEN Output Structure:
    regen3d_output/
        scene_info.json           # Scene metadata + camera parameters
        objects/
            obj_0/
                mesh.glb          # Triangulated mesh (from Hunyuan3D 2.0)
                material.json     # PBR material parameters
                pose.json         # 4x4 transform matrix (optimized via PyTorch3D)
                bounds.json       # Axis-aligned bounding box
                segmentation.png  # Instance mask from Grounded-SAM (optional)
            obj_1/
            ...
        background/
            mesh.glb              # Background/scene shell mesh (from VGGT)
            material.json
        depth/
            depth.exr             # Extracted depth map
            depth_confidence.png  # Depth confidence mask
        camera/
            intrinsics.json       # Camera intrinsics matrix (from VGGT)
            extrinsics.json       # Camera pose (optional)

This adapter produces:
    assets/
        scene_manifest.json       # Canonical manifest
        obj_0/, obj_1/, ...       # Asset directories with GLB + metadata
    layout/
        scene_layout_scaled.json  # Layout with OBB transforms

Key 3D-RE-GEN differentiators vs prior work:
- 4-DoF ground-alignment constraint for floor-contact objects
- Background bounding constraint to prevent penetration
- A-Q (Application-Querying) for scene-aware occlusion completion
- Comprehensive background mesh for collision and lighting support

Reference:
- Paper: https://arxiv.org/abs/2512.17459
- Project: https://3dregen.jdihlmann.com/
- GitHub: https://github.com/cgtuebingen/3D-RE-GEN
"""

from __future__ import annotations

import json
import logging
import shutil
from dataclasses import dataclass, field, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
import numpy as np

from tools.config.production_mode import resolve_production_mode

try:
    from tools.validation import validate_rotation_matrix, ValidationError
    HAVE_VALIDATION_TOOLS = True
except ImportError:
    HAVE_VALIDATION_TOOLS = False
    ValidationError = ValueError

logger = logging.getLogger(__name__)


# =============================================================================
# Data Classes for 3D-RE-GEN Outputs
# =============================================================================


@dataclass
class Regen3DPose:
    """Object pose from 3D-RE-GEN.

    3D-RE-GEN optimizes poses using differentiable rendering with PyTorch3D,
    including 2D silhouette loss (Dice + Focal), 3D geometric loss (point-to-mesh),
    and background bounding constraint.

    For floor-contact objects, 3D-RE-GEN uses a 4-DoF model:
    - Translation constrained to floor plane (x, z)
    - Yaw rotation only
    - Uniform scale

    The transform is a 4x4 matrix in world coordinates.
    """
    transform_matrix: List[List[float]]  # 4x4 row-major matrix
    translation: Optional[List[float]] = None  # [x, y, z]
    rotation_quaternion: Optional[List[float]] = None  # [w, x, y, z]
    scale: Optional[List[float]] = None  # [sx, sy, sz]
    confidence: float = 1.0
    is_floor_contact: bool = False  # True if 4-DoF ground-aligned


@dataclass
class Regen3DMaterial:
    """PBR material parameters from 3D-RE-GEN.

    Material properties extracted from the generated meshes.
    """
    base_color: List[float] = field(default_factory=lambda: [0.8, 0.8, 0.8])  # RGB
    metallic: float = 0.0
    roughness: float = 0.5
    normal_map_path: Optional[str] = None
    albedo_map_path: Optional[str] = None
    material_type: str = "generic"  # ceramic, metal, wood, plastic, fabric, etc.


@dataclass
class Regen3DObject:
    """Single object from 3D-RE-GEN reconstruction.

    Represents a foreground object with mesh, pose, and material.
    The mesh is generated by Hunyuan3D 2.0 from inpainted object images
    (using A-Q for scene-aware occlusion completion).
    """
    id: str
    mesh_path: str  # Path to GLB file
    pose: Regen3DPose
    bounds: Dict[str, List[float]]  # {"min": [x,y,z], "max": [x,y,z], "center": [...], "size": [...]}
    material: Optional[Regen3DMaterial] = None
    segmentation_mask_path: Optional[str] = None

    # Semantic information (may be inferred by downstream jobs)
    category: Optional[str] = None
    description: Optional[str] = None
    sim_role: str = "unknown"  # Will be enriched by inventory step

    # Confidence/quality metrics
    reconstruction_confidence: float = 1.0
    mesh_quality_score: Optional[float] = None


@dataclass
class Regen3DOutput:
    """Complete 3D-RE-GEN reconstruction output.

    Contains all objects, background, and scene metadata.
    The background mesh is critical for simulation as it provides
    collision support and spatial reference for object placement.
    """
    scene_id: str
    objects: List[Regen3DObject]
    background: Optional[Regen3DObject] = None

    # Camera parameters (from VGGT geometry transformer)
    camera_intrinsics: Optional[List[List[float]]] = None  # 3x3 matrix
    camera_extrinsics: Optional[List[List[float]]] = None  # 4x4 matrix
    image_size: Tuple[int, int] = (1920, 1080)

    # Scene metadata
    coordinate_frame: str = "y_up"  # or "z_up"
    meters_per_unit: float = 1.0
    depth_map_path: Optional[str] = None
    source_image_path: Optional[str] = None

    # Quality metrics
    overall_confidence: float = 1.0
    reconstruction_method: str = "3d-re-gen"
    version: str = "1.0"


# =============================================================================
# Adapter Implementation
# =============================================================================


class Regen3DAdapter:
    """Adapter to convert 3D-RE-GEN outputs to BlueprintPipeline formats.

    Usage:
        adapter = Regen3DAdapter()
        regen3d_output = adapter.load_regen3d_output(regen3d_dir)
        manifest = adapter.create_manifest(regen3d_output, scene_id)
        layout = adapter.create_layout(regen3d_output)
        adapter.copy_assets(regen3d_output, output_dir)
    """

    MANIFEST_VERSION = "1.0.0"

    def __init__(self, verbose: bool = True):
        self.verbose = verbose
        self._llm_client = None
        self._llm_init_attempted = False
        self._dimension_cache: Dict[str, Dict[str, float]] = {}

    def log(self, msg: str) -> None:
        if self.verbose:
            print(f"[REGEN3D-ADAPTER] {msg}")

    def _get_llm_client(self):
        """Lazily initialize LLM client for Gemini estimation."""
        if not self._llm_init_attempted:
            self._llm_init_attempted = True
            try:
                from tools.llm_client import get_llm_client
                self._llm_client = get_llm_client()
            except Exception:
                self._llm_client = None
        return self._llm_client

    def _estimate_dimensions_gemini(self, category: str) -> Optional[Dict[str, float]]:
        """Estimate object dimensions using Gemini based on category."""
        if category in self._dimension_cache:
            return self._dimension_cache[category]
        llm = self._get_llm_client()
        if not llm:
            return None
        try:
            prompt = (
                f"Estimate the typical width, height, and depth in meters for a '{category}' object. "
                f"Return ONLY a JSON object like: {{\"width\": 0.3, \"height\": 0.2, \"depth\": 0.3}}"
            )
            resp = llm.generate(prompt)
            import json as _json
            dims = _json.loads(resp.strip())
            if isinstance(dims, dict) and all(k in dims for k in ("width", "height", "depth")):
                self._dimension_cache[category] = dims
                return dims
        except Exception:
            pass
        return None

    def load_regen3d_output(self, regen3d_dir: Path) -> Regen3DOutput:
        """Load 3D-RE-GEN outputs from a directory.

        Args:
            regen3d_dir: Path to 3D-RE-GEN output directory

        Returns:
            Parsed Regen3DOutput
        """
        regen3d_dir = Path(regen3d_dir)

        # Load scene info
        scene_info_path = regen3d_dir / "scene_info.json"
        if scene_info_path.is_file():
            scene_info = json.loads(scene_info_path.read_text())
        else:
            scene_info = {}

        scene_id = scene_info.get("scene_id", regen3d_dir.name)

        # Load objects
        objects = []
        objects_dir = regen3d_dir / "objects"
        if objects_dir.is_dir():
            for obj_dir in sorted(objects_dir.iterdir()):
                if obj_dir.is_dir():
                    obj = self._load_object(obj_dir)
                    if obj:
                        objects.append(obj)

        # Load background
        background = None
        bg_dir = regen3d_dir / "background"
        if bg_dir.is_dir():
            background = self._load_object(bg_dir, is_background=True)

        # Load camera parameters
        camera_intrinsics = None
        camera_extrinsics = None
        camera_dir = regen3d_dir / "camera"
        if camera_dir.is_dir():
            intr_path = camera_dir / "intrinsics.json"
            if intr_path.is_file():
                camera_intrinsics = json.loads(intr_path.read_text()).get("matrix")
            extr_path = camera_dir / "extrinsics.json"
            if extr_path.is_file():
                camera_extrinsics = json.loads(extr_path.read_text()).get("matrix")

        # Get depth map path
        depth_map_path = None
        depth_dir = regen3d_dir / "depth"
        if depth_dir.is_dir():
            for ext in [".exr", ".png", ".npy"]:
                candidate = depth_dir / f"depth{ext}"
                if candidate.is_file():
                    depth_map_path = str(candidate)
                    break

        return Regen3DOutput(
            scene_id=scene_id,
            objects=objects,
            background=background,
            camera_intrinsics=camera_intrinsics,
            camera_extrinsics=camera_extrinsics,
            image_size=tuple(scene_info.get("image_size", [1920, 1080])),
            coordinate_frame=scene_info.get("coordinate_frame", "y_up"),
            meters_per_unit=scene_info.get("meters_per_unit", 1.0),
            depth_map_path=depth_map_path,
            source_image_path=scene_info.get("source_image_path"),
            overall_confidence=scene_info.get("confidence", 1.0),
            reconstruction_method="3d-re-gen",
            version=scene_info.get("version", "1.0"),
        )

    def _load_object(self, obj_dir: Path, is_background: bool = False) -> Optional[Regen3DObject]:
        """Load a single object from its directory."""
        # Find mesh file
        mesh_path = None
        for name in ["mesh.glb", "model.glb", "asset.glb", "mesh.obj"]:
            candidate = obj_dir / name
            if candidate.is_file():
                mesh_path = str(candidate)
                break

        if not mesh_path:
            self.log(f"WARNING: No mesh found in {obj_dir}")
            return None

        # Load pose
        pose_path = obj_dir / "pose.json"
        if pose_path.is_file():
            pose_data = json.loads(pose_path.read_text())
            pose = Regen3DPose(
                transform_matrix=pose_data.get("transform_matrix", np.eye(4).tolist()),
                translation=pose_data.get("translation"),
                rotation_quaternion=pose_data.get("rotation_quaternion"),
                scale=pose_data.get("scale"),
                confidence=pose_data.get("confidence", 1.0),
                is_floor_contact=pose_data.get("is_floor_contact", False),
            )
        else:
            pose = Regen3DPose(transform_matrix=np.eye(4).tolist())

        # Load bounds
        bounds_path = obj_dir / "bounds.json"
        if bounds_path.is_file():
            bounds = json.loads(bounds_path.read_text())
        else:
            # Default bounds
            bounds = {
                "min": [-0.5, -0.5, -0.5],
                "max": [0.5, 0.5, 0.5],
                "center": [0.0, 0.0, 0.0],
                "size": [1.0, 1.0, 1.0],
            }

        # Load material
        material = None
        mat_path = obj_dir / "material.json"
        if mat_path.is_file():
            mat_data = json.loads(mat_path.read_text())
            material = Regen3DMaterial(
                base_color=mat_data.get("base_color", [0.8, 0.8, 0.8]),
                metallic=mat_data.get("metallic", 0.0),
                roughness=mat_data.get("roughness", 0.5),
                normal_map_path=mat_data.get("normal_map_path"),
                albedo_map_path=mat_data.get("albedo_map_path"),
                material_type=mat_data.get("material_type", "generic"),
            )

        # Find segmentation mask
        seg_mask_path = None
        for name in ["segmentation.png", "mask.png"]:
            candidate = obj_dir / name
            if candidate.is_file():
                seg_mask_path = str(candidate)
                break

        obj_id = "scene_background" if is_background else obj_dir.name
        sim_role = "background" if is_background else "unknown"

        # Load semantic label if harvester wrote one
        category = None
        label_path = obj_dir / "label.json"
        if label_path.is_file():
            try:
                label_data = json.loads(label_path.read_text())
                category = label_data.get("label")
            except Exception:
                pass

        return Regen3DObject(
            id=obj_id,
            mesh_path=mesh_path,
            pose=pose,
            bounds=bounds,
            material=material,
            segmentation_mask_path=seg_mask_path,
            sim_role=sim_role,
            category=category,
        )

    def create_manifest(
        self,
        regen3d_output: Regen3DOutput,
        scene_id: Optional[str] = None,
        environment_type: str = "generic",
        scale_factor: float = 1.0,
    ) -> Dict[str, Any]:
        """Create a canonical scene_manifest.json from 3D-RE-GEN output. Now applies scale_factor consistently with create_layout().

        Args:
            regen3d_output: Parsed 3D-RE-GEN output
            scene_id: Optional override for scene ID
            environment_type: Type of environment (kitchen, office, etc.)
            scale_factor: Optional scale factor to apply (default: 1.0)

        Returns:
            Manifest dictionary ready for JSON serialization
        """
        scene_id = scene_id or regen3d_output.scene_id

        objects = []

        # Process foreground objects
        for obj in regen3d_output.objects:
            manifest_obj = self._object_to_manifest(obj, regen3d_output, scale_factor)
            objects.append(manifest_obj)

        # Process background
        if regen3d_output.background:
            bg_obj = self._object_to_manifest(
                regen3d_output.background,
                regen3d_output,
                scale_factor,
                is_background=True,
            )
            objects.append(bg_obj)

        manifest = {
            "version": self.MANIFEST_VERSION,
            "scene_id": scene_id,
            "scene": {
                "coordinate_frame": regen3d_output.coordinate_frame,
                "meters_per_unit": regen3d_output.meters_per_unit * scale_factor,
                "environment_type": environment_type,
                "room": {
                    k: v for k, v in self._compute_room_bounds(regen3d_output, scale_factor).items()
                    if k in ("bounds", "origin")
                },
                "physics_defaults": {
                    "gravity": {"x": 0.0, "y": -9.81, "z": 0.0},
                    "solver": "TGS",
                    "time_steps_per_second": 60,
                },
            },
            "objects": objects,
            "assets": {
                "asset_root": f"scenes/{scene_id}/assets",
                "packs": [],
            },
            "metadata": {
                "source_pipeline": "3d-re-gen",
                "regen3d_version": regen3d_output.version,
                "reconstruction_confidence": regen3d_output.overall_confidence,
                "source_image_path": regen3d_output.source_image_path,
                "scale_factor": scale_factor,
            },
        }

        return manifest

    def _object_to_manifest(
        self,
        obj: Regen3DObject,
        scene: Regen3DOutput,
        scale_factor: float = 1.0,
        is_background: bool = False,
    ) -> Dict[str, Any]:
        """Convert a Regen3DObject to manifest object format. Now applies scale_factor to translation and scale components.
        """
        # Extract transform components from matrix
        transform = self._decompose_transform(obj.pose.transform_matrix)

        # Apply scale_factor to translation and scale
        if scale_factor != 1.0:
            transform["translation"] = [v * scale_factor for v in transform["translation"]]
            transform["scale"] = [v * scale_factor for v in transform["scale"]]

        # Determine sim_role based on object properties
        sim_role = obj.sim_role
        if sim_role == "unknown":
            # Will be enriched by inventory/segmentation job
            sim_role = "static"

        manifest_obj = {
            "id": obj.id,
            "sim_role": sim_role,
            "name": obj.id,
            "category": obj.category or ("background" if is_background else "object"),
            "description": obj.description or f"Object {obj.id}",
            "transform": {
                "position": {
                    "x": transform["translation"][0],
                    "y": transform["translation"][1],
                    "z": transform["translation"][2],
                },
                "scale": {
                    "x": transform["scale"][0],
                    "y": transform["scale"][1],
                    "z": transform["scale"][2],
                },
                "rotation_quaternion": {
                    "w": transform["rotation"][0],
                    "x": transform["rotation"][1],
                    "y": transform["rotation"][2],
                    "z": transform["rotation"][3],
                },
            },
            "asset": {
                "path": f"assets/obj_{obj.id}/asset.glb",
                "format": "glb",
                "source": "3d-re-gen",
            },
            "dimensions_est": self._compute_dimensions_est(obj),
            "semantics": {
                "class": obj.category or "object",
                "affordances": [],
                "tags": [],
            },
            "physics": {},  # Will be enriched by simready-job
            "physics_hints": {
                "is_floor_contact": obj.pose.is_floor_contact,
            },
            "articulation": {},  # Will be enriched by interactive-job
            "relationships": [],
            "variation_candidate": False,
        }

        # Add material hints if available
        if obj.material:
            manifest_obj["physics_hints"]["material_type"] = obj.material.material_type
            manifest_obj["physics_hints"]["roughness"] = obj.material.roughness
            manifest_obj["physics_hints"]["metallic"] = obj.material.metallic

        return manifest_obj

    def _compute_dimensions_est(self, obj: Regen3DObject) -> Dict[str, float]:
        """Compute dimensions with Gemini fallback instead of silent [1,1,1] default.

        Note: dimensions_source provenance is tracked in metadata.source_pipeline,
        not in dimensions_est itself (schema has additionalProperties: false).
        """
        size = obj.bounds.get("size")
        if size and size != [1, 1, 1] and any(s != 1.0 for s in size):
            return {
                "width": size[0],
                "height": size[1],
                "depth": size[2],
            }

        # Try Gemini estimation
        category = obj.category or "object"
        gemini_dims = self._estimate_dimensions_gemini(category)
        if gemini_dims:
            logger.info("Using Gemini-estimated dimensions for '%s' (%s)", obj.id, category)
            return {
                "width": gemini_dims["width"],
                "height": gemini_dims["height"],
                "depth": gemini_dims["depth"],
            }

        # Final fallback
        logger.warning("Using heuristic default dimensions for '%s' - no bounds or Gemini available", obj.id)
        default = obj.bounds.get("size", [1, 1, 1])
        return {
            "width": default[0],
            "height": default[1],
            "depth": default[2],
        }

    def _decompose_transform(self, matrix: List[List[float]]) -> Dict[str, List[float]]:
        """Decompose a 4x4 transform matrix into translation, rotation, scale."""
        m = np.array(matrix, dtype=np.float64)
        production_mode = resolve_production_mode()

        # Translation
        translation = m[:3, 3].tolist()

        # Extract rotation matrix (upper 3x3)
        rot_scale = m[:3, :3]

        # Scale from column norms
        scale = [
            float(np.linalg.norm(rot_scale[:, 0])),
            float(np.linalg.norm(rot_scale[:, 1])),
            float(np.linalg.norm(rot_scale[:, 2])),
        ]

        # Normalize to get rotation
        rot = rot_scale.copy()
        for i in range(3):
            if scale[i] > 1e-6:
                rot[:, i] /= scale[i]

        if HAVE_VALIDATION_TOOLS:
            try:
                rot = validate_rotation_matrix(
                    rot,
                    field_name=f"{self.__class__.__name__}.rotation_matrix",
                    auto_fix=not production_mode,
                )
            except ValidationError as exc:
                if production_mode:
                    raise ValueError(
                        f"Rotation matrix validation failed in production: {exc}. "
                        "Cannot use identity fallback for production data."
                    )
                logger.warning("Rotation matrix validation failed: %s. Using identity fallback.", exc)
                rot = np.eye(3)

        # Convert rotation matrix to quaternion
        rotation = self._matrix_to_quaternion(rot)

        return {
            "translation": translation,
            "rotation": rotation,  # [w, x, y, z]
            "scale": scale,
        }

    def _matrix_to_quaternion(self, m: np.ndarray) -> List[float]:
        """Convert 3x3 rotation matrix to quaternion [w, x, y, z]."""
        trace = m[0, 0] + m[1, 1] + m[2, 2]

        if trace > 0:
            s = 0.5 / np.sqrt(trace + 1.0)
            w = 0.25 / s
            x = (m[2, 1] - m[1, 2]) * s
            y = (m[0, 2] - m[2, 0]) * s
            z = (m[1, 0] - m[0, 1]) * s
        elif m[0, 0] > m[1, 1] and m[0, 0] > m[2, 2]:
            s = 2.0 * np.sqrt(1.0 + m[0, 0] - m[1, 1] - m[2, 2])
            w = (m[2, 1] - m[1, 2]) / s
            x = 0.25 * s
            y = (m[0, 1] + m[1, 0]) / s
            z = (m[0, 2] + m[2, 0]) / s
        elif m[1, 1] > m[2, 2]:
            s = 2.0 * np.sqrt(1.0 + m[1, 1] - m[0, 0] - m[2, 2])
            w = (m[0, 2] - m[2, 0]) / s
            x = (m[0, 1] + m[1, 0]) / s
            y = 0.25 * s
            z = (m[1, 2] + m[2, 1]) / s
        else:
            s = 2.0 * np.sqrt(1.0 + m[2, 2] - m[0, 0] - m[1, 1])
            w = (m[1, 0] - m[0, 1]) / s
            x = (m[0, 2] + m[2, 0]) / s
            y = (m[1, 2] + m[2, 1]) / s
            z = 0.25 * s

        return [float(w), float(x), float(y), float(z)]

    def _compute_room_bounds(self, regen3d_output: Regen3DOutput, scale_factor: float = 1.0) -> Dict[str, Any]:
        """Compute room bounds from all objects. Now applies scale_factor to bounds.
        """
        all_bounds = []

        for obj in regen3d_output.objects:
            all_bounds.append(obj.bounds)

        if regen3d_output.background:
            all_bounds.append(regen3d_output.background.bounds)

        if not all_bounds:
            # Try Gemini estimation for room bounds
            llm = self._get_llm_client()
            if llm:
                try:
                    prompt = (
                        "Estimate typical room dimensions in meters for a simulation scene. "
                        "Return ONLY JSON: {\"min\": [x,y,z], \"max\": [x,y,z]}"
                    )
                    import json as _json
                    resp = llm.generate(prompt)
                    room_data = _json.loads(resp.strip())
                    room_min = room_data.get("min", [-5.0, 0.0, -5.0])
                    room_max = room_data.get("max", [5.0, 3.0, 5.0])
                except Exception:
                    room_min = [-5.0, 0.0, -5.0]
                    room_max = [5.0, 3.0, 5.0]
            else:
                room_min = [-5.0, 0.0, -5.0]
                room_max = [5.0, 3.0, 5.0]
        else:
            # Compute union of all bounds
            mins = np.array([b.get("min", [-5, 0, -5]) for b in all_bounds])
            maxs = np.array([b.get("max", [5, 3, 5]) for b in all_bounds])
            room_min = mins.min(axis=0).tolist()
            room_max = maxs.max(axis=0).tolist()

        # Apply scale_factor
        if scale_factor != 1.0:
            room_min = [v * scale_factor for v in room_min]
            room_max = [v * scale_factor for v in room_max]

        return {
            "bounds": {
                "width": room_max[0] - room_min[0],
                "depth": room_max[2] - room_min[2],
                "height": room_max[1] - room_min[1],
            },
            "min": room_min,
            "max": room_max,
            "origin": [
                (room_min[0] + room_max[0]) / 2,
                room_min[1],  # Origin at floor level
                (room_min[2] + room_max[2]) / 2,
            ],
        }

    def create_layout(
        self,
        regen3d_output: Regen3DOutput,
        apply_scale_factor: float = 1.0,
    ) -> Dict[str, Any]:
        """Create scene_layout_scaled.json from 3D-RE-GEN output.

        This layout format is required by usd-assembly-job.

        Args:
            regen3d_output: Parsed 3D-RE-GEN output
            apply_scale_factor: Optional scale factor to apply

        Returns:
            Layout dictionary ready for JSON serialization
        """
        objects = []

        for obj in regen3d_output.objects:
            layout_obj = self._object_to_layout(obj, apply_scale_factor)
            objects.append(layout_obj)

        if regen3d_output.background:
            bg_obj = self._object_to_layout(
                regen3d_output.background,
                apply_scale_factor,
                is_background=True,
            )
            objects.append(bg_obj)

        # Compute room box
        room_info = self._compute_room_bounds(regen3d_output)
        room_box = {
            "min": room_info["min"],
            "max": room_info["max"],
        }

        # Apply scale factor to room box
        if apply_scale_factor != 1.0:
            room_box["min"] = [v * apply_scale_factor for v in room_box["min"]]
            room_box["max"] = [v * apply_scale_factor for v in room_box["max"]]

        layout = {
            "scene_id": regen3d_output.scene_id,
            "objects": objects,
            "room_box": room_box,
            "room_planes": self._generate_room_planes(room_box),
            "camera_trajectory": self._build_camera_trajectory(regen3d_output),
            "scale_factor": apply_scale_factor,
            "meters_per_unit": regen3d_output.meters_per_unit * apply_scale_factor,
            "coordinate_frame": regen3d_output.coordinate_frame,
            "metadata": {
                "source": "3d-re-gen",
                "scaled": apply_scale_factor != 1.0,
            },
        }

        return layout

    def _object_to_layout(
        self,
        obj: Regen3DObject,
        scale_factor: float,
        is_background: bool = False,
    ) -> Dict[str, Any]:
        """Convert Regen3DObject to layout object format with OBB data. OBB (Oriented Bounding Box) format used by downstream jobs:
        - center: 3D position [x, y, z] in world coordinates
        - extents: Half-sizes of the bounding box [hx, hy, hz]
        - R: 3x3 rotation matrix [row0, row1, row2]

        The OBB is used by build_scene_usd.py to reconstruct the world transform:
            T_world = OBB.R @ diag(OBB.extents) @ T_local

        Where:
        - OBB.center is the 3D position in world space
        - OBB.R is the rotation orientation
        - OBB.extents are half-sizes used to scale the mesh to fit the bounding box
        - T_local is the local mesh-to-OBB transform

        See: usd-assembly-job/build_scene_usd.py:matrix_from_obb() for conversion details
        """
        # Extract center from transform or bounds
        m = np.array(obj.pose.transform_matrix, dtype=np.float64)
        center = (m[:3, 3] * scale_factor).tolist()

        # Compute scaled extents (half-sizes)
        # Extents represent HALF the actual size of the bounding box
        size = obj.bounds.get("size", [1, 1, 1])
        extents = [s * scale_factor * 0.5 for s in size]

        # Extract rotation matrix (3x3) from the 4x4 transform
        # This preserves the object's orientation in world space
        rot = m[:3, :3].tolist()

        layout_obj = {
            "id": obj.id,
            "class_name": obj.category or ("scene_background" if is_background else "object"),
            "center3d": center,
            "obb": {
                "center": center,  # World position
                "extents": extents,  # Half-sizes for scaling mesh
                "R": rot,  # Rotation matrix for orientation
            },
            "bounds": {
                "min": [center[i] - extents[i] for i in range(3)],
                "max": [center[i] + extents[i] for i in range(3)],
            },
            "approx_location": self._center_to_approx_location(center),
            "is_floor_contact": obj.pose.is_floor_contact,
        }

        return layout_obj

    def _center_to_approx_location(self, center: List[float]) -> str:
        """Convert 3D center to approx_location string."""
        x, y, z = center

        h = "center"
        if x < -1:
            h = "left"
        elif x > 1:
            h = "right"

        v = "middle"
        if z < -1:
            v = "bottom"
        elif z > 1:
            v = "top"

        return f"{v} {h}"

    def _generate_room_planes(self, room_box: Dict[str, List[float]]) -> Dict[str, Any]:
        """Generate room plane equations from room box."""
        min_pt = room_box["min"]
        max_pt = room_box["max"]

        return {
            "floor": {
                "equation": [0, 1, 0, -min_pt[1]],  # y = min_y
                "normal": [0, 1, 0],
            },
            "ceiling": {
                "equation": [0, -1, 0, max_pt[1]],  # y = max_y
                "normal": [0, -1, 0],
            },
            "walls": [
                {"equation": [1, 0, 0, -min_pt[0]], "normal": [1, 0, 0]},   # x = min_x
                {"equation": [-1, 0, 0, max_pt[0]], "normal": [-1, 0, 0]}, # x = max_x
                {"equation": [0, 0, 1, -min_pt[2]], "normal": [0, 0, 1]},   # z = min_z
                {"equation": [0, 0, -1, max_pt[2]], "normal": [0, 0, -1]}, # z = max_z
            ],
        }

    def _build_camera_trajectory(self, regen3d_output: Regen3DOutput) -> List[Dict]:
        """Build camera trajectory from 3D-RE-GEN camera parameters."""
        cameras = []

        if regen3d_output.camera_intrinsics:
            cam = {
                "id": 0,
                "intrinsics": regen3d_output.camera_intrinsics,
                "image_size": list(regen3d_output.image_size),
            }
            if regen3d_output.camera_extrinsics:
                cam["extrinsics"] = regen3d_output.camera_extrinsics
            if regen3d_output.source_image_path:
                cam["image_path"] = regen3d_output.source_image_path
            cameras.append(cam)

        return cameras

    def copy_assets(
        self,
        regen3d_output: Regen3DOutput,
        output_dir: Path,
        assets_prefix: str = "assets",
    ) -> Dict[str, str]:
        """Copy 3D-RE-GEN assets to the expected directory structure.

        Creates:
            output_dir/
                {assets_prefix}/
                    obj_{id}/
                        asset.glb
                        metadata.json

        Args:
            regen3d_output: Parsed 3D-RE-GEN output
            output_dir: Base output directory
            assets_prefix: Prefix for assets directory

        Returns:
            Mapping of object IDs to their asset paths
        """
        output_dir = Path(output_dir)
        assets_dir = output_dir / assets_prefix

        asset_paths = {}

        # Copy foreground objects
        for obj in regen3d_output.objects:
            obj_dir = assets_dir / f"obj_{obj.id}"
            obj_dir.mkdir(parents=True, exist_ok=True)

            # Copy mesh
            src_mesh = Path(obj.mesh_path)
            dst_mesh = obj_dir / "asset.glb"
            if src_mesh.is_file():
                shutil.copy2(src_mesh, dst_mesh)
                asset_paths[obj.id] = str(dst_mesh.relative_to(output_dir))
                self.log(f"Copied mesh for obj_{obj.id}")

            # Write metadata
            metadata = {
                "id": obj.id,
                "category": obj.category,
                "mesh_bounds": {
                    "export": {
                        "min": obj.bounds.get("min"),
                        "max": obj.bounds.get("max"),
                        "center": obj.bounds.get("center"),
                        "size": obj.bounds.get("size"),
                    }
                },
                "source": "3d-re-gen",
                "reconstruction_confidence": obj.reconstruction_confidence,
                "is_floor_contact": obj.pose.is_floor_contact,
            }

            if obj.material:
                metadata["material"] = asdict(obj.material)

            metadata_path = obj_dir / "metadata.json"
            metadata_path.write_text(json.dumps(metadata, indent=2))

        # Copy background
        if regen3d_output.background:
            bg_dir = assets_dir / "obj_scene_background"
            bg_dir.mkdir(parents=True, exist_ok=True)

            src_mesh = Path(regen3d_output.background.mesh_path)
            dst_mesh = bg_dir / "asset.glb"
            if src_mesh.is_file():
                shutil.copy2(src_mesh, dst_mesh)
                asset_paths["scene_background"] = str(dst_mesh.relative_to(output_dir))
                self.log("Copied background mesh")

        return asset_paths


# =============================================================================
# Convenience Functions
# =============================================================================


def manifest_from_regen3d(
    regen3d_dir: Path,
    scene_id: Optional[str] = None,
    environment_type: str = "generic",
) -> Dict[str, Any]:
    """Create a canonical scene_manifest.json from 3D-RE-GEN output directory.

    This is the primary integration point for the 3D-RE-GEN-first pipeline.

    Args:
        regen3d_dir: Path to 3D-RE-GEN output directory
        scene_id: Optional scene ID (defaults to directory name)
        environment_type: Type of environment (kitchen, office, etc.)

    Returns:
        Manifest dictionary ready for JSON serialization

    Example:
        manifest = manifest_from_regen3d(
            Path("/mnt/gcs/scenes/scene_123/regen3d"),
            scene_id="scene_123",
            environment_type="kitchen"
        )
        Path("scene_manifest.json").write_text(json.dumps(manifest, indent=2))
    """
    adapter = Regen3DAdapter()
    regen3d_output = adapter.load_regen3d_output(regen3d_dir)
    return adapter.create_manifest(regen3d_output, scene_id, environment_type)


def layout_from_regen3d(
    regen3d_dir: Path,
    scale_factor: float = 1.0,
) -> Dict[str, Any]:
    """Create scene_layout_scaled.json from 3D-RE-GEN output directory.

    This layout is required by usd-assembly-job for scene construction.

    Args:
        regen3d_dir: Path to 3D-RE-GEN output directory
        scale_factor: Optional scale factor to apply (for metric calibration)

    Returns:
        Layout dictionary ready for JSON serialization

    Example:
        layout = layout_from_regen3d(
            Path("/mnt/gcs/scenes/scene_123/regen3d"),
            scale_factor=1.0
        )
        Path("scene_layout_scaled.json").write_text(json.dumps(layout, indent=2))
    """
    adapter = Regen3DAdapter()
    regen3d_output = adapter.load_regen3d_output(regen3d_dir)
    return adapter.create_layout(regen3d_output, scale_factor)
