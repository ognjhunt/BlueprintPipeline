#!/usr/bin/env python3
"""
UltraShape-1.0 Integration for BlueprintPipeline

UltraShape is a two-stage diffusion framework for high-quality 3D geometry generation:
- Stage 1: Uses Hunyuan3D-2.1 to generate a coarse mesh
- Stage 2: UltraShape refines the mesh for higher geometric precision

Reference: https://github.com/PKU-YuanGroup/UltraShape-1.0
Paper: arXiv:2512.21185

This module provides a clean interface for using UltraShape to refine
3D meshes generated by Hunyuan3D or other coarse mesh generators.

Usage:
    from ultrashape.ultrashape_refiner import UltraShapeRefiner

    refiner = UltraShapeRefiner(checkpoint_path="path/to/ultrashape_v1.pt")
    refined_mesh_path = refiner.refine(
        image_path="input.png",
        coarse_mesh_path="coarse.glb",
        output_path="refined.glb"
    )
"""

import os
import sys
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Optional, Tuple, Dict, Any
from dataclasses import dataclass
import logging

from tools.config.seed_manager import set_global_seed

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ultrashape")


@dataclass
class UltraShapeConfig:
    """Configuration for UltraShape refinement."""

    # Model paths
    checkpoint_path: str = "/app/ultrashape/checkpoints/ultrashape_v1.pt"
    config_path: str = "/app/ultrashape/configs/infer_dit_refine.yaml"

    # Inference parameters
    diffusion_steps: int = 50
    mesh_scale: float = 1.0
    octree_resolution: int = 256
    seed: int = 42

    # Processing
    use_bf16: bool = True
    remove_background: bool = True

    @classmethod
    def from_env(cls) -> "UltraShapeConfig":
        """Load configuration from environment variables."""
        return cls(
            checkpoint_path=os.getenv(
                "ULTRASHAPE_CHECKPOINT", "/app/ultrashape/checkpoints/ultrashape_v1.pt"
            ),
            config_path=os.getenv(
                "ULTRASHAPE_CONFIG", "/app/ultrashape/configs/infer_dit_refine.yaml"
            ),
            diffusion_steps=int(os.getenv("ULTRASHAPE_DIFFUSION_STEPS", "50")),
            mesh_scale=float(os.getenv("ULTRASHAPE_MESH_SCALE", "1.0")),
            octree_resolution=int(os.getenv("ULTRASHAPE_OCTREE_RESOLUTION", "256")),
            seed=int(os.getenv("ULTRASHAPE_SEED", "42")),
            use_bf16=os.getenv("ULTRASHAPE_USE_BF16", "1").lower() in ("1", "true"),
            remove_background=os.getenv("ULTRASHAPE_REMOVE_BG", "1").lower()
            in ("1", "true"),
        )


class UltraShapeRefiner:
    """
    UltraShape mesh refinement pipeline.

    This class provides a high-level interface for refining 3D meshes
    using the UltraShape diffusion model.
    """

    def __init__(
        self,
        config: Optional[UltraShapeConfig] = None,
        ultrashape_repo_path: Optional[str] = None,
    ):
        """
        Initialize the UltraShape refiner.

        Args:
            config: UltraShape configuration. If None, loads from environment.
            ultrashape_repo_path: Path to UltraShape repository. If None, uses default.
        """
        self.config = config or UltraShapeConfig.from_env()
        self.repo_path = Path(
            ultrashape_repo_path or os.getenv("ULTRASHAPE_REPO_PATH", "/app/UltraShape-1.0")
        )

        self._pipeline = None
        self._vae = None
        self._conditioner = None

        # Validate paths
        if not self.repo_path.is_dir():
            logger.warning(f"UltraShape repository not found at {self.repo_path}")

    def _ensure_loaded(self) -> bool:
        """Ensure the UltraShape model is loaded."""
        if self._pipeline is not None:
            return True

        try:
            # Add UltraShape to path
            sys.path.insert(0, str(self.repo_path))

            # Import UltraShape components
            from ultrashape.pipelines import UltraShapePipeline
            from ultrashape.utils.config import get_config_from_file

            # Load configuration
            config = get_config_from_file(self.config.config_path)

            # Load pipeline
            self._pipeline = UltraShapePipeline.from_pretrained(
                config=config,
                checkpoint=self.config.checkpoint_path,
            )

            logger.info("UltraShape model loaded successfully")
            return True

        except ImportError as e:
            logger.error(f"Failed to import UltraShape: {e}")
            return False
        except Exception as e:
            logger.error(f"Failed to load UltraShape model: {e}")
            return False

    def refine(
        self,
        image_path: Path,
        coarse_mesh_path: Path,
        output_path: Path,
        diffusion_steps: Optional[int] = None,
        seed: Optional[int] = None,
    ) -> Tuple[bool, Optional[Path], Optional[str]]:
        """
        Refine a coarse mesh using UltraShape.

        Args:
            image_path: Path to the reference image.
            coarse_mesh_path: Path to the coarse mesh (GLB/OBJ).
            output_path: Path for the refined mesh output.
            diffusion_steps: Override diffusion steps from config.
            seed: Override seed from config.

        Returns:
            Tuple of (success, output_path, error_message)
        """
        image_path = Path(image_path)
        coarse_mesh_path = Path(coarse_mesh_path)
        output_path = Path(output_path)

        # Validate inputs
        if not image_path.is_file():
            return False, None, f"Image not found: {image_path}"
        if not coarse_mesh_path.is_file():
            return False, None, f"Coarse mesh not found: {coarse_mesh_path}"

        # Create output directory
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Try direct Python API first
        if self._ensure_loaded():
            return self._refine_python_api(
                image_path=image_path,
                coarse_mesh_path=coarse_mesh_path,
                output_path=output_path,
                diffusion_steps=diffusion_steps or self.config.diffusion_steps,
                seed=seed or self.config.seed,
            )

        # Fallback to subprocess call
        return self._refine_subprocess(
            image_path=image_path,
            coarse_mesh_path=coarse_mesh_path,
            output_path=output_path,
            diffusion_steps=diffusion_steps or self.config.diffusion_steps,
            seed=seed or self.config.seed,
        )

    def _refine_python_api(
        self,
        image_path: Path,
        coarse_mesh_path: Path,
        output_path: Path,
        diffusion_steps: int,
        seed: int,
    ) -> Tuple[bool, Optional[Path], Optional[str]]:
        """Refine using the Python API directly."""
        try:
            import torch
            from PIL import Image
            import numpy as np

            logger.info(f"Refining mesh with UltraShape (Python API)")
            logger.info(f"  Image: {image_path}")
            logger.info(f"  Coarse mesh: {coarse_mesh_path}")
            logger.info(f"  Steps: {diffusion_steps}")

            # Load image
            image = Image.open(image_path)
            if image.mode != "RGB":
                image = image.convert("RGB")

            # Remove background if configured
            if self.config.remove_background:
                try:
                    from rembg import remove

                    image = remove(image)
                    if image.mode != "RGBA":
                        image = image.convert("RGBA")
                except ImportError:
                    logger.warning("rembg not available, skipping background removal")

            # Load coarse mesh
            import trimesh

            coarse_mesh = trimesh.load(str(coarse_mesh_path))

            # Set seed
            set_global_seed(seed)

            # Run refinement
            with torch.autocast("cuda", dtype=torch.bfloat16 if self.config.use_bf16 else torch.float32):
                refined_mesh = self._pipeline(
                    image=image,
                    mesh=coarse_mesh,
                    num_inference_steps=diffusion_steps,
                    octree_resolution=self.config.octree_resolution,
                    mesh_scale=self.config.mesh_scale,
                )

            # Export refined mesh
            if hasattr(refined_mesh, "export"):
                refined_mesh.export(str(output_path))
            elif isinstance(refined_mesh, tuple):
                # Some pipelines return (vertices, faces)
                vertices, faces = refined_mesh[:2]
                mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
                mesh.export(str(output_path))
            else:
                return False, None, f"Unexpected output type: {type(refined_mesh)}"

            logger.info(f"Refined mesh saved to: {output_path}")
            return True, output_path, None

        except Exception as e:
            logger.error(f"UltraShape refinement failed: {e}")
            return False, None, str(e)

    def _refine_subprocess(
        self,
        image_path: Path,
        coarse_mesh_path: Path,
        output_path: Path,
        diffusion_steps: int,
        seed: int,
    ) -> Tuple[bool, Optional[Path], Optional[str]]:
        """Refine using subprocess call to inference script."""
        try:
            logger.info(f"Refining mesh with UltraShape (subprocess)")

            # Build command
            script_path = self.repo_path / "scripts" / "infer_dit_refine.py"
            if not script_path.is_file():
                return False, None, f"Inference script not found: {script_path}"

            # Create temporary output directory
            with tempfile.TemporaryDirectory() as tmpdir:
                tmp_output = Path(tmpdir) / "output"
                tmp_output.mkdir()

                cmd = [
                    sys.executable,
                    str(script_path),
                    "--ckpt", str(self.config.checkpoint_path),
                    "--config", str(self.config.config_path),
                    "--image", str(image_path),
                    "--mesh", str(coarse_mesh_path),
                    "--output_dir", str(tmp_output),
                    "--steps", str(diffusion_steps),
                    "--seed", str(seed),
                    "--mesh_scale", str(self.config.mesh_scale),
                    "--octree_resolution", str(self.config.octree_resolution),
                ]

                logger.info(f"Running: {' '.join(cmd)}")

                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    cwd=str(self.repo_path),
                    env={
                        **os.environ,
                        "PYTHONPATH": str(self.repo_path),
                    },
                )

                if result.returncode != 0:
                    logger.error(f"UltraShape failed: {result.stderr}")
                    return False, None, f"UltraShape failed: {result.stderr[:500]}"

                # Find output mesh
                output_candidates = list(tmp_output.glob("*.glb")) + list(tmp_output.glob("*.obj"))
                if not output_candidates:
                    return False, None, "No output mesh generated"

                # Copy to final destination
                shutil.copy(output_candidates[0], output_path)

            logger.info(f"Refined mesh saved to: {output_path}")
            return True, output_path, None

        except Exception as e:
            logger.error(f"UltraShape subprocess failed: {e}")
            return False, None, str(e)

    def is_available(self) -> bool:
        """Check if UltraShape is available and configured."""
        # Check checkpoint
        if not Path(self.config.checkpoint_path).is_file():
            logger.warning(f"UltraShape checkpoint not found: {self.config.checkpoint_path}")
            return False

        # Check config
        if not Path(self.config.config_path).is_file():
            logger.warning(f"UltraShape config not found: {self.config.config_path}")
            return False

        # Check repo
        if not self.repo_path.is_dir():
            logger.warning(f"UltraShape repo not found: {self.repo_path}")
            return False

        return True


def download_ultrashape_weights(
    output_dir: Path,
    model_name: str = "infinith/UltraShape",
) -> Path:
    """
    Download UltraShape weights from HuggingFace.

    Args:
        output_dir: Directory to save weights.
        model_name: HuggingFace model name.

    Returns:
        Path to the downloaded checkpoint.
    """
    try:
        from huggingface_hub import snapshot_download

        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        logger.info(f"Downloading UltraShape weights from {model_name}")

        snapshot_dir = snapshot_download(
            repo_id=model_name,
            local_dir=output_dir,
            allow_patterns=["*.pt", "*.yaml", "*.json"],
        )

        # Find checkpoint
        checkpoint_path = output_dir / "ultrashape_v1.pt"
        if checkpoint_path.is_file():
            return checkpoint_path

        # Search for checkpoint
        for path in output_dir.rglob("*.pt"):
            return path

        raise FileNotFoundError("No checkpoint found in downloaded weights")

    except Exception as e:
        logger.error(f"Failed to download UltraShape weights: {e}")
        raise


def clone_ultrashape_repo(
    output_dir: Path,
    branch: str = "main",
) -> Path:
    """
    Clone the UltraShape repository.

    Args:
        output_dir: Directory to clone into.
        branch: Git branch to clone.

    Returns:
        Path to the cloned repository.
    """
    output_dir = Path(output_dir)

    if output_dir.is_dir() and (output_dir / ".git").is_dir():
        logger.info(f"UltraShape repo already exists at {output_dir}")
        return output_dir

    logger.info(f"Cloning UltraShape repository to {output_dir}")

    result = subprocess.run(
        [
            "git", "clone",
            "--depth", "1",
            "--branch", branch,
            "https://github.com/PKU-YuanGroup/UltraShape-1.0.git",
            str(output_dir),
        ],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        raise RuntimeError(f"Failed to clone UltraShape: {result.stderr}")

    return output_dir


# ============================================================================
# CLI Interface
# ============================================================================

def main():
    """Command-line interface for UltraShape refinement."""
    import argparse

    parser = argparse.ArgumentParser(description="UltraShape mesh refinement")
    parser.add_argument("--image", required=True, help="Path to reference image")
    parser.add_argument("--mesh", required=True, help="Path to coarse mesh (GLB/OBJ)")
    parser.add_argument("--output", required=True, help="Output path for refined mesh")
    parser.add_argument("--checkpoint", help="Path to UltraShape checkpoint")
    parser.add_argument("--config", help="Path to UltraShape config YAML")
    parser.add_argument("--steps", type=int, default=50, help="Diffusion steps")
    parser.add_argument("--seed", type=int, default=42, help="Random seed")
    parser.add_argument("--check-only", action="store_true", help="Only check availability")

    args = parser.parse_args()

    # Build config
    config = UltraShapeConfig.from_env()
    if args.checkpoint:
        config.checkpoint_path = args.checkpoint
    if args.config:
        config.config_path = args.config

    refiner = UltraShapeRefiner(config=config)

    if args.check_only:
        if refiner.is_available():
            print("UltraShape is available and configured")
            sys.exit(0)
        else:
            print("UltraShape is NOT available")
            sys.exit(1)

    success, output_path, error = refiner.refine(
        image_path=Path(args.image),
        coarse_mesh_path=Path(args.mesh),
        output_path=Path(args.output),
        diffusion_steps=args.steps,
        seed=args.seed,
    )

    if success:
        print(f"Successfully refined mesh: {output_path}")
        sys.exit(0)
    else:
        print(f"Refinement failed: {error}")
        sys.exit(1)


if __name__ == "__main__":
    main()
