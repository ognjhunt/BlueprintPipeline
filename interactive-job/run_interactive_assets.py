import base64
import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional
import urllib.request


def load_scene_assets(path: Path) -> dict:
    if not path.is_file():
        raise FileNotFoundError(f"scene_assets.json not found at {path}")
    with path.open("r") as f:
        return json.load(f)


def ensure_dir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def call_physx_anything(endpoint: str, crop_path: Path) -> Optional[dict]:
    """
    Minimal stub for posting the crop to a PhysX-Anything-style endpoint.
    The response contract is deliberately loose; if the call fails we simply return None.
    """
    try:
        with crop_path.open("rb") as f:
            payload = base64.b64encode(f.read()).decode("utf-8")
        body = json.dumps({"image_base64": payload}).encode("utf-8")
        req = urllib.request.Request(endpoint, data=body, headers={"Content-Type": "application/json"})
        with urllib.request.urlopen(req, timeout=30) as resp:  # nosec B310
            text = resp.read().decode("utf-8")
            return json.loads(text)
    except Exception as e:  # noqa: BLE001
        print(f"[PHYSX] WARNING: failed to query endpoint {endpoint}: {e}", file=sys.stderr)
        return None


def write_placeholder_glb(out_path: Path) -> None:
    """
    Writes a tiny placeholder GLB payload so downstream steps have a concrete artifact.
    This is intentionally minimal; real geometry should come from PhysX-Anything or Isaac Sim.
    """
    ensure_dir(out_path.parent)
    placeholder = b"Placeholder GLB generated by run_interactive_assets.py"
    with out_path.open("wb") as f:
        f.write(placeholder)


def write_minimal_urdf(urdf_path: Path, mesh_path: Path, obj_id: int, joints: List[Dict]) -> None:
    ensure_dir(urdf_path.parent)
    urdf = f"""
<robot name="obj_{obj_id}">
  <link name="base">
    <visual>
      <geometry>
        <mesh filename="{mesh_path.name}" />
      </geometry>
    </visual>
  </link>
{chr(10).join(joints)}
</robot>
"""
    urdf_path.write_text(urdf.strip() + "\n", encoding="utf-8")


def build_revolute_joint_xml(name: str, parent: str, child: str, axis=(0, 1, 0), limits=(-1.57, 1.57)) -> str:
    axis_str = " ".join(map(str, axis))
    lower, upper = limits
    return (
        f"  <joint name=\"{name}\" type=\"revolute\">\n"
        f"    <parent link=\"{parent}\"/>\n"
        f"    <child link=\"{child}\"/>\n"
        f"    <axis xyz=\"{axis_str}\"/>\n"
        f"    <limit lower=\"{lower}\" upper=\"{upper}\"/>\n"
        f"  </joint>"
    )


def process_interactive_object(obj: dict, multiview_root: Path, assets_root: Path, endpoint: Optional[str]) -> dict:
    obj_id = obj.get("id")
    crop_rel = obj.get("crop_path")
    crop_path = multiview_root / f"obj_{obj_id}" / "crop.png"
    if crop_rel:
        crop_path = Path("/mnt/gcs") / crop_rel

    output_dir = assets_root / "interactive" / f"obj_{obj_id}"
    ensure_dir(output_dir)

    result = {
        "id": obj_id,
        "status": "placeholder",
        "crop_path": str(crop_path),
        "output_dir": str(output_dir),
        "urdf_path": None,
        "mesh_path": None,
        "endpoint": endpoint,
        "service_response": None,
    }

    if not crop_path.is_file():
        print(f"[PHYSX] WARNING: missing crop for obj_{obj_id} at {crop_path}", file=sys.stderr)
        return result

    response = None
    if endpoint:
        response = call_physx_anything(endpoint, crop_path)
        result["service_response"] = response

    mesh_path = output_dir / "part.glb"
    write_placeholder_glb(mesh_path)

    joint_snippets = [
        build_revolute_joint_xml(
            name=f"joint_{obj_id}_0",
            parent="base",
            child="base",
            axis=(0, 1, 0),
            limits=(-1.0, 1.0),
        )
    ]
    urdf_path = output_dir / f"obj_{obj_id}.urdf"
    write_minimal_urdf(urdf_path, mesh_path, obj_id=obj_id, joints=joint_snippets)

    manifest = {
        "object_id": obj_id,
        "endpoint": endpoint,
        "service_response": response,
        "urdf_path": urdf_path.name,
        "mesh_path": mesh_path.name,
        "joint_model": "revolute_placeholder",
    }
    manifest_path = output_dir / "interactive_manifest.json"
    manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    result.update(
        {
            "status": "ok",
            "urdf_path": str(urdf_path),
            "mesh_path": str(mesh_path),
            "manifest": str(manifest_path),
        }
    )
    print(f"[PHYSX] Wrote interactive bundle for obj_{obj_id} -> {output_dir}")
    return result


def main() -> None:
    bucket = os.getenv("BUCKET", "")
    scene_id = os.getenv("SCENE_ID", "")
    multiview_prefix = os.getenv("MULTIVIEW_PREFIX")
    assets_prefix = os.getenv("ASSETS_PREFIX")
    layout_prefix = os.getenv("LAYOUT_PREFIX")
    endpoint = os.getenv("PHYSX_ENDPOINT")

    if not multiview_prefix or not assets_prefix:
        print("[PHYSX] MULTIVIEW_PREFIX and ASSETS_PREFIX are required", file=sys.stderr)
        sys.exit(1)

    root = Path("/mnt/gcs")
    multiview_root = root / multiview_prefix
    assets_root = root / assets_prefix
    layout_root = root / layout_prefix if layout_prefix else None

    assets_manifest = assets_root / "scene_assets.json"
    if not assets_manifest.is_file():
        print(f"[PHYSX] ERROR: scene_assets.json not found at {assets_manifest}", file=sys.stderr)
        sys.exit(1)

    scene_assets = load_scene_assets(assets_manifest)
    objects = scene_assets.get("objects", [])
    interactive = [o for o in objects if o.get("type") == "interactive"]

    print(f"[PHYSX] Bucket={bucket} Scene={scene_id}")
    print(f"[PHYSX] multiview_root={multiview_root}")
    print(f"[PHYSX] assets_root={assets_root}")
    if layout_root:
        print(f"[PHYSX] layout_root={layout_root}")
    print(f"[PHYSX] endpoint={endpoint}")
    print(f"[PHYSX] interactive count={len(interactive)}")

    results = []
    for obj in interactive:
        results.append(process_interactive_object(obj, multiview_root, assets_root, endpoint))

    summary = {
        "scene_id": scene_id,
        "interactive_processed": results,
    }
    out_path = assets_root / "interactive" / "interactive_results.json"
    ensure_dir(out_path.parent)
    out_path.write_text(json.dumps(summary, indent=2), encoding="utf-8")
    print(f"[PHYSX] Wrote summary to {out_path}")


if __name__ == "__main__":
    main()
