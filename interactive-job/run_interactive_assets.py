import base64
import json
import os
import sys
import tempfile
import urllib.request
import zipfile
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Dict, List, Optional, Tuple


def load_scene_assets(path: Path) -> dict:
    if not path.is_file():
        raise FileNotFoundError(f"scene_assets.json not found at {path}")
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def ensure_dir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def call_physx_anything(endpoint: str, crop_path: Path) -> Optional[dict]:
    """
    Post the crop image to the PhysX-Anything service.

    Request:
        POST endpoint
        Content-Type: application/json
        Body: {"image_base64": "<base64-encoded image bytes>"}

    Response (expected, but flexible):
        {
          "mesh_url": "...",
          "urdf_url": "...",
          "asset_zip_url": "...",
          "mesh_base64": "...",
          "urdf_base64": "...",
          ...
        }
    """
    try:
        with crop_path.open("rb") as f:
            payload = base64.b64encode(f.read()).decode("utf-8")
        body = json.dumps({"image_base64": payload}).encode("utf-8")
        req = urllib.request.Request(
            endpoint,
            data=body,
            headers={"Content-Type": "application/json"},
        )
        print(f"[PHYSX] POST {endpoint} with crop {crop_path}")
        with urllib.request.urlopen(req, timeout=60) as resp:  # nosec B310
            text = resp.read().decode("utf-8", errors="replace")
            try:
                data = json.loads(text)
            except json.JSONDecodeError:
                print(f"[PHYSX] WARNING: non-JSON response from endpoint: {text[:200]}...", file=sys.stderr)
                return None
            return data
    except Exception as e:  # noqa: BLE001
        print(f"[PHYSX] WARNING: failed to query endpoint {endpoint}: {e}", file=sys.stderr)
        return None


def download_file(url: str, out_path: Path) -> bool:
    ensure_dir(out_path.parent)
    print(f"[PHYSX] Downloading {url} -> {out_path}")
    try:
        urllib.request.urlretrieve(url, out_path)  # nosec B310
        return True
    except Exception as e:  # noqa: BLE001
        print(f"[PHYSX] WARNING: failed to download {url}: {e}", file=sys.stderr)
        if out_path.is_file():
            try:
                out_path.unlink()
            except OSError:
                pass
        return False


def write_placeholder_assets(out_dir: Path, obj_id: int) -> Tuple[Path, Path]:
    """
    Writes placeholder URDF/mesh when the PhysX-Anything service cannot be contacted
    or does not return valid assets.
    Placeholders are explicitly marked in the manifest so downstream steps can filter
    them out.
    """
    ensure_dir(out_dir)

    mesh_path = out_dir / "part.glb"
    placeholder = b"Placeholder GLB generated by run_interactive_assets.py"
    mesh_path.write_bytes(placeholder)

    urdf_path = out_dir / f"obj_{obj_id}.urdf"
    urdf = f"""
<robot name="obj_{obj_id}">
  <link name="base">
    <visual>
      <geometry>
        <mesh filename="{mesh_path.name}" />
      </geometry>
    </visual>
  </link>
  <joint name="placeholder_joint" type="fixed">
    <parent link="base"/>
    <child link="base"/>
  </joint>
</robot>
"""
    urdf_path.write_text(urdf.strip() + "\n", encoding="utf-8")
    return mesh_path, urdf_path


def parse_urdf_summary(urdf_path: Path) -> Dict:
    """Extracts a lightweight joint/link summary for bookkeeping."""
    import xml.etree.ElementTree as ET

    summary: Dict[str, List[Dict]] = {"joints": [], "links": []}
    if not urdf_path.is_file():
        return summary

    try:
        tree = ET.parse(urdf_path)
        root = tree.getroot()
    except Exception as e:  # noqa: BLE001
        print(f"[PHYSX] WARNING: failed to parse URDF {urdf_path}: {e}", file=sys.stderr)
        return summary

    for link in root.findall("link"):
        inertial = link.find("inertial")
        mass_tag = inertial.find("mass") if inertial is not None else None
        mass_val = None
        if mass_tag is not None:
            value = mass_tag.attrib.get("value")
            if value:
                try:
                    mass_val = float(value)
                except ValueError:
                    mass_val = None
        summary["links"].append(
            {
                "name": link.attrib.get("name"),
                "mass": mass_val,
            }
        )

    for joint in root.findall("joint"):
        axis_tag = joint.find("axis")
        limit_tag = joint.find("limit")
        axis = axis_tag.attrib.get("xyz") if axis_tag is not None else None
        lower = upper = None
        if limit_tag is not None:
            low_str = limit_tag.attrib.get("lower")
            up_str = limit_tag.attrib.get("upper")
            try:
                lower = float(low_str) if low_str else None
            except ValueError:
                lower = None
            try:
                upper = float(up_str) if up_str else None
            except ValueError:
                upper = None

        parent_link = None
        child_link = None
        parent_elem = joint.find("parent")
        child_elem = joint.find("child")
        if parent_elem is not None:
            parent_link = parent_elem.attrib.get("link")
        if child_elem is not None:
            child_link = child_elem.attrib.get("link")

        summary["joints"].append(
            {
                "name": joint.attrib.get("name"),
                "type": joint.attrib.get("type"),
                "parent": parent_link,
                "child": child_link,
                "axis": axis,
                "lower": lower,
                "upper": upper,
            }
        )

    return summary


def decode_base64_to_file(data_b64: str, out_path: Path) -> None:
    ensure_dir(out_path.parent)
    out_path.write_bytes(base64.b64decode(data_b64))


def materialize_service_assets(
    response: Dict,
    output_dir: Path,
    obj_id: int,
) -> Tuple[Optional[Path], Optional[Path], Dict]:
    """
    Attempts to download or decode PhysX-Anything outputs.
    Returns paths to (mesh, urdf) along with metadata that is suitable for the manifest.
    """
    mesh_path = output_dir / "part.glb"
    urdf_path = output_dir / f"obj_{obj_id}.urdf"
    ensure_dir(output_dir)

    meta: Dict[str, Optional[str]] = {
        "mesh_url": response.get("mesh_url"),
        "urdf_url": response.get("urdf_url"),
        "asset_zip_url": response.get("asset_zip_url"),
        "placeholder": False,
    }

    # 1) ZIP bundle path
    if response.get("asset_zip_url"):
        try:
            with tempfile.NamedTemporaryFile(suffix=".zip", delete=True) as tmp:
                ok = download_file(response["asset_zip_url"], Path(tmp.name))
                if ok:
                    with zipfile.ZipFile(tmp.name) as zf:
                        zf.extractall(output_dir)
                        # Best-effort: locate URDF/mesh within the archive
                        for name in zf.namelist():
                            lower = name.lower()
                            if lower.endswith(".urdf"):
                                urdf_path = output_dir / name
                            if lower.endswith((".glb", ".gltf")):
                                mesh_path = output_dir / name
            if urdf_path.is_file() and mesh_path.is_file():
                return mesh_path, urdf_path, meta
        except Exception as e:  # noqa: BLE001
            print(f"[PHYSX] WARNING: failed to handle asset_zip_url: {e}", file=sys.stderr)

    # 2) Direct URLs
    if response.get("mesh_url"):
        download_file(response["mesh_url"], mesh_path)
    if response.get("urdf_url"):
        download_file(response["urdf_url"], urdf_path)
    if urdf_path.is_file() and mesh_path.is_file():
        return mesh_path, urdf_path, meta

    # 3) Inline base64 payloads
    if response.get("mesh_base64"):
        decode_base64_to_file(response["mesh_base64"], mesh_path)
    if response.get("urdf_base64"):
        decode_base64_to_file(response["urdf_base64"], urdf_path)
    if urdf_path.is_file() and mesh_path.is_file():
        return mesh_path, urdf_path, meta

    meta["placeholder"] = True
    return None, None, meta


def process_interactive_object(
    obj: dict,
    multiview_root: Path,
    assets_root: Path,
    endpoint: Optional[str],
) -> dict:
    obj_id = obj.get("id")
    crop_rel = obj.get("crop_path")

    # If the assets plan already has a crop path (relative to /mnt/gcs), use that
    if crop_rel:
        crop_path = Path("/mnt/gcs") / crop_rel
    else:
        # Default crop location from multiview - check both crop.png and view_0.png
        obj_dir = multiview_root / f"obj_{obj_id}"
        crop_png = obj_dir / "crop.png"
        view_png = obj_dir / "view_0.png"

        if crop_png.is_file():
            crop_path = crop_png
        elif view_png.is_file():
            crop_path = view_png
        else:
            crop_path = crop_png  # Use default for error messaging

    output_dir = assets_root / "interactive" / f"obj_{obj_id}"
    ensure_dir(output_dir)

    result = {
        "id": obj_id,
        "status": "placeholder",
        "crop_path": str(crop_path),
        "output_dir": str(output_dir),
        "urdf_path": None,
        "mesh_path": None,
        "endpoint": endpoint,
        "service_response": None,
    }

    if not crop_path.is_file():
        print(f"[PHYSX] WARNING: missing crop for obj_{obj_id} at {crop_path}", file=sys.stderr)
        return result

    response: Optional[dict] = None
    if endpoint:
        response = call_physx_anything(endpoint, crop_path)
        result["service_response"] = response

    mesh_path: Optional[Path] = None
    urdf_path: Optional[Path] = None
    manifest: Dict = {}

    if response:
        mesh_path, urdf_path, download_meta = materialize_service_assets(response, output_dir, obj_id)
        manifest.update(download_meta)

    if mesh_path is None or urdf_path is None:
        print(f"[PHYSX] INFO: using placeholder assets for obj_{obj_id}", file=sys.stderr)
        mesh_path, urdf_path = write_placeholder_assets(output_dir, obj_id)
        manifest["placeholder"] = True

    manifest.update(
        {
            "object_id": obj_id,
            "endpoint": endpoint,
            "service_response": response,
            "urdf_path": urdf_path.name,
            "mesh_path": mesh_path.name,
        }
    )

    manifest["joint_summary"] = parse_urdf_summary(urdf_path)

    manifest_path = output_dir / "interactive_manifest.json"
    manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    result.update(
        {
            "status": "ok" if not manifest.get("placeholder") else "placeholder",
            "urdf_path": str(urdf_path),
            "mesh_path": str(mesh_path),
            "manifest": str(manifest_path),
        }
    )
    print(f"[PHYSX] Wrote interactive bundle for obj_{obj_id} -> {output_dir}")
    return result


def main() -> None:
    bucket = os.getenv("BUCKET", "")
    scene_id = os.getenv("SCENE_ID", "")
    multiview_prefix = os.getenv("MULTIVIEW_PREFIX")
    assets_prefix = os.getenv("ASSETS_PREFIX")
    layout_prefix = os.getenv("LAYOUT_PREFIX")
    endpoint = os.getenv("PHYSX_ENDPOINT")

    if not multiview_prefix or not assets_prefix:
        print("[PHYSX] MULTIVIEW_PREFIX and ASSETS_PREFIX are required", file=sys.stderr)
        sys.exit(1)

    root = Path("/mnt/gcs")
    multiview_root = root / multiview_prefix
    assets_root = root / assets_prefix
    layout_root = root / layout_prefix if layout_prefix else None

    assets_manifest = assets_root / "scene_assets.json"
    if not assets_manifest.is_file():
        print(f"[PHYSX] ERROR: scene_assets.json not found at {assets_manifest}", file=sys.stderr)
        sys.exit(1)

    scene_assets = load_scene_assets(assets_manifest)
    objects = scene_assets.get("objects", [])
    interactive = [o for o in objects if o.get("type") == "interactive"]

    if not endpoint and interactive:
        print("[PHYSX] ERROR: PHYSX_ENDPOINT is required for interactive assets", file=sys.stderr)
        sys.exit(1)

    print(f"[PHYSX] Bucket={bucket} Scene={scene_id}")
    print(f"[PHYSX] multiview_root={multiview_root}")
    print(f"[PHYSX] assets_root={assets_root}")
    if layout_root:
        print(f"[PHYSX] layout_root={layout_root}")
    print(f"[PHYSX] endpoint={endpoint}")
    print(f"[PHYSX] interactive count={len(interactive)}")

    # Process objects in parallel for faster execution
    results = []
    max_workers = min(len(interactive), 8) if interactive else 1

    if len(interactive) <= 1:
        # Sequential processing for single object
        for obj in interactive:
            results.append(process_interactive_object(obj, multiview_root, assets_root, endpoint))
    else:
        # Parallel processing for multiple objects
        print(f"[PHYSX] Processing {len(interactive)} objects with {max_workers} workers")
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {
                executor.submit(process_interactive_object, obj, multiview_root, assets_root, endpoint): obj
                for obj in interactive
            }
            for future in as_completed(futures):
                obj = futures[future]
                try:
                    result = future.result()
                    results.append(result)
                    print(f"[PHYSX] Completed obj_{obj.get('id')}")
                except Exception as e:
                    print(f"[PHYSX] ERROR processing obj_{obj.get('id')}: {e}", file=sys.stderr)
                    results.append({
                        "id": obj.get("id"),
                        "status": "error",
                        "error": str(e),
                    })

    summary = {
        "scene_id": scene_id,
        "interactive_processed": results,
    }
    out_path = assets_root / "interactive" / "interactive_results.json"
    ensure_dir(out_path.parent)
    out_path.write_text(json.dumps(summary, indent=2), encoding="utf-8")
    print(f"[PHYSX] Wrote summary to {out_path}")

    # Write completion marker for workflow coordination
    marker_path = assets_root / ".interactive_complete"
    marker_path.write_text(f"completed at {os.getenv('K_REVISION', 'unknown')}\n")
    print(f"[PHYSX] Wrote completion marker: {marker_path}")


if __name__ == "__main__":
    main()
