import base64
import json
import os
import sys
import tempfile
import urllib.request
import zipfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple


def load_scene_assets(path: Path) -> dict:
    if not path.is_file():
        raise FileNotFoundError(f"scene_assets.json not found at {path}")
    with path.open("r") as f:
        return json.load(f)


def ensure_dir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def call_physx_anything(endpoint: str, crop_path: Path) -> Optional[dict]:
    """
    Post the crop image to the PhysX-Anything service.

    The service is expected to return JSON containing URLs or base64 payloads for a URDF and mesh.
    To keep this client resilient, we support the following fields:
      * "mesh_url" / "urdf_url" - direct download URLs for the primary assets
      * "asset_zip_url" - archive containing the URDF/mesh
      * "mesh_base64" / "urdf_base64" - inline payloads (UTF-8 base64 encoded)
    Unknown fields are preserved in the response for debugging purposes.
    """
    try:
        with crop_path.open("rb") as f:
            payload = base64.b64encode(f.read()).decode("utf-8")
        body = json.dumps({"image_base64": payload}).encode("utf-8")
        req = urllib.request.Request(endpoint, data=body, headers={"Content-Type": "application/json"})
        with urllib.request.urlopen(req, timeout=60) as resp:  # nosec B310
            text = resp.read().decode("utf-8")
            return json.loads(text)
    except Exception as e:  # noqa: BLE001
        print(f"[PHYSX] WARNING: failed to query endpoint {endpoint}: {e}", file=sys.stderr)
        return None


def download_file(url: str, out_path: Path) -> None:
    ensure_dir(out_path.parent)
    print(f"[PHYSX] Downloading {url} -> {out_path}")
    urllib.request.urlretrieve(url, out_path)  # nosec B310


def write_placeholder_assets(out_dir: Path, obj_id: int) -> Tuple[Path, Path]:
    """
    Writes placeholder URDF/mesh when the PhysX-Anything service cannot be contacted.
    Placeholders are explicitly marked in the manifest so downstream steps can filter them out.
    """
    mesh_path = out_dir / "part.glb"
    ensure_dir(mesh_path.parent)
    placeholder = b"Placeholder GLB generated by run_interactive_assets.py"
    mesh_path.write_bytes(placeholder)

    urdf_path = out_dir / f"obj_{obj_id}.urdf"
    urdf = f"""
<robot name="obj_{obj_id}">
  <link name="base">
    <visual>
      <geometry>
        <mesh filename="{mesh_path.name}" />
      </geometry>
    </visual>
  </link>
  <joint name="placeholder_joint" type="fixed">
    <parent link="base"/>
    <child link="base"/>
  </joint>
</robot>
"""
    urdf_path.write_text(urdf.strip() + "\n", encoding="utf-8")
    return mesh_path, urdf_path


def parse_urdf_summary(urdf_path: Path) -> Dict:
    """Extracts a lightweight joint/link summary for bookkeeping."""
    import xml.etree.ElementTree as ET

    summary: Dict[str, List[Dict]] = {"joints": [], "links": []}
    if not urdf_path.is_file():
        return summary

    tree = ET.parse(urdf_path)
    root = tree.getroot()

    for link in root.findall("link"):
        inertial = link.find("inertial")
        mass_tag = inertial.find("mass") if inertial is not None else None
        summary["links"].append(
            {
                "name": link.attrib.get("name"),
                "mass": float(mass_tag.attrib.get("value")) if mass_tag is not None and mass_tag.attrib.get("value") else None,
            }
        )

    for joint in root.findall("joint"):
        axis_tag = joint.find("axis")
        limit_tag = joint.find("limit")
        summary["joints"].append(
            {
                "name": joint.attrib.get("name"),
                "type": joint.attrib.get("type"),
                "parent": (joint.find("parent") or {}).attrib.get("link") if joint.find("parent") is not None else None,
                "child": (joint.find("child") or {}).attrib.get("link") if joint.find("child") is not None else None,
                "axis": axis_tag.attrib.get("xyz") if axis_tag is not None else None,
                "lower": float(limit_tag.attrib.get("lower")) if limit_tag is not None and limit_tag.attrib.get("lower") else None,
                "upper": float(limit_tag.attrib.get("upper")) if limit_tag is not None and limit_tag.attrib.get("upper") else None,
            }
        )

    return summary


def decode_base64_to_file(data_b64: str, out_path: Path) -> None:
    ensure_dir(out_path.parent)
    out_path.write_bytes(base64.b64decode(data_b64))


def materialize_service_assets(response: Dict, output_dir: Path, obj_id: int) -> Tuple[Optional[Path], Optional[Path], Dict]:
    """
    Attempts to download or decode PhysX-Anything outputs.
    Returns paths to (mesh, urdf) along with metadata that is suitable for the manifest.
    """
    mesh_path = output_dir / "part.glb"
    urdf_path = output_dir / f"obj_{obj_id}.urdf"
    ensure_dir(output_dir)

    meta: Dict[str, Optional[str]] = {
        "mesh_url": response.get("mesh_url"),
        "urdf_url": response.get("urdf_url"),
        "asset_zip_url": response.get("asset_zip_url"),
        "placeholder": False,
    }

    # 1) ZIP bundle path
    if response.get("asset_zip_url"):
        with tempfile.NamedTemporaryFile(suffix=".zip", delete=True) as tmp:
            download_file(response["asset_zip_url"], Path(tmp.name))
            with zipfile.ZipFile(tmp.name) as zf:
                zf.extractall(output_dir)
                # Best-effort: locate URDF/mesh within the archive
                for name in zf.namelist():
                    lower = name.lower()
                    if lower.endswith(".urdf"):
                        urdf_path = output_dir / name
                    if lower.endswith((".glb", ".gltf")):
                        mesh_path = output_dir / name
        if urdf_path.is_file() and mesh_path.is_file():
            return mesh_path, urdf_path, meta

    # 2) Direct URLs
    if response.get("mesh_url"):
        download_file(response["mesh_url"], mesh_path)
    if response.get("urdf_url"):
        download_file(response["urdf_url"], urdf_path)
    if urdf_path.is_file() and mesh_path.is_file():
        return mesh_path, urdf_path, meta

    # 3) Inline base64 payloads
    if response.get("mesh_base64"):
        decode_base64_to_file(response["mesh_base64"], mesh_path)
    if response.get("urdf_base64"):
        decode_base64_to_file(response["urdf_base64"], urdf_path)
    if urdf_path.is_file() and mesh_path.is_file():
        return mesh_path, urdf_path, meta

    meta["placeholder"] = True
    return None, None, meta


def process_interactive_object(obj: dict, multiview_root: Path, assets_root: Path, endpoint: Optional[str]) -> dict:
    obj_id = obj.get("id")
    crop_rel = obj.get("crop_path")
    crop_path = multiview_root / f"obj_{obj_id}" / "crop.png"
    if crop_rel:
        crop_path = Path("/mnt/gcs") / crop_rel

    output_dir = assets_root / "interactive" / f"obj_{obj_id}"
    ensure_dir(output_dir)

    result = {
        "id": obj_id,
        "status": "placeholder",
        "crop_path": str(crop_path),
        "output_dir": str(output_dir),
        "urdf_path": None,
        "mesh_path": None,
        "endpoint": endpoint,
        "service_response": None,
    }

    if not crop_path.is_file():
        print(f"[PHYSX] WARNING: missing crop for obj_{obj_id} at {crop_path}", file=sys.stderr)
        return result

    response: Optional[dict] = None
    if endpoint:
        response = call_physx_anything(endpoint, crop_path)
        result["service_response"] = response

    mesh_path: Optional[Path] = None
    urdf_path: Optional[Path] = None
    manifest: Dict = {}

    if response:
        mesh_path, urdf_path, download_meta = materialize_service_assets(response, output_dir, obj_id)
        manifest.update(download_meta)

    if mesh_path is None or urdf_path is None:
        mesh_path, urdf_path = write_placeholder_assets(output_dir, obj_id)
        manifest["placeholder"] = True

    manifest.update(
        {
            "object_id": obj_id,
            "endpoint": endpoint,
            "service_response": response,
            "urdf_path": urdf_path.name,
            "mesh_path": mesh_path.name,
        }
    )

    manifest["joint_summary"] = parse_urdf_summary(urdf_path)

    manifest_path = output_dir / "interactive_manifest.json"
    manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    result.update(
        {
            "status": "ok" if not manifest.get("placeholder") else "placeholder",
            "urdf_path": str(urdf_path),
            "mesh_path": str(mesh_path),
            "manifest": str(manifest_path),
        }
    )
    print(f"[PHYSX] Wrote interactive bundle for obj_{obj_id} -> {output_dir}")
    return result


def main() -> None:
    bucket = os.getenv("BUCKET", "")
    scene_id = os.getenv("SCENE_ID", "")
    multiview_prefix = os.getenv("MULTIVIEW_PREFIX")
    assets_prefix = os.getenv("ASSETS_PREFIX")
    layout_prefix = os.getenv("LAYOUT_PREFIX")
    endpoint = os.getenv("PHYSX_ENDPOINT")

    if not multiview_prefix or not assets_prefix:
        print("[PHYSX] MULTIVIEW_PREFIX and ASSETS_PREFIX are required", file=sys.stderr)
        sys.exit(1)

    root = Path("/mnt/gcs")
    multiview_root = root / multiview_prefix
    assets_root = root / assets_prefix
    layout_root = root / layout_prefix if layout_prefix else None

    assets_manifest = assets_root / "scene_assets.json"
    if not assets_manifest.is_file():
        print(f"[PHYSX] ERROR: scene_assets.json not found at {assets_manifest}", file=sys.stderr)
        sys.exit(1)

    scene_assets = load_scene_assets(assets_manifest)
    objects = scene_assets.get("objects", [])
    interactive = [o for o in objects if o.get("type") == "interactive"]

    if not endpoint and interactive:
        print("[PHYSX] ERROR: PHYSX_ENDPOINT is required for interactive assets", file=sys.stderr)
        sys.exit(1)

    print(f"[PHYSX] Bucket={bucket} Scene={scene_id}")
    print(f"[PHYSX] multiview_root={multiview_root}")
    print(f"[PHYSX] assets_root={assets_root}")
    if layout_root:
        print(f"[PHYSX] layout_root={layout_root}")
    print(f"[PHYSX] endpoint={endpoint}")
    print(f"[PHYSX] interactive count={len(interactive)}")

    results = []
    for obj in interactive:
        results.append(process_interactive_object(obj, multiview_root, assets_root, endpoint))

    summary = {
        "scene_id": scene_id,
        "interactive_processed": results,
    }
    out_path = assets_root / "interactive" / "interactive_results.json"
    ensure_dir(out_path.parent)
    out_path.write_text(json.dumps(summary, indent=2), encoding="utf-8")
    print(f"[PHYSX] Wrote summary to {out_path}")


if __name__ == "__main__":
    main()
