#!/usr/bin/env python3
"""
Variation Asset Generator for Replicator Domain Randomization.

This script reads the variation_assets/manifest.json generated by replicator-job
and creates reference images for assets that need to be generated (source_hint="generate").

Pipeline flow:
1. Read manifest.json from replicator/variation_assets/
2. For each asset with source_hint="generate":
   - Generate a reference image using Gemini 3.0 Pro Image (Nano Banana Pro)
   - Save to variation_assets/{asset_name}/reference.png
3. Create variation_assets.json for downstream processing
4. Write completion marker for downstream pipeline

The generated images are then processed by downstream jobs to create 3D models,
followed by simready-job to add physics properties.

NOTE: For a complete end-to-end solution, consider using variation-asset-pipeline-job
which combines image generation, 3D conversion, and physics assignment into one job.

Environment Variables:
    (None specific to model selection; always uses Gemini 3.0 Pro Image.)
"""

import datetime
import json
import logging
import os
import sys
import time
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum

from PIL import Image

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.append(str(REPO_ROOT))

from tools.validation.entrypoint_checks import validate_required_env_vars

try:
    from google import genai
    from google.genai import types
except ImportError:
    logging.getLogger(__name__).error(
        "[VARIATION-GEN] google-genai package not installed"
    )
    sys.exit(1)

logger = logging.getLogger(__name__)


# ============================================================================
# Constants
# ============================================================================

GCS_ROOT = Path("/mnt/gcs")

# Gemini model for image generation (Nano Banana Pro / Gemini 3.0 Pro Image Preview)
GEMINI_IMAGE_MODEL = "gemini-3-pro-image-preview"
GEMINI_IMAGE_MODEL_NAME = "Gemini 3.0 Pro Image (Nano Banana Pro)"

# Generation settings
DEFAULT_IMAGE_SIZE = 2048
DEFAULT_ASPECT_RATIO = "1:1"
MAX_RETRIES = 3
RETRY_DELAY_SECONDS = 5

# Asset categories that benefit from specific generation styles
CATEGORY_STYLE_HINTS = {
    "dishes": "ceramic dishware, photorealistic product photography",
    "utensils": "stainless steel cutlery, photorealistic product photography",
    "food": "realistic food item, photorealistic product photography",
    "groceries": "packaged consumer goods, photorealistic product photography",
    "produce": "fresh produce, photorealistic product photography",
    "bottles": "glass or plastic bottle, photorealistic product photography",
    "cans": "aluminum or tin can, photorealistic product photography",
    "boxes": "cardboard box or package, photorealistic product photography",
    "clothing": "fabric clothing item, photorealistic product photography",
    "towels": "textile towel or cloth, photorealistic product photography",
    "tools": "hand tool, photorealistic product photography",
    "containers": "storage container, photorealistic product photography",
    "electronics": "electronic device, photorealistic product photography",
    "office_supplies": "office supply item, photorealistic product photography",
    "lab_equipment": "laboratory equipment, photorealistic product photography",
}

# Semantic class to material hints
SEMANTIC_CLASS_MATERIALS = {
    "dish": "ceramic, porcelain, or stoneware material",
    "grocery": "plastic packaging, cardboard, or metal can",
    "clothing": "cotton, polyester, or fabric material",
    "tool": "metal and plastic materials",
    "container": "plastic, glass, or metal material",
}


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class VariationAssetSpec:
    """Specification for a variation asset to generate."""
    name: str
    category: str
    description: str
    semantic_class: str
    priority: str
    source_hint: Optional[str]
    example_variants: List[str]
    physics_hints: Dict[str, Any]

    # Enriched generation hints from replicator-job
    material_hint: Optional[str] = None
    style_hint: Optional[str] = None
    generation_prompt_hint: Optional[str] = None

    # Generation tracking
    generated: bool = False
    reference_image_path: Optional[str] = None
    error_message: Optional[str] = None


@dataclass
class GenerationResult:
    """Result of generating a single asset image."""
    asset_name: str
    success: bool
    image_path: Optional[str] = None
    error: Optional[str] = None
    generation_time_seconds: float = 0.0


# ============================================================================
# Gemini Client
# ============================================================================

def create_gemini_client():
    """Create Gemini client using API key from environment."""
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY environment variable is required")
    return genai.Client(api_key=api_key)


# ============================================================================
# Prompt Generation
# ============================================================================

def build_asset_generation_prompt(asset: VariationAssetSpec, policy_context: Optional[str] = None) -> str:
    """
    Build a prompt for Gemini 3.0 Pro Image to generate a reference image for an asset.

    The prompt is designed to produce:
    - High-quality product photography style
    - Transparent/neutral background suitable for 3D reconstruction
    - Consistent lighting and perspective
    - Realistic materials and textures

    If the asset has a generation_prompt_hint from replicator-job, it will be used
    as the base for the prompt. Otherwise, we build one from scratch.
    """
    # Use enriched hints from replicator-job if available
    if asset.generation_prompt_hint:
        base_description = asset.generation_prompt_hint
    else:
        base_description = f"a {asset.description}"

    # Get style hints - prefer asset-specific, fall back to category lookup
    style_hint = asset.style_hint or CATEGORY_STYLE_HINTS.get(
        asset.category.lower(),
        "photorealistic product photography"
    )

    # Get material hints - prefer asset-specific, fall back to semantic class lookup
    material_hint = asset.material_hint or SEMANTIC_CLASS_MATERIALS.get(
        asset.semantic_class.lower(),
        "appropriate realistic materials"
    )

    # Build variant examples text
    variants_text = ""
    if asset.example_variants:
        variants_text = f"\nVariant examples for reference: {', '.join(asset.example_variants[:3])}"

    # Build physics-aware description hints
    physics_text = ""
    if asset.physics_hints:
        mass_range = asset.physics_hints.get("mass_range_kg")
        if mass_range:
            physics_text = f"\nObject should appear to weigh approximately {mass_range[0]}-{mass_range[1]} kg."

    # Policy context for scene-appropriate generation
    context_text = ""
    if policy_context:
        context_text = f"\nThis object will be used in a {policy_context} training scenario."

    prompt = f"""Professional product photography of {base_description}.

Style: {style_hint}
Materials: {material_hint}

Requirements:
- Single isolated object, centered in frame
- Pure white or light gray studio background
- Soft, even studio lighting (3-point lighting)
- Front-facing view, slightly elevated angle (about 15-20 degrees from front)
- Object fills approximately 70-80% of frame
- Sharp focus, high detail
- No shadows on background (floating appearance)
- Photorealistic rendering quality
- 8K resolution detail level
{variants_text}
{physics_text}
{context_text}

The image should be suitable for 3D reconstruction and look like a professional product catalog photo."""

    return prompt


def build_batch_context_prompt(assets: List[VariationAssetSpec], scene_type: str) -> str:
    """Build context prompt for maintaining consistency across batch generation."""
    asset_list = "\n".join([f"- {a.name}: {a.description}" for a in assets[:10]])

    return f"""You are generating a consistent set of objects for a {scene_type} environment simulation.

Objects to generate:
{asset_list}

Maintain consistent:
- Lighting style (soft studio lighting)
- Camera perspective (front-facing, slightly elevated)
- Image quality (photorealistic, high detail)
- Background style (clean white/gray studio)
- Material realism (appropriate for each object type)
"""


# ============================================================================
# Image Generation
# ============================================================================

def generate_asset_image(
    client,
    asset: VariationAssetSpec,
    output_dir: Path,
    policy_context: Optional[str] = None,
    dry_run: bool = False,
) -> GenerationResult:
    """
    Generate a reference image for a single asset.

    Uses Gemini 3.0 Pro Image (Nano Banana Pro) with native image generation.

    Args:
        client: Gemini client instance
        asset: Asset specification
        output_dir: Directory to save the generated image
        policy_context: Optional context about the training policy
        dry_run: If True, skip actual generation (for testing)

    Returns:
        GenerationResult with success status and image path
    """
    import io
    import base64

    start_time = time.time()

    # Create asset output directory
    asset_dir = output_dir / asset.name
    asset_dir.mkdir(parents=True, exist_ok=True)

    image_path = asset_dir / "reference.png"

    if dry_run:
        logger.info("[VARIATION-GEN] [DRY-RUN] Would generate: %s", asset.name)
        return GenerationResult(
            asset_name=asset.name,
            success=True,
            image_path=str(image_path),
            generation_time_seconds=0.0
        )

    # Build prompt
    prompt = build_asset_generation_prompt(asset, policy_context)

    logger.info("[VARIATION-GEN] Generating image for: %s", asset.name)
    logger.info("[VARIATION-GEN]   Category: %s", asset.category)
    logger.info("[VARIATION-GEN]   Description: %s...", asset.description[:80])
    logger.info("[VARIATION-GEN]   Model: %s", GEMINI_IMAGE_MODEL_NAME)

    # Retry loop for robustness
    last_error = None
    for attempt in range(MAX_RETRIES):
        try:
            response = client.models.generate_content(
                model=GEMINI_IMAGE_MODEL,
                contents=prompt,
                config=types.GenerateContentConfig(
                    response_modalities=["IMAGE", "TEXT"],
                    temperature=0.8,
                ),
            )

            # Extract image from Gemini response
            if response.candidates and len(response.candidates) > 0:
                candidate = response.candidates[0]
                if candidate.content and candidate.content.parts:
                    for part in candidate.content.parts:
                        if hasattr(part, 'inline_data') and part.inline_data:
                            # Decode base64 image data
                            image_data = part.inline_data.data
                            if isinstance(image_data, str):
                                image_bytes = base64.b64decode(image_data)
                            else:
                                image_bytes = image_data

                            # Save image
                            img = Image.open(io.BytesIO(image_bytes))
                            img.save(str(image_path), format='PNG')

                            elapsed = time.time() - start_time
                            logger.info(
                                "[VARIATION-GEN] Generated: %s (%.1fs)",
                                asset.name,
                                elapsed,
                            )

                            return GenerationResult(
                                asset_name=asset.name,
                                success=True,
                                image_path=str(image_path),
                                generation_time_seconds=elapsed
                            )

            raise ValueError("No image data in Gemini response")

        except Exception as e:
            last_error = str(e)
            logger.warning(
                "[VARIATION-GEN] Attempt %s/%s failed for %s: %s",
                attempt + 1,
                MAX_RETRIES,
                asset.name,
                e,
            )

            if attempt < MAX_RETRIES - 1:
                time.sleep(RETRY_DELAY_SECONDS * (attempt + 1))  # Exponential backoff

    # All retries failed
    elapsed = time.time() - start_time
    return GenerationResult(
        asset_name=asset.name,
        success=False,
        error=last_error,
        generation_time_seconds=elapsed
    )


def generate_all_assets(
    client,
    assets: List[VariationAssetSpec],
    output_dir: Path,
    policy_context: Optional[str] = None,
    max_assets: Optional[int] = None,
    dry_run: bool = False,
) -> Tuple[List[GenerationResult], Dict[str, Any]]:
    """
    Generate reference images for all assets that need generation.

    Args:
        client: Gemini client instance
        assets: List of asset specifications
        output_dir: Base directory for output
        policy_context: Optional context about training policy
        max_assets: Optional limit on number of assets to generate
        dry_run: If True, skip actual generation

    Returns:
        Tuple of (list of results, summary statistics)
    """
    # Filter to only assets that need generation
    assets_to_generate = [
        a for a in assets
        if a.source_hint == "generate" or a.source_hint is None
    ]

    # Apply limit if specified
    if max_assets is not None:
        assets_to_generate = assets_to_generate[:max_assets]

    logger.info(
        "[VARIATION-GEN] Generating %s assets using %s...",
        len(assets_to_generate),
        GEMINI_IMAGE_MODEL_NAME,
    )

    results: List[GenerationResult] = []

    for i, asset in enumerate(assets_to_generate):
        logger.debug(
            "[VARIATION-GEN] Progress: %s/%s", i + 1, len(assets_to_generate)
        )

        result = generate_asset_image(
            client=client,
            asset=asset,
            output_dir=output_dir,
            policy_context=policy_context,
            dry_run=dry_run,
        )
        results.append(result)

        # Small delay between requests to avoid rate limiting
        if not dry_run and i < len(assets_to_generate) - 1:
            time.sleep(1.0)

    # Compute summary
    successful = sum(1 for r in results if r.success)
    failed = sum(1 for r in results if not r.success)
    total_time = sum(r.generation_time_seconds for r in results)

    summary = {
        "total_attempted": len(results),
        "successful": successful,
        "failed": failed,
        "total_generation_time_seconds": total_time,
        "average_time_per_asset_seconds": total_time / len(results) if results else 0,
        "image_model": GEMINI_IMAGE_MODEL_NAME
    }

    return results, summary


# ============================================================================
# Manifest Processing
# ============================================================================

def load_manifest(manifest_path: Path) -> Tuple[Dict[str, Any], List[VariationAssetSpec]]:
    """
    Load and parse the variation assets manifest.

    The manifest is generated by replicator-job and contains:
    - Asset specifications with descriptions and categories
    - Enriched generation hints (material_hint, style_hint, generation_prompt_hint)
    - Physics hints for simready-job
    - Scene context (scene_type, environment_type, policies)

    Returns:
        Tuple of (raw manifest dict, list of parsed asset specs)
    """
    if not manifest_path.is_file():
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")

    with manifest_path.open("r") as f:
        manifest = json.load(f)

    assets = []
    for asset_dict in manifest.get("assets", []):
        asset = VariationAssetSpec(
            name=asset_dict.get("name", "unknown"),
            category=asset_dict.get("category", "other"),
            description=asset_dict.get("description", ""),
            semantic_class=asset_dict.get("semantic_class", "object"),
            priority=asset_dict.get("priority", "optional"),
            source_hint=asset_dict.get("source_hint"),
            example_variants=asset_dict.get("example_variants", []),
            physics_hints=asset_dict.get("physics_hints", {}),
            # Enriched hints from replicator-job
            material_hint=asset_dict.get("material_hint"),
            style_hint=asset_dict.get("style_hint"),
            generation_prompt_hint=asset_dict.get("generation_prompt_hint")
        )
        assets.append(asset)

    logger.info("[VARIATION-GEN] Loaded manifest with %s assets", len(assets))
    logger.info(
        "[VARIATION-GEN] Scene type: %s", manifest.get("scene_type", "unknown")
    )
    logger.info(
        "[VARIATION-GEN] Environment: %s",
        manifest.get("environment_type", "unknown"),
    )

    return manifest, assets


def create_hunyuan_assets_json(
    results: List[GenerationResult],
    assets: List[VariationAssetSpec],
    output_dir: Path,
    scene_id: str
) -> Path:
    """
    Create a scene_assets.json-compatible file for downstream processing.

    This file follows the same format as the main scene_assets.json but
    contains only the variation assets.
    """
    # Build asset lookup
    asset_lookup = {a.name: a for a in assets}

    objects = []
    for result in results:
        if not result.success:
            continue

        asset = asset_lookup.get(result.asset_name)
        if asset is None:
            continue

        # Create object entry compatible with downstream 3D conversion
        obj = {
            "id": result.asset_name,
            "category": asset.category,
            "short_description": asset.description,
            "sim_role": "manipulable_object",
            "must_be_separate_asset": True,
            # Reference image path relative to GCS mount
            "preferred_view": result.image_path.replace(str(GCS_ROOT) + "/", "") if result.image_path else None,
            "multiview_dir": None,
            "crop_path": None,
            # Physics hints for simready-job
            "physics_hints": asset.physics_hints,
            "semantic_class": asset.semantic_class,
        }
        objects.append(obj)

    assets_json = {
        "scene_id": scene_id,
        "generated_at": datetime.datetime.utcnow().isoformat() + "Z",
        "source": "variation-gen-job",
        "objects": objects,
        "metadata": {
            "total_objects": len(objects),
            "generation_type": "variation_assets"
        }
    }

    output_path = output_dir / "variation_assets.json"
    with output_path.open("w") as f:
        json.dump(assets_json, f, indent=2)

    logger.info(
        "[VARIATION-GEN] Created downstream-compatible assets file: %s", output_path
    )
    return output_path


def update_manifest_with_results(
    manifest: Dict[str, Any],
    results: List[GenerationResult],
    output_path: Path
) -> None:
    """Update the manifest with generation results."""
    # Create lookup of results
    result_lookup = {r.asset_name: r for r in results}

    # Update each asset in manifest
    for asset in manifest.get("assets", []):
        name = asset.get("name")
        result = result_lookup.get(name)

        if result:
            asset["generation_status"] = "success" if result.success else "failed"
            if result.image_path:
                asset["reference_image_path"] = result.image_path
            if result.error:
                asset["generation_error"] = result.error

    # Add generation metadata
    manifest["generation_completed_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    manifest["generation_summary"] = {
        "total_attempted": len(results),
        "successful": sum(1 for r in results if r.success),
        "failed": sum(1 for r in results if not r.success)
    }

    # Save updated manifest
    with output_path.open("w") as f:
        json.dump(manifest, f, indent=2)

    logger.info("[VARIATION-GEN] Updated manifest: %s", output_path)


# ============================================================================
# Main Processing
# ============================================================================

def process_variation_assets(
    root: Path,
    scene_id: str,
    replicator_prefix: str,
    variation_assets_prefix: str,
    max_assets: Optional[int] = None,
    dry_run: bool = False,
    priority_filter: Optional[str] = None
) -> bool:
    """
    Main processing function for variation asset generation.

    Args:
        root: GCS root path
        scene_id: Scene identifier
        replicator_prefix: Path to replicator bundle (contains manifest)
        variation_assets_prefix: Path to output variation assets
        max_assets: Optional limit on number of assets
        dry_run: If True, skip actual generation
        priority_filter: Optional filter ("required", "recommended", "optional")

    Returns:
        True if successful, False otherwise
    """
    logger.info("[VARIATION-GEN] Processing variation assets for scene: %s", scene_id)

    # Load manifest
    manifest_path = root / replicator_prefix / "variation_assets" / "manifest.json"

    try:
        manifest, assets = load_manifest(manifest_path)
    except FileNotFoundError as e:
        logger.error("[VARIATION-GEN] %s", e)
        return False

    logger.info("[VARIATION-GEN] Loaded manifest with %s assets", len(assets))

    # Filter by priority if specified
    if priority_filter:
        assets = [a for a in assets if a.priority == priority_filter]
        logger.info(
            "[VARIATION-GEN] Filtered to %s %s assets", len(assets), priority_filter
        )

    # Filter to only assets that need generation
    assets_to_generate = [
        a for a in assets
        if a.source_hint == "generate" or a.source_hint is None
    ]

    logger.info(
        "[VARIATION-GEN] %s assets need generation", len(assets_to_generate)
    )

    if not assets_to_generate:
        logger.info("[VARIATION-GEN] No assets need generation; exiting.")
        # Still write completion marker
        output_dir = root / variation_assets_prefix
        output_dir.mkdir(parents=True, exist_ok=True)
        marker_path = output_dir / ".variation_pipeline_complete"
        marker_path.write_text(f"No assets to generate at {datetime.datetime.utcnow().isoformat()}Z\n")
        return True

    # Get scene context for generation
    scene_type = manifest.get("scene_type", "generic")
    policy_context = f"{scene_type} scene" if scene_type != "generic" else None

    # Create output directory
    output_dir = root / variation_assets_prefix
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create Gemini client
    if not dry_run:
        try:
            client = create_gemini_client()
        except ValueError as e:
            logger.error("[VARIATION-GEN] %s", e)
            return False
    else:
        client = None

    # Generate images
    results, summary = generate_all_assets(
        client=client,
        assets=assets_to_generate,
        output_dir=output_dir,
        policy_context=policy_context,
        max_assets=max_assets,
        dry_run=dry_run,
    )

    logger.info("[VARIATION-GEN] Generation complete:")
    logger.info("[VARIATION-GEN]   Successful: %s", summary["successful"])
    logger.info("[VARIATION-GEN]   Failed: %s", summary["failed"])
    logger.info(
        "[VARIATION-GEN]   Total time: %.1fs",
        summary["total_generation_time_seconds"],
    )

    # Create hunyuan-compatible assets file
    if summary['successful'] > 0:
        create_hunyuan_assets_json(
            results=results,
            assets=assets,
            output_dir=output_dir,
            scene_id=scene_id
        )

    # Update manifest with results
    updated_manifest_path = output_dir / "manifest_with_results.json"
    update_manifest_with_results(manifest, results, updated_manifest_path)

    # Write generation report
    report = {
        "scene_id": scene_id,
        "generated_at": datetime.datetime.utcnow().isoformat() + "Z",
        "summary": summary,
        "results": [asdict(r) for r in results],
        "config": {
            "image_model": GEMINI_IMAGE_MODEL,
            "max_assets": max_assets,
            "priority_filter": priority_filter,
            "dry_run": dry_run
        }
    }
    report_path = output_dir / "generation_report.json"
    with report_path.open("w") as f:
        json.dump(report, f, indent=2)

    # Write completion marker
    marker_path = output_dir / ".variation_pipeline_complete"
    marker_path.write_text(
        f"completed at {datetime.datetime.utcnow().isoformat()}Z\n"
        f"successful: {summary['successful']}\n"
        f"failed: {summary['failed']}\n"
    )
    logger.info("[VARIATION-GEN] Wrote completion marker: %s", marker_path)

    return summary['failed'] == 0 or summary['successful'] > 0


# ============================================================================
# Entry Point
# ============================================================================

def main():
    """Main entry point for the variation-gen job."""

    validate_required_env_vars(
        {
            "BUCKET": "GCS bucket name",
            "SCENE_ID": "Scene identifier",
            "GEMINI_API_KEY": "Gemini API key for image generation",
        },
        label="[VARIATION-GEN]",
    )

    # Get configuration from environment
    bucket = os.environ["BUCKET"]
    scene_id = os.environ["SCENE_ID"]
    replicator_prefix = os.getenv("REPLICATOR_PREFIX", f"scenes/{scene_id}/replicator")
    variation_assets_prefix = os.getenv("VARIATION_ASSETS_PREFIX", f"scenes/{scene_id}/variation_assets")

    # Optional configuration
    max_assets_str = os.getenv("MAX_ASSETS", "")
    max_assets = int(max_assets_str) if max_assets_str else None

    priority_filter = os.getenv("PRIORITY_FILTER", "")  # "required", "recommended", "optional"
    priority_filter = priority_filter if priority_filter else None

    dry_run = os.getenv("DRY_RUN", "").lower() in {"1", "true", "yes"}

    logger.info("[VARIATION-GEN] Starting variation asset generation")
    logger.info("[VARIATION-GEN] Scene ID: %s", scene_id)
    logger.info("[VARIATION-GEN] Bucket: %s", bucket)
    logger.info("[VARIATION-GEN] Replicator prefix: %s", replicator_prefix)
    logger.info("[VARIATION-GEN] Output prefix: %s", variation_assets_prefix)
    logger.info("[VARIATION-GEN] Image model: %s", GEMINI_IMAGE_MODEL_NAME)
    if max_assets:
        logger.info("[VARIATION-GEN] Max assets: %s", max_assets)
    if priority_filter:
        logger.info("[VARIATION-GEN] Priority filter: %s", priority_filter)
    if dry_run:
        logger.info("[VARIATION-GEN] DRY RUN MODE - no actual generation")

    try:
        success = process_variation_assets(
            root=GCS_ROOT,
            scene_id=scene_id,
            replicator_prefix=replicator_prefix,
            variation_assets_prefix=variation_assets_prefix,
            max_assets=max_assets,
            dry_run=dry_run,
            priority_filter=priority_filter,
        )

        if success:
            logger.info("[VARIATION-GEN] SUCCESS: Variation asset generation complete")
            sys.exit(0)
        else:
            logger.warning(
                "[VARIATION-GEN] PARTIAL SUCCESS: Some assets failed to generate"
            )
            sys.exit(0)  # Don't fail the job for partial success

    except Exception as e:
        logger.exception("[VARIATION-GEN] ERROR: %s", e)
        sys.exit(1)


if __name__ == "__main__":
    main()
