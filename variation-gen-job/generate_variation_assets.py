#!/usr/bin/env python3
"""
Variation Asset Generator for Replicator Domain Randomization.

This script reads the variation_assets/manifest.json generated by replicator-job
and creates reference images for assets that need to be generated (source_hint="generate").

Pipeline flow:
1. Read manifest.json from replicator/variation_assets/
2. For each asset with source_hint="generate":
   - Generate a reference image using Gemini 3.0 Pro Image (Nano Banana Pro)
   - Save to variation_assets/{asset_name}/reference.png
3. Create variation_assets.json for downstream processing
4. Write completion marker for downstream pipeline

The generated images are then processed by downstream jobs to create 3D models,
followed by simready-job to add physics properties.

NOTE: For a complete end-to-end solution, consider using variation-asset-pipeline-job
which combines image generation, 3D conversion, and physics assignment into one job.

Environment Variables:
    ENABLE_3D_GENERATION: Enable 3D generation after image generation.
    VARIATION_3D_BACKEND: Backend to use for 3D generation ("meshy" or "external").
    FAIL_ON_3D_FAILURE: When true, fail the job if any 3D generation fails.
    MESHY_API_KEY: API key for Meshy 3D generation (required when backend="meshy").
    EXTERNAL_3D_SERVICE_URL: External service endpoint for 3D generation.
    EXTERNAL_3D_SERVICE_TOKEN: Optional bearer token for external 3D service.
"""

import datetime
import base64
import json
import logging
import os
import sys
import time
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict

from PIL import Image, ImageDraw, ImageFont

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.append(str(REPO_ROOT))

from tools.validation.entrypoint_checks import validate_required_env_vars

try:
    from google import genai
    from google.genai import types
except ImportError:
    logging.getLogger(__name__).error(
        "[VARIATION-GEN] google-genai package not installed"
    )
    sys.exit(1)

logger = logging.getLogger(__name__)


# ============================================================================
# Constants
# ============================================================================

GCS_ROOT = Path("/mnt/gcs")

# Gemini model for image generation (Nano Banana Pro / Gemini 3.0 Pro Image Preview)
GEMINI_IMAGE_MODEL = "gemini-3-pro-image-preview"
GEMINI_IMAGE_MODEL_NAME = "Gemini 3.0 Pro Image (Nano Banana Pro)"

# Generation settings
DEFAULT_IMAGE_SIZE = 2048
DEFAULT_ASPECT_RATIO = "1:1"
MAX_RETRIES = 3
RETRY_DELAY_SECONDS = 5
USD_FROM_GLTF_TIMEOUT_S = 120

# Asset categories that benefit from specific generation styles
CATEGORY_STYLE_HINTS = {
    "dishes": "ceramic dishware, photorealistic product photography",
    "utensils": "stainless steel cutlery, photorealistic product photography",
    "food": "realistic food item, photorealistic product photography",
    "groceries": "packaged consumer goods, photorealistic product photography",
    "produce": "fresh produce, photorealistic product photography",
    "bottles": "glass or plastic bottle, photorealistic product photography",
    "cans": "aluminum or tin can, photorealistic product photography",
    "boxes": "cardboard box or package, photorealistic product photography",
    "clothing": "fabric clothing item, photorealistic product photography",
    "towels": "textile towel or cloth, photorealistic product photography",
    "tools": "hand tool, photorealistic product photography",
    "containers": "storage container, photorealistic product photography",
    "electronics": "electronic device, photorealistic product photography",
    "office_supplies": "office supply item, photorealistic product photography",
    "lab_equipment": "laboratory equipment, photorealistic product photography",
}

# Semantic class to material hints
SEMANTIC_CLASS_MATERIALS = {
    "dish": "ceramic, porcelain, or stoneware material",
    "grocery": "plastic packaging, cardboard, or metal can",
    "clothing": "cotton, polyester, or fabric material",
    "tool": "metal and plastic materials",
    "container": "plastic, glass, or metal material",
}


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class VariationAssetSpec:
    """Specification for a variation asset to generate."""
    name: str
    category: str
    description: str
    semantic_class: str
    priority: str
    source_hint: Optional[str]
    example_variants: List[str]
    physics_hints: Dict[str, Any]

    # Enriched generation hints from replicator-job
    material_hint: Optional[str] = None
    style_hint: Optional[str] = None
    generation_prompt_hint: Optional[str] = None

    # Generation tracking
    generated: bool = False
    reference_image_path: Optional[str] = None
    error_message: Optional[str] = None


@dataclass
class GenerationResult:
    """Result of generating a single asset image."""
    asset_name: str
    success: bool
    image_path: Optional[str] = None
    error: Optional[str] = None
    generation_time_seconds: float = 0.0


@dataclass
class ThreeDGenerationResult:
    """Result of generating a single asset 3D model."""
    asset_name: str
    success: bool
    backend: str
    glb_path: Optional[str] = None
    obj_path: Optional[str] = None
    usdz_path: Optional[str] = None
    normal_map_path: Optional[str] = None
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    generation_time_seconds: float = 0.0


@dataclass
class ProcessOutcome:
    success: bool
    partial_success: bool
    should_fail_job: bool


# ============================================================================
# Gemini Client
# ============================================================================

def create_gemini_client():
    """Create Gemini client using API key from environment."""
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY environment variable is required")
    return genai.Client(api_key=api_key)


def gcs_relative_path(path: Optional[str]) -> Optional[str]:
    if not path:
        return None
    try:
        path_obj = Path(path)
        return str(path_obj).replace(str(GCS_ROOT) + "/", "")
    except Exception:
        return path


def create_normal_map_placeholder(output_path: Path, size: int = 1024) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    image = Image.new("RGB", (size, size), color=(128, 128, 255))
    image.save(output_path, format="PNG")


def convert_glb_to_usdz(glb_path: Path, usdz_path: Path) -> bool:
    """Convert GLB to USDZ using usd_from_gltf if available."""
    import shutil
    import subprocess

    usd_from_gltf = shutil.which("usd_from_gltf")
    if usd_from_gltf is None:
        logger.warning("[VARIATION-GEN] usd_from_gltf not available")
        return False

    usdz_path.parent.mkdir(parents=True, exist_ok=True)
    command = [usd_from_gltf, str(glb_path), "-o", str(usdz_path)]
    try:
        subprocess.run(
            command,
            check=True,
            capture_output=True,
            text=True,
            timeout=USD_FROM_GLTF_TIMEOUT_S,
        )
        return True
    except subprocess.TimeoutExpired:
        command_str = " ".join(command)
        logger.error(
            "[VARIATION-GEN] usd_from_gltf timed out after %ss: %s",
            USD_FROM_GLTF_TIMEOUT_S,
            command_str,
        )
        return False
    except subprocess.CalledProcessError as exc:
        details = []
        if exc.stderr:
            details.append(f"stderr: {exc.stderr.strip()}")
        if exc.stdout:
            details.append(f"stdout: {exc.stdout.strip()}")
        detail_str = f" ({'; '.join(details)})" if details else ""
        logger.error(
            "[VARIATION-GEN] usd_from_gltf failed with exit code %s%s",
            exc.returncode,
            detail_str,
        )
        return False


def convert_glb_to_obj(glb_path: Path, obj_path: Path) -> Tuple[bool, Optional[str]]:
    """Convert GLB to OBJ using trimesh if available."""
    try:
        import trimesh
    except ImportError:
        return False, "trimesh not available"

    try:
        mesh = trimesh.load(str(glb_path))
        obj_path.parent.mkdir(parents=True, exist_ok=True)
        mesh.export(str(obj_path))
        return True, None
    except Exception as exc:
        return False, str(exc)


def image_to_data_uri(img_path: Path) -> str:
    mime = "image/png"
    if img_path.suffix.lower() in [".jpg", ".jpeg"]:
        mime = "image/jpeg"
    data = img_path.read_bytes()
    b64 = base64.b64encode(data).decode("ascii")
    return f"data:{mime};base64,{b64}"


def download_file(url: str, out_path: Path) -> None:
    import urllib.request

    out_path.parent.mkdir(parents=True, exist_ok=True)
    logger.info("[VARIATION-GEN] Downloading %s -> %s", url, out_path)
    urllib.request.urlretrieve(url, out_path)


def run_meshy_generation(
    image_path: Path,
    output_dir: Path,
    asset_name: str,
    api_key: str,
    dry_run: bool = False,
) -> Tuple[bool, Dict[str, Optional[Path]], Dict[str, Any], Optional[str]]:
    """
    Run Meshy image-to-3D generation.

    Returns: (success, output_paths, metadata, error_message)
    """
    if dry_run:
        asset_out_dir = output_dir / asset_name
        asset_out_dir.mkdir(parents=True, exist_ok=True)
        glb_path = asset_out_dir / "model.glb"
        obj_path = asset_out_dir / "model.obj"
        usdz_path = asset_out_dir / "model.usdz"
        normal_map_path = asset_out_dir / "normal.png"
        glb_path.write_text("dry run mesh placeholder")
        obj_path.write_text("dry run mesh placeholder")
        usdz_path.write_text("dry run usdz placeholder")
        create_normal_map_placeholder(normal_map_path, size=256)
        return (
            True,
            {
                "glb": glb_path,
                "obj": obj_path,
                "usdz": usdz_path,
                "normal_map": normal_map_path,
            },
            {"dry_run": True},
            None,
        )

    try:
        import requests
    except ImportError:
        return False, {}, {}, "requests not available for Meshy API"

    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    payload = {
        "image_url": image_to_data_uri(image_path),
        "ai_model": "latest",
        "topology": "triangle",
        "should_remesh": False,
        "should_texture": True,
        "enable_pbr": True,
    }

    try:
        response = requests.post(
            "https://api.meshy.ai/openapi/v1/image-to-3d",
            headers=headers,
            json=payload,
            timeout=30,
        )
        response.raise_for_status()
        task_id = response.json()["result"]
    except Exception as exc:
        return False, {}, {}, f"Meshy task creation failed: {exc}"

    poll_url = f"https://api.meshy.ai/openapi/v1/image-to-3d/{task_id}"
    start_time = time.time()
    timeout = float(os.getenv("MESHY_TIMEOUT_S", "1800"))
    while True:
        response = requests.get(poll_url, headers={"Authorization": f"Bearer {api_key}"})
        response.raise_for_status()
        data = response.json()
        status = data.get("status")
        logger.info(
            "[VARIATION-GEN] Meshy %s status=%s progress=%s",
            task_id,
            status,
            data.get("progress"),
        )
        if status == "SUCCEEDED":
            task = data
            break
        if status in {"FAILED", "CANCELED"}:
            return False, {}, {}, f"Meshy task failed: {data.get('task_error')}"
        if time.time() - start_time > timeout:
            return False, {}, {}, "Meshy task timed out"
        time.sleep(10.0)

    asset_out_dir = output_dir / asset_name
    asset_out_dir.mkdir(parents=True, exist_ok=True)

    model_urls = task.get("model_urls", {})
    output_paths: Dict[str, Optional[Path]] = {
        "glb": None,
        "obj": None,
        "usdz": None,
        "normal_map": None,
    }

    for fmt in ("glb", "obj", "usdz"):
        url = model_urls.get(fmt)
        if url:
            out_path = asset_out_dir / f"model.{fmt}"
            download_file(url, out_path)
            output_paths[fmt] = out_path

    if output_paths["glb"] and not output_paths["obj"]:
        obj_path = asset_out_dir / "model.obj"
        ok, err = convert_glb_to_obj(output_paths["glb"], obj_path)
        if ok:
            output_paths["obj"] = obj_path
        else:
            logger.warning("[VARIATION-GEN] GLB->OBJ conversion failed: %s", err)

    if output_paths["glb"] and not output_paths["usdz"]:
        usdz_path = asset_out_dir / "model.usdz"
        if convert_glb_to_usdz(output_paths["glb"], usdz_path):
            output_paths["usdz"] = usdz_path

    normal_map_path = None
    texture_urls = task.get("texture_urls", [])
    for texture in texture_urls:
        for key in ("normal", "normal_map", "normals", "normalMap"):
            url = texture.get(key)
            if url:
                normal_map_path = asset_out_dir / "normal.png"
                download_file(url, normal_map_path)
                output_paths["normal_map"] = normal_map_path
                break
        if normal_map_path:
            break

    if not output_paths["normal_map"]:
        normal_map_path = asset_out_dir / "normal.png"
        create_normal_map_placeholder(normal_map_path, size=1024)
        output_paths["normal_map"] = normal_map_path

    metadata = {
        "task_id": task_id,
        "model_urls": model_urls,
        "texture_urls": texture_urls,
    }
    missing_outputs = [key for key in ("glb", "obj", "usdz", "normal_map") if not output_paths.get(key)]
    if missing_outputs:
        metadata["missing_outputs"] = missing_outputs
        return False, output_paths, metadata, f"Missing outputs: {', '.join(missing_outputs)}"

    return True, output_paths, metadata, None


def run_external_3d_service(
    image_path: Path,
    output_dir: Path,
    asset_name: str,
    service_url: str,
    token: Optional[str] = None,
    dry_run: bool = False,
) -> Tuple[bool, Dict[str, Optional[Path]], Dict[str, Any], Optional[str]]:
    """
    Run an external 3D generation service.

    Expected response payload:
    {
      "model_urls": {"glb": "...", "obj": "...", "usdz": "..."},
      "normal_map_url": "...",
      "metadata": {...}
    }
    """
    if dry_run:
        asset_out_dir = output_dir / asset_name
        asset_out_dir.mkdir(parents=True, exist_ok=True)
        glb_path = asset_out_dir / "model.glb"
        obj_path = asset_out_dir / "model.obj"
        usdz_path = asset_out_dir / "model.usdz"
        normal_map_path = asset_out_dir / "normal.png"
        glb_path.write_text("dry run mesh placeholder")
        obj_path.write_text("dry run mesh placeholder")
        usdz_path.write_text("dry run usdz placeholder")
        create_normal_map_placeholder(normal_map_path, size=256)
        return (
            True,
            {
                "glb": glb_path,
                "obj": obj_path,
                "usdz": usdz_path,
                "normal_map": normal_map_path,
            },
            {"dry_run": True},
            None,
        )

    try:
        import requests
    except ImportError:
        return False, {}, {}, "requests not available for external 3D service"

    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"

    payload = {
        "asset_name": asset_name,
        "image_base64": base64.b64encode(image_path.read_bytes()).decode("ascii"),
    }

    try:
        response = requests.post(
            service_url,
            headers=headers,
            json=payload,
            timeout=float(os.getenv("EXTERNAL_3D_TIMEOUT_S", "1800")),
        )
        response.raise_for_status()
        data = response.json()
    except Exception as exc:
        return False, {}, {}, f"External 3D service error: {exc}"

    asset_out_dir = output_dir / asset_name
    asset_out_dir.mkdir(parents=True, exist_ok=True)

    output_paths: Dict[str, Optional[Path]] = {
        "glb": None,
        "obj": None,
        "usdz": None,
        "normal_map": None,
    }

    model_urls = data.get("model_urls", {})
    for fmt in ("glb", "obj", "usdz"):
        url = model_urls.get(fmt)
        if url:
            out_path = asset_out_dir / f"model.{fmt}"
            download_file(url, out_path)
            output_paths[fmt] = out_path

    if output_paths["glb"] and not output_paths["obj"]:
        obj_path = asset_out_dir / "model.obj"
        ok, err = convert_glb_to_obj(output_paths["glb"], obj_path)
        if ok:
            output_paths["obj"] = obj_path
        else:
            logger.warning("[VARIATION-GEN] GLB->OBJ conversion failed: %s", err)

    if output_paths["glb"] and not output_paths["usdz"]:
        usdz_path = asset_out_dir / "model.usdz"
        if convert_glb_to_usdz(output_paths["glb"], usdz_path):
            output_paths["usdz"] = usdz_path

    normal_map_url = data.get("normal_map_url")
    if normal_map_url:
        normal_map_path = asset_out_dir / "normal.png"
        download_file(normal_map_url, normal_map_path)
        output_paths["normal_map"] = normal_map_path

    if not output_paths["normal_map"]:
        normal_map_path = asset_out_dir / "normal.png"
        create_normal_map_placeholder(normal_map_path, size=1024)
        output_paths["normal_map"] = normal_map_path

    metadata = data.get("metadata", {})
    metadata["raw_response"] = data
    missing_outputs = [key for key in ("glb", "obj", "usdz", "normal_map") if not output_paths.get(key)]
    if missing_outputs:
        metadata["missing_outputs"] = missing_outputs
        return False, output_paths, metadata, f"Missing outputs: {', '.join(missing_outputs)}"

    return True, output_paths, metadata, None


# ============================================================================
# Mock Generator
# ============================================================================

class MockImageGenerator:
    """Generate simple placeholder images for mock runs."""

    def __init__(self, image_size: int = 512) -> None:
        self.image_size = image_size

    def generate(self, asset: VariationAssetSpec, output_dir: Path) -> GenerationResult:
        start_time = time.time()

        asset_dir = output_dir / asset.name
        asset_dir.mkdir(parents=True, exist_ok=True)

        image_path = asset_dir / "reference.png"
        image = Image.new("RGB", (self.image_size, self.image_size), color=(255, 255, 255))
        draw = ImageDraw.Draw(image)
        font = ImageFont.load_default()
        text = asset.name

        if hasattr(draw, "textbbox"):
            bbox = draw.textbbox((0, 0), text, font=font)
            text_width = bbox[2] - bbox[0]
            text_height = bbox[3] - bbox[1]
        else:
            text_width, text_height = draw.textsize(text, font=font)

        text_x = max((self.image_size - text_width) // 2, 0)
        text_y = max((self.image_size - text_height) // 2, 0)
        draw.text((text_x, text_y), text, fill=(0, 0, 0), font=font)
        image.save(image_path, format="PNG")

        elapsed = time.time() - start_time
        logger.info("[VARIATION-GEN] [MOCK] Generated placeholder for: %s", asset.name)
        return GenerationResult(
            asset_name=asset.name,
            success=True,
            image_path=str(image_path),
            generation_time_seconds=elapsed,
        )


# ============================================================================
# Prompt Generation
# ============================================================================

def build_asset_generation_prompt(asset: VariationAssetSpec, policy_context: Optional[str] = None) -> str:
    """
    Build a prompt for Gemini 3.0 Pro Image to generate a reference image for an asset.

    The prompt is designed to produce:
    - High-quality product photography style
    - Transparent/neutral background suitable for 3D reconstruction
    - Consistent lighting and perspective
    - Realistic materials and textures

    If the asset has a generation_prompt_hint from replicator-job, it will be used
    as the base for the prompt. Otherwise, we build one from scratch.
    """
    # Use enriched hints from replicator-job if available
    if asset.generation_prompt_hint:
        base_description = asset.generation_prompt_hint
    else:
        base_description = f"a {asset.description}"

    # Get style hints - prefer asset-specific, fall back to category lookup
    style_hint = asset.style_hint or CATEGORY_STYLE_HINTS.get(
        asset.category.lower(),
        "photorealistic product photography"
    )

    # Get material hints - prefer asset-specific, fall back to semantic class lookup
    material_hint = asset.material_hint or SEMANTIC_CLASS_MATERIALS.get(
        asset.semantic_class.lower(),
        "appropriate realistic materials"
    )

    # Build variant examples text
    variants_text = ""
    if asset.example_variants:
        variants_text = f"\nVariant examples for reference: {', '.join(asset.example_variants[:3])}"

    # Build physics-aware description hints
    physics_text = ""
    if asset.physics_hints:
        mass_range = asset.physics_hints.get("mass_range_kg")
        if mass_range:
            physics_text = f"\nObject should appear to weigh approximately {mass_range[0]}-{mass_range[1]} kg."

    # Policy context for scene-appropriate generation
    context_text = ""
    if policy_context:
        context_text = f"\nThis object will be used in a {policy_context} training scenario."

    prompt = f"""Professional product photography of {base_description}.

Style: {style_hint}
Materials: {material_hint}

Requirements:
- Single isolated object, centered in frame
- Pure white or light gray studio background
- Soft, even studio lighting (3-point lighting)
- Front-facing view, slightly elevated angle (about 15-20 degrees from front)
- Object fills approximately 70-80% of frame
- Sharp focus, high detail
- No shadows on background (floating appearance)
- Photorealistic rendering quality
- 8K resolution detail level
{variants_text}
{physics_text}
{context_text}

The image should be suitable for 3D reconstruction and look like a professional product catalog photo."""

    return prompt


def build_batch_context_prompt(assets: List[VariationAssetSpec], scene_type: str) -> str:
    """Build context prompt for maintaining consistency across batch generation."""
    asset_list = "\n".join([f"- {a.name}: {a.description}" for a in assets[:10]])

    return f"""You are generating a consistent set of objects for a {scene_type} environment simulation.

Objects to generate:
{asset_list}

Maintain consistent:
- Lighting style (soft studio lighting)
- Camera perspective (front-facing, slightly elevated)
- Image quality (photorealistic, high detail)
- Background style (clean white/gray studio)
- Material realism (appropriate for each object type)
"""


# ============================================================================
# Image Generation
# ============================================================================

def generate_asset_image(
    client,
    asset: VariationAssetSpec,
    output_dir: Path,
    policy_context: Optional[str] = None,
    dry_run: bool = False,
) -> GenerationResult:
    """
    Generate a reference image for a single asset.

    Uses Gemini 3.0 Pro Image (Nano Banana Pro) with native image generation.

    Args:
        client: Gemini client instance
        asset: Asset specification
        output_dir: Directory to save the generated image
        policy_context: Optional context about the training policy
        dry_run: If True, skip actual generation (for testing)

    Returns:
        GenerationResult with success status and image path
    """
    import io

    start_time = time.time()

    # Create asset output directory
    asset_dir = output_dir / asset.name
    asset_dir.mkdir(parents=True, exist_ok=True)

    image_path = asset_dir / "reference.png"

    if dry_run:
        logger.info("[VARIATION-GEN] [DRY-RUN] Would generate: %s", asset.name)
        placeholder = Image.new("RGBA", (1, 1), (255, 255, 255, 0))
        placeholder.save(str(image_path), format="PNG")
        return GenerationResult(
            asset_name=asset.name,
            success=True,
            image_path=str(image_path),
            generation_time_seconds=0.0
        )

    # Build prompt
    prompt = build_asset_generation_prompt(asset, policy_context)

    logger.info("[VARIATION-GEN] Generating image for: %s", asset.name)
    logger.info("[VARIATION-GEN]   Category: %s", asset.category)
    logger.info("[VARIATION-GEN]   Description: %s...", asset.description[:80])
    logger.info("[VARIATION-GEN]   Model: %s", GEMINI_IMAGE_MODEL_NAME)

    # Retry loop for robustness
    last_error = None
    for attempt in range(MAX_RETRIES):
        try:
            response = client.models.generate_content(
                model=GEMINI_IMAGE_MODEL,
                contents=prompt,
                config=types.GenerateContentConfig(
                    response_modalities=["IMAGE", "TEXT"],
                    temperature=0.8,
                ),
            )

            # Extract image from Gemini response
            if response.candidates and len(response.candidates) > 0:
                candidate = response.candidates[0]
                if candidate.content and candidate.content.parts:
                    for part in candidate.content.parts:
                        if hasattr(part, 'inline_data') and part.inline_data:
                            # Decode base64 image data
                            image_data = part.inline_data.data
                            if isinstance(image_data, str):
                                image_bytes = base64.b64decode(image_data)
                            else:
                                image_bytes = image_data

                            # Save image
                            img = Image.open(io.BytesIO(image_bytes))
                            img.save(str(image_path), format='PNG')

                            elapsed = time.time() - start_time
                            logger.info(
                                "[VARIATION-GEN] Generated: %s (%.1fs)",
                                asset.name,
                                elapsed,
                            )

                            return GenerationResult(
                                asset_name=asset.name,
                                success=True,
                                image_path=str(image_path),
                                generation_time_seconds=elapsed
                            )

            raise ValueError("No image data in Gemini response")

        except Exception as e:
            last_error = str(e)
            logger.warning(
                "[VARIATION-GEN] Attempt %s/%s failed for %s: %s",
                attempt + 1,
                MAX_RETRIES,
                asset.name,
                e,
            )

            if attempt < MAX_RETRIES - 1:
                time.sleep(RETRY_DELAY_SECONDS * (attempt + 1))  # Exponential backoff

    # All retries failed
    elapsed = time.time() - start_time
    return GenerationResult(
        asset_name=asset.name,
        success=False,
        error=last_error,
        generation_time_seconds=elapsed
    )


def generate_all_assets(
    client,
    assets: List[VariationAssetSpec],
    output_dir: Path,
    policy_context: Optional[str] = None,
    max_assets: Optional[int] = None,
    dry_run: bool = False,
    mock_mode: bool = False,
) -> Tuple[List[GenerationResult], Dict[str, Any]]:
    """
    Generate reference images for all assets that need generation.

    Args:
        client: Gemini client instance
        assets: List of asset specifications
        output_dir: Base directory for output
        policy_context: Optional context about training policy
        max_assets: Optional limit on number of assets to generate
        dry_run: If True, skip actual generation

    Returns:
        Tuple of (list of results, summary statistics)
    """
    # Filter to only assets that need generation
    assets_to_generate = [
        a for a in assets
        if a.source_hint == "generate" or a.source_hint is None
    ]

    # Apply limit if specified
    if max_assets is not None:
        assets_to_generate = assets_to_generate[:max_assets]

    image_model_name = "mock" if mock_mode else GEMINI_IMAGE_MODEL_NAME
    logger.info(
        "[VARIATION-GEN] Generating %s assets using %s...",
        len(assets_to_generate),
        image_model_name,
    )

    results: List[GenerationResult] = []
    mock_generator = MockImageGenerator() if mock_mode else None

    for i, asset in enumerate(assets_to_generate):
        logger.debug(
            "[VARIATION-GEN] Progress: %s/%s", i + 1, len(assets_to_generate)
        )

        if mock_generator:
            result = mock_generator.generate(asset=asset, output_dir=output_dir)
        else:
            result = generate_asset_image(
                client=client,
                asset=asset,
                output_dir=output_dir,
                policy_context=policy_context,
                dry_run=dry_run,
            )
        results.append(result)

        # Small delay between requests to avoid rate limiting
        if not dry_run and not mock_mode and i < len(assets_to_generate) - 1:
            time.sleep(1.0)

    # Compute summary
    successful = sum(1 for r in results if r.success)
    failed = sum(1 for r in results if not r.success)
    total_time = sum(r.generation_time_seconds for r in results)

    summary = {
        "total_attempted": len(results),
        "successful": successful,
        "failed": failed,
        "total_generation_time_seconds": total_time,
        "average_time_per_asset_seconds": total_time / len(results) if results else 0,
        "image_model": image_model_name
    }

    return results, summary


# ============================================================================
# Manifest Processing
# ============================================================================

def load_manifest(manifest_path: Path) -> Tuple[Dict[str, Any], List[VariationAssetSpec]]:
    """
    Load and parse the variation assets manifest.

    The manifest is generated by replicator-job and contains:
    - Asset specifications with descriptions and categories
    - Enriched generation hints (material_hint, style_hint, generation_prompt_hint)
    - Physics hints for simready-job
    - Scene context (scene_type, environment_type, policies)

    Returns:
        Tuple of (raw manifest dict, list of parsed asset specs)
    """
    if not manifest_path.is_file():
        raise FileNotFoundError(f"Manifest not found: {manifest_path}")

    with manifest_path.open("r") as f:
        manifest = json.load(f)

    assets = []
    for asset_dict in manifest.get("assets", []):
        asset = VariationAssetSpec(
            name=asset_dict.get("name", "unknown"),
            category=asset_dict.get("category", "other"),
            description=asset_dict.get("description", ""),
            semantic_class=asset_dict.get("semantic_class", "object"),
            priority=asset_dict.get("priority", "optional"),
            source_hint=asset_dict.get("source_hint"),
            example_variants=asset_dict.get("example_variants", []),
            physics_hints=asset_dict.get("physics_hints", {}),
            # Enriched hints from replicator-job
            material_hint=asset_dict.get("material_hint"),
            style_hint=asset_dict.get("style_hint"),
            generation_prompt_hint=asset_dict.get("generation_prompt_hint")
        )
        assets.append(asset)

    logger.info("[VARIATION-GEN] Loaded manifest with %s assets", len(assets))
    logger.info(
        "[VARIATION-GEN] Scene type: %s", manifest.get("scene_type", "unknown")
    )
    logger.info(
        "[VARIATION-GEN] Environment: %s",
        manifest.get("environment_type", "unknown"),
    )

    return manifest, assets


def create_hunyuan_assets_json(
    results: List[GenerationResult],
    assets: List[VariationAssetSpec],
    output_dir: Path,
    scene_id: str,
    three_d_results: Optional[Dict[str, ThreeDGenerationResult]] = None,
) -> Path:
    """
    Create a scene_assets.json-compatible file for downstream processing.

    This file follows the same format as the main scene_assets.json but
    contains only the variation assets.
    """
    # Build asset lookup
    asset_lookup = {a.name: a for a in assets}

    objects = []
    for result in results:
        if not result.success:
            continue

        asset = asset_lookup.get(result.asset_name)
        if asset is None:
            continue

        three_d_result = three_d_results.get(result.asset_name) if three_d_results else None

        # Create object entry compatible with downstream 3D conversion
        obj = {
            "id": result.asset_name,
            "category": asset.category,
            "short_description": asset.description,
            "sim_role": "manipulable_object",
            "must_be_separate_asset": True,
            # Reference image path relative to GCS mount
            "preferred_view": gcs_relative_path(result.image_path),
            "multiview_dir": None,
            "crop_path": None,
            # Physics hints for simready-job
            "physics_hints": asset.physics_hints,
            "semantic_class": asset.semantic_class,
        }

        if three_d_result:
            obj["generated_3d"] = {
                "status": "success" if three_d_result.success else "failed",
                "backend": three_d_result.backend,
                "glb_path": gcs_relative_path(three_d_result.glb_path),
                "obj_path": gcs_relative_path(three_d_result.obj_path),
                "usdz_path": gcs_relative_path(three_d_result.usdz_path),
                "normal_map_path": gcs_relative_path(three_d_result.normal_map_path),
                "generation_time_seconds": three_d_result.generation_time_seconds,
                "metadata": three_d_result.metadata or {},
                "error": three_d_result.error,
            }
        objects.append(obj)

    assets_json = {
        "scene_id": scene_id,
        "generated_at": datetime.datetime.utcnow().isoformat() + "Z",
        "source": "variation-gen-job",
        "objects": objects,
        "metadata": {
            "total_objects": len(objects),
            "generation_type": "variation_assets"
        }
    }

    output_path = output_dir / "variation_assets.json"
    with output_path.open("w") as f:
        json.dump(assets_json, f, indent=2)

    logger.info(
        "[VARIATION-GEN] Created downstream-compatible assets file: %s", output_path
    )
    return output_path


def update_manifest_with_results(
    manifest: Dict[str, Any],
    results: List[GenerationResult],
    output_path: Path,
    three_d_results: Optional[Dict[str, ThreeDGenerationResult]] = None,
) -> None:
    """Update the manifest with generation results."""
    # Create lookup of results
    result_lookup = {r.asset_name: r for r in results}
    three_d_lookup = three_d_results or {}

    # Update each asset in manifest
    for asset in manifest.get("assets", []):
        name = asset.get("name")
        result = result_lookup.get(name)

        if result:
            asset["generation_status"] = "success" if result.success else "failed"
            if result.image_path:
                asset["reference_image_path"] = result.image_path
            if result.error:
                asset["generation_error"] = result.error

        three_d_result = three_d_lookup.get(name)
        if three_d_result:
            asset["generation_3d_status"] = "success" if three_d_result.success else "failed"
            asset["generation_3d_backend"] = three_d_result.backend
            asset["generated_3d"] = {
                "glb_path": three_d_result.glb_path,
                "obj_path": three_d_result.obj_path,
                "usdz_path": three_d_result.usdz_path,
                "normal_map_path": three_d_result.normal_map_path,
                "metadata": three_d_result.metadata or {},
                "error": three_d_result.error,
            }

    # Add generation metadata
    manifest["generation_completed_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    manifest["generation_summary"] = {
        "total_attempted": len(results),
        "successful": sum(1 for r in results if r.success),
        "failed": sum(1 for r in results if not r.success)
    }

    # Save updated manifest
    with output_path.open("w") as f:
        json.dump(manifest, f, indent=2)

    logger.info("[VARIATION-GEN] Updated manifest: %s", output_path)


# ============================================================================
# 3D Generation
# ============================================================================

def generate_3d_asset(
    asset_name: str,
    image_path: Path,
    output_dir: Path,
    backend: str,
    dry_run: bool = False,
) -> ThreeDGenerationResult:
    start_time = time.time()
    backend_lower = backend.lower()

    if backend_lower == "meshy":
        api_key = os.getenv("MESHY_API_KEY")
        if not api_key:
            return ThreeDGenerationResult(
                asset_name=asset_name,
                success=False,
                backend=backend,
                error="MESHY_API_KEY not set",
                generation_time_seconds=0.0,
                metadata={},
            )
        success, output_paths, metadata, error = run_meshy_generation(
            image_path=image_path,
            output_dir=output_dir,
            asset_name=asset_name,
            api_key=api_key,
            dry_run=dry_run,
        )
    elif backend_lower == "external":
        service_url = os.getenv("EXTERNAL_3D_SERVICE_URL")
        if not service_url:
            return ThreeDGenerationResult(
                asset_name=asset_name,
                success=False,
                backend=backend,
                error="EXTERNAL_3D_SERVICE_URL not set",
                generation_time_seconds=0.0,
                metadata={},
            )
        success, output_paths, metadata, error = run_external_3d_service(
            image_path=image_path,
            output_dir=output_dir,
            asset_name=asset_name,
            service_url=service_url,
            token=os.getenv("EXTERNAL_3D_SERVICE_TOKEN"),
            dry_run=dry_run,
        )
    else:
        return ThreeDGenerationResult(
            asset_name=asset_name,
            success=False,
            backend=backend,
            error=f"Unsupported 3D backend: {backend}",
            generation_time_seconds=0.0,
            metadata={},
        )

    elapsed = time.time() - start_time
    return ThreeDGenerationResult(
        asset_name=asset_name,
        success=success,
        backend=backend,
        glb_path=str(output_paths.get("glb")) if output_paths.get("glb") else None,
        obj_path=str(output_paths.get("obj")) if output_paths.get("obj") else None,
        usdz_path=str(output_paths.get("usdz")) if output_paths.get("usdz") else None,
        normal_map_path=str(output_paths.get("normal_map")) if output_paths.get("normal_map") else None,
        error=error,
        metadata=metadata or {},
        generation_time_seconds=elapsed,
    )


def generate_all_3d_assets(
    results: List[GenerationResult],
    output_dir: Path,
    backend: str,
    dry_run: bool = False,
) -> Tuple[List[ThreeDGenerationResult], Dict[str, Any]]:
    assets_to_process = [r for r in results if r.success and r.image_path]
    logger.info(
        "[VARIATION-GEN] 3D generation enabled for %s assets using %s",
        len(assets_to_process),
        backend,
    )

    three_d_results: List[ThreeDGenerationResult] = []
    for result in assets_to_process:
        image_path = Path(result.image_path)
        three_d_result = generate_3d_asset(
            asset_name=result.asset_name,
            image_path=image_path,
            output_dir=output_dir,
            backend=backend,
            dry_run=dry_run,
        )
        three_d_results.append(three_d_result)
        if not three_d_result.success:
            logger.warning(
                "[VARIATION-GEN] 3D generation failed for %s: %s",
                result.asset_name,
                three_d_result.error,
            )

    total_time = sum(r.generation_time_seconds for r in three_d_results)
    summary = {
        "total_attempted": len(three_d_results),
        "successful": sum(1 for r in three_d_results if r.success),
        "failed": sum(1 for r in three_d_results if not r.success),
        "total_generation_time_seconds": total_time,
        "average_time_per_asset_seconds": total_time / len(three_d_results) if three_d_results else 0,
        "backend": backend,
    }

    return three_d_results, summary

# ============================================================================
# Main Processing
# ============================================================================

def process_variation_assets(
    root: Path,
    scene_id: str,
    replicator_prefix: str,
    variation_assets_prefix: str,
    max_assets: Optional[int] = None,
    dry_run: bool = False,
    priority_filter: Optional[str] = None,
    mock_mode: bool = False,
    enable_3d_generation: bool = False,
    three_d_backend: str = "meshy",
    fail_on_3d_failure: bool = False,
) -> ProcessOutcome:
    """
    Main processing function for variation asset generation.

    Args:
        root: GCS root path
        scene_id: Scene identifier
        replicator_prefix: Path to replicator bundle (contains manifest)
        variation_assets_prefix: Path to output variation assets
        max_assets: Optional limit on number of assets
        dry_run: If True, skip actual generation
        priority_filter: Optional filter ("required", "recommended", "optional")

    Returns:
        ProcessOutcome describing success and failure state.
    """
    logger.info("[VARIATION-GEN] Processing variation assets for scene: %s", scene_id)

    # Load manifest
    manifest_path = root / replicator_prefix / "variation_assets" / "manifest.json"

    try:
        manifest, assets = load_manifest(manifest_path)
    except FileNotFoundError as e:
        logger.error("[VARIATION-GEN] %s", e)
        return ProcessOutcome(success=False, partial_success=False, should_fail_job=True)

    logger.info("[VARIATION-GEN] Loaded manifest with %s assets", len(assets))

    # Filter by priority if specified
    if priority_filter:
        assets = [a for a in assets if a.priority == priority_filter]
        logger.info(
            "[VARIATION-GEN] Filtered to %s %s assets", len(assets), priority_filter
        )

    # Filter to only assets that need generation
    assets_to_generate = [
        a for a in assets
        if a.source_hint == "generate" or a.source_hint is None
    ]

    logger.info(
        "[VARIATION-GEN] %s assets need generation", len(assets_to_generate)
    )

    if not assets_to_generate:
        logger.info("[VARIATION-GEN] No assets need generation; exiting.")
        # Still write completion marker
        output_dir = root / variation_assets_prefix
        output_dir.mkdir(parents=True, exist_ok=True)
        marker_path = output_dir / ".variation_pipeline_complete"
        marker_path.write_text(f"No assets to generate at {datetime.datetime.utcnow().isoformat()}Z\n")
        return ProcessOutcome(success=True, partial_success=False, should_fail_job=False)

    # Get scene context for generation
    scene_type = manifest.get("scene_type", "generic")
    policy_context = f"{scene_type} scene" if scene_type != "generic" else None

    # Create output directory
    output_dir = root / variation_assets_prefix
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create Gemini client
    if not dry_run and not mock_mode:
        try:
            client = create_gemini_client()
        except ValueError as e:
            logger.error("[VARIATION-GEN] %s", e)
            return ProcessOutcome(success=False, partial_success=False, should_fail_job=True)
    else:
        client = None

    # Generate images
    results, summary = generate_all_assets(
        client=client,
        assets=assets_to_generate,
        output_dir=output_dir,
        policy_context=policy_context,
        max_assets=max_assets,
        dry_run=dry_run,
        mock_mode=mock_mode,
    )

    logger.info("[VARIATION-GEN] Generation complete:")
    logger.info("[VARIATION-GEN]   Successful: %s", summary["successful"])
    logger.info("[VARIATION-GEN]   Failed: %s", summary["failed"])
    logger.info(
        "[VARIATION-GEN]   Total time: %.1fs",
        summary["total_generation_time_seconds"],
    )

    three_d_results: List[ThreeDGenerationResult] = []
    three_d_summary: Optional[Dict[str, Any]] = None
    if enable_3d_generation:
        three_d_results, three_d_summary = generate_all_3d_assets(
            results=results,
            output_dir=output_dir,
            backend=three_d_backend,
            dry_run=dry_run,
        )

    three_d_lookup = {r.asset_name: r for r in three_d_results}

    # Create hunyuan-compatible assets file
    if summary['successful'] > 0:
        create_hunyuan_assets_json(
            results=results,
            assets=assets,
            output_dir=output_dir,
            scene_id=scene_id,
            three_d_results=three_d_lookup if three_d_lookup else None,
        )

    # Update manifest with results
    updated_manifest_path = output_dir / "manifest_with_results.json"
    update_manifest_with_results(
        manifest,
        results,
        updated_manifest_path,
        three_d_results=three_d_lookup if three_d_lookup else None,
    )

    # Write generation report
    report = {
        "scene_id": scene_id,
        "generated_at": datetime.datetime.utcnow().isoformat() + "Z",
        "summary": summary,
        "results": [asdict(r) for r in results],
        "config": {
            "image_model": "mock" if mock_mode else GEMINI_IMAGE_MODEL,
            "max_assets": max_assets,
            "priority_filter": priority_filter,
            "dry_run": dry_run,
            "mock_mode": mock_mode,
        }
    }
    if three_d_summary is not None:
        report["summary_3d"] = three_d_summary
        report["results_3d"] = [asdict(r) for r in three_d_results]
        report["config"]["enable_3d_generation"] = enable_3d_generation
        report["config"]["three_d_backend"] = three_d_backend
        report["config"]["fail_on_3d_failure"] = fail_on_3d_failure
    report_path = output_dir / "generation_report.json"
    with report_path.open("w") as f:
        json.dump(report, f, indent=2)

    # Write completion marker
    marker_path = output_dir / ".variation_pipeline_complete"
    marker_path.write_text(
        f"completed at {datetime.datetime.utcnow().isoformat()}Z\n"
        f"successful: {summary['successful']}\n"
        f"failed: {summary['failed']}\n"
    )
    logger.info("[VARIATION-GEN] Wrote completion marker: %s", marker_path)

    image_failed = summary["failed"] > 0
    three_d_failed = (
        three_d_summary["failed"] > 0
        if three_d_summary is not None
        else False
    )
    should_fail_job = enable_3d_generation and fail_on_3d_failure and three_d_failed
    success = (summary["failed"] == 0 or summary["successful"] > 0) and not should_fail_job
    return ProcessOutcome(
        success=success,
        partial_success=image_failed or three_d_failed,
        should_fail_job=should_fail_job,
    )


# ============================================================================
# Entry Point
# ============================================================================

def main():
    """Main entry point for the variation-gen job."""

    # Get configuration from environment
    variation_gen_mode = os.getenv("VARIATION_GEN_MODE", "").lower()
    dry_run = os.getenv("DRY_RUN", "").lower() in {"1", "true", "yes"}
    mock_mode = variation_gen_mode == "mock"
    enable_3d_generation = os.getenv("ENABLE_3D_GENERATION", "").lower() in {"1", "true", "yes"}
    three_d_backend = os.getenv("VARIATION_3D_BACKEND", "meshy")
    fail_on_3d_failure = os.getenv("FAIL_ON_3D_FAILURE", "").lower() in {"1", "true", "yes"}

    required_env_vars = {
        "BUCKET": "GCS bucket name",
        "SCENE_ID": "Scene identifier",
    }
    if not mock_mode and not dry_run:
        required_env_vars["GEMINI_API_KEY"] = "Gemini API key for image generation"
    if enable_3d_generation and three_d_backend.lower() == "meshy":
        required_env_vars["MESHY_API_KEY"] = "Meshy API key for 3D generation"
    if enable_3d_generation and three_d_backend.lower() == "external":
        required_env_vars["EXTERNAL_3D_SERVICE_URL"] = "External 3D service URL"

    validate_required_env_vars(required_env_vars, label="[VARIATION-GEN]")

    bucket = os.environ["BUCKET"]
    scene_id = os.environ["SCENE_ID"]
    replicator_prefix = os.getenv("REPLICATOR_PREFIX", f"scenes/{scene_id}/replicator")
    variation_assets_prefix = os.getenv(
        "VARIATION_ASSETS_PREFIX", f"scenes/{scene_id}/variation_assets"
    )

    # Optional configuration
    max_assets_str = os.getenv("MAX_ASSETS", "")
    max_assets = int(max_assets_str) if max_assets_str else None

    priority_filter = os.getenv("PRIORITY_FILTER", "")  # "required", "recommended", "optional"
    priority_filter = priority_filter if priority_filter else None

    logger.info("[VARIATION-GEN] Starting variation asset generation")
    logger.info("[VARIATION-GEN] Scene ID: %s", scene_id)
    logger.info("[VARIATION-GEN] Bucket: %s", bucket)
    logger.info("[VARIATION-GEN] Replicator prefix: %s", replicator_prefix)
    logger.info("[VARIATION-GEN] Output prefix: %s", variation_assets_prefix)
    image_model_display = "Mock generator" if mock_mode else GEMINI_IMAGE_MODEL_NAME
    logger.info("[VARIATION-GEN] Image model: %s", image_model_display)
    if enable_3d_generation:
        logger.info("[VARIATION-GEN] 3D generation enabled (backend=%s)", three_d_backend)
    if fail_on_3d_failure:
        logger.info("[VARIATION-GEN] 3D failure will fail the job")
    if max_assets:
        logger.info("[VARIATION-GEN] Max assets: %s", max_assets)
    if priority_filter:
        logger.info("[VARIATION-GEN] Priority filter: %s", priority_filter)
    if dry_run:
        logger.info("[VARIATION-GEN] DRY RUN MODE - no actual generation")
    if mock_mode:
        logger.info("[VARIATION-GEN] MOCK MODE - using placeholder images")

    try:
        outcome = process_variation_assets(
            root=GCS_ROOT,
            scene_id=scene_id,
            replicator_prefix=replicator_prefix,
            variation_assets_prefix=variation_assets_prefix,
            max_assets=max_assets,
            dry_run=dry_run,
            priority_filter=priority_filter,
            mock_mode=mock_mode,
            enable_3d_generation=enable_3d_generation,
            three_d_backend=three_d_backend,
            fail_on_3d_failure=fail_on_3d_failure,
        )

        if outcome.success and not outcome.partial_success:
            logger.info("[VARIATION-GEN] SUCCESS: Variation asset generation complete")
            sys.exit(0)
        if outcome.should_fail_job:
            logger.error("[VARIATION-GEN] ERROR: 3D generation failures detected")
            sys.exit(1)
        logger.warning(
            "[VARIATION-GEN] PARTIAL SUCCESS: Some assets failed to generate"
        )
        sys.exit(0)  # Don't fail the job for partial success

    except Exception as e:
        logger.exception("[VARIATION-GEN] ERROR: %s", e)
        sys.exit(1)


if __name__ == "__main__":
    main()
