#!/usr/bin/env python3
"""
Replicator Script: Room Tidying and Sorting
Scene: ChIJBc5E5wTjrIkRKrrWR_meHbc
Policy: general_manipulation

General purpose manipulation involving moving objects between the bed, desk, and nightstand.

This script is auto-generated by the BlueprintPipeline replicator-job.
To use: Open scene.usda in Isaac Sim, then run this script in the Script Editor.
"""

import omni.replicator.core as rep
from typing import List, Dict, Any, Optional
import random
import json
from pathlib import Path

# ============================================================================
# Configuration
# ============================================================================

SCENE_ROOT = "/World"
PLACEMENT_REGIONS_ROOT = "/PlacementRegions"

# Placement regions for this policy
PLACEMENT_REGIONS = {
    "desk_surface": "/PlacementRegions/desk_surface/Surface",
    "nightstand_surface": "/PlacementRegions/nightstand_surface/Surface",
    "bed_base_region": "/PlacementRegions/bed_base_region/Surface"
}

# Variation assets for this policy
VARIATION_ASSETS = {
    "writing_utensils": "./variation_assets/writing_utensils.usdz",
    "drinking_vessel": "./variation_assets/drinking_vessel.usdz",
    "electronic_clutter": "./variation_assets/electronic_clutter.usdz"
}

# Capture configuration
CAPTURE_CONFIG = {
    "resolution": [
        1280,
        720
    ],
    "annotations": [
        "rgb",
        "depth",
        "semantic_segmentation",
        "bounding_box_3d"
    ],
    "frames_per_episode": 100
}

# Randomization parameters
RANDOMIZER_CONFIGS = [
    {
        "name": "object_scatter",
        "enabled": true,
        "frequency": "per_frame",
        "parameters": {
            "min_objects": 6,
            "max_objects": 12,
            "distribution": "clustered"
        }
    },
    {
        "name": "lighting_variation",
        "enabled": true,
        "frequency": "per_episode",
        "parameters": {
            "intensity_range": [
                0.5,
                2.0
            ],
            "color_temperature_range": [
                2500,
                7000
            ]
        }
    }
]

# Tracks objects spawned by scatter randomizer
SPAWNED_OBJECTS = []


# ============================================================================
# Utility Functions
# ============================================================================

def get_placement_surface(region_name: str):
    """Get a placement surface prim by region name."""
    path = PLACEMENT_REGIONS.get(region_name)
    if path:
        return rep.get.prim_at_path(PLACEMENT_REGIONS_ROOT + "/" + region_name.replace("_region", "") + "/Surface")
    return None


def get_all_placement_surfaces():
    """Get all placement surfaces."""
    surfaces = []
    for name in PLACEMENT_REGIONS.keys():
        surface = get_placement_surface(name)
        if surface:
            surfaces.append(surface)
    return surfaces


def load_variation_assets() -> List[str]:
    """Load all variation asset paths."""
    # In production, these would be actual USD paths
    # For now, return the configured paths
    return list(VARIATION_ASSETS.values())


def load_variation_metadata() -> Dict[str, Any]:
    """Load variation asset metadata if available."""
    candidate_paths = [
        Path("./variation_assets/variation_assets.json"),
        Path("./variation_assets.json"),
        Path("./variation_assets/manifest.json"),
    ]
    for path in candidate_paths:
        if path.is_file():
            try:
                with path.open("r", encoding="utf-8") as handle:
                    data = json.load(handle)
                assets = data.get("assets") or data.get("variation_assets") or []
                return {
                    "assets": assets,
                    "raw": data,
                }
            except json.JSONDecodeError:
                print(f"[REPLICATOR] Warning: Failed to parse variation metadata at {path}")
                return {"assets": [], "raw": {}}
    return {"assets": [], "raw": {}}


def _material_ranges_from_hint(material_hint: str) -> Dict[str, Any]:
    hint = (material_hint or "").lower()
    ranges = {
        "base_color_min": (0.4, 0.4, 0.4),
        "base_color_max": (1.0, 1.0, 1.0),
        "roughness": (0.2, 0.8),
        "metallic": (0.0, 0.2),
    }
    if any(token in hint for token in ["metal", "aluminum", "steel", "stainless"]):
        ranges.update({
            "roughness": (0.05, 0.4),
            "metallic": (0.6, 1.0),
        })
    elif any(token in hint for token in ["glass", "ceramic", "porcelain", "stoneware"]):
        ranges.update({
            "roughness": (0.05, 0.3),
            "metallic": (0.0, 0.1),
        })
    elif any(token in hint for token in ["fabric", "cloth", "cotton", "textile"]):
        ranges.update({
            "roughness": (0.6, 1.0),
            "metallic": (0.0, 0.05),
        })
    elif any(token in hint for token in ["plastic", "polymer", "rubber"]):
        ranges.update({
            "roughness": (0.3, 0.7),
            "metallic": (0.0, 0.1),
        })
    elif "wood" in hint:
        ranges.update({
            "roughness": (0.4, 0.85),
            "metallic": (0.0, 0.05),
        })
    return ranges


def _resolve_target_prims(targets: Optional[List[str]], label: str):
    if not targets:
        raise RuntimeError(f"[REPLICATOR] Missing target prims for {label}: no targets configured")
    prims = []
    for target in targets:
        prims.extend(rep.get.prims(path_pattern=target))
    if not prims:
        raise RuntimeError(f"[REPLICATOR] Missing target prims for {label}: {targets}")
    return prims


def _collect_texture_variants(asset_metadata: Dict[str, Any]) -> List[str]:
    for key in ["texture_variants", "textures", "texture_paths", "material_textures"]:
        textures = asset_metadata.get(key)
        if isinstance(textures, list):
            return [t for t in textures if isinstance(t, str)]
    return []


def _build_material_metadata_index(metadata: Dict[str, Any]) -> Dict[str, Any]:
    by_name = {}
    by_semantic = {}
    textures_by_name = {}
    textures_by_semantic = {}
    for asset in metadata.get("assets", []):
        name = asset.get("name")
        semantic = asset.get("semantic_class")
        if name:
            by_name[name] = asset
            textures = _collect_texture_variants(asset)
            if textures:
                textures_by_name[name] = textures
        if semantic:
            by_semantic.setdefault(semantic, []).append(asset)
            textures = _collect_texture_variants(asset)
            if textures:
                textures_by_semantic.setdefault(semantic, []).extend(textures)
    return {
        "by_name": by_name,
        "by_semantic": by_semantic,
        "textures_by_name": textures_by_name,
        "textures_by_semantic": textures_by_semantic,
    }


def _collect_assets_by_category(metadata: Dict[str, Any]) -> Dict[str, List[str]]:
    assets_by_category: Dict[str, List[str]] = {}
    for asset in metadata.get("assets", []):
        category = asset.get("category")
        asset_path = asset.get("asset_path") or asset.get("path") or asset.get("usd_path")
        if category and asset_path:
            assets_by_category.setdefault(category, []).append(asset_path)
    return assets_by_category


def _extract_physics_hints(params: Dict[str, Any]) -> Dict[str, Any]:
    hints: Dict[str, Any] = {}
    if isinstance(params.get("physics_hints"), dict):
        hints.update(params["physics_hints"])
    for key in (
        "dynamic_friction_range",
        "static_friction_range",
        "restitution_range",
        "mass_scale_range",
        "density_scale_range",
    ):
        if key in params and key not in hints:
            hints[key] = params[key]
    return hints


def _apply_physics_hints(target_prims, physics_hints: Dict[str, Any]) -> None:
    if not physics_hints or target_prims is None:
        return

    dynamic_friction_range = physics_hints.get("dynamic_friction_range")
    static_friction_range = physics_hints.get("static_friction_range")
    restitution_range = physics_hints.get("restitution_range")
    mass_scale_range = physics_hints.get("mass_scale_range")
    density_scale_range = physics_hints.get("density_scale_range")

    if not any(
        [
            dynamic_friction_range,
            static_friction_range,
            restitution_range,
            mass_scale_range,
            density_scale_range,
        ]
    ):
        return

    with target_prims:
        if dynamic_friction_range:
            rep.modify.attribute(
                "physxMaterial:dynamicFriction",
                rep.distribution.uniform(dynamic_friction_range[0], dynamic_friction_range[1]),
            )
        if static_friction_range:
            rep.modify.attribute(
                "physxMaterial:staticFriction",
                rep.distribution.uniform(static_friction_range[0], static_friction_range[1]),
            )
        if restitution_range:
            rep.modify.attribute(
                "physxMaterial:restitution",
                rep.distribution.uniform(restitution_range[0], restitution_range[1]),
            )
        if mass_scale_range:
            rep.modify.attribute(
                "physxMassProperties:massScale",
                rep.distribution.uniform(mass_scale_range[0], mass_scale_range[1]),
            )
        if density_scale_range:
            rep.modify.attribute(
                "physxMassProperties:densityScale",
                rep.distribution.uniform(density_scale_range[0], density_scale_range[1]),
            )


# ============================================================================
# Randomizers
# ============================================================================

def create_object_scatter_randomizer(
    surfaces,
    asset_paths: List[str],
    min_objects: int = 5,
    max_objects: int = 15,
    semantic_class: str = "object",
    collision_check: bool = True,
    physics_hints: Optional[Dict[str, Any]] = None,
):
    """Create a randomizer that scatters objects on surfaces."""
    physics_hints = physics_hints or {}

    def randomize_objects():
        # Determine number of objects to spawn
        num_objects = random.randint(min_objects, max_objects)

        if not asset_paths:
            print("[REPLICATOR] Warning: No asset paths provided for scatter")
            return None

        # Create objects from random asset selection
        objects = rep.create.from_usd(
            rep.distribution.choice(asset_paths, num_objects),
            semantics=[("class", semantic_class)],
            count=num_objects
        )
        SPAWNED_OBJECTS.append(objects)

        with objects:
            # Random rotation
            rep.modify.pose(
                rotation=rep.distribution.uniform((0, -15, 0), (0, 15, 360))
            )

            # Scatter on surfaces
            if surfaces:
                rep.randomizer.scatter_2d(
                    surface_prims=surfaces,
                    check_for_collisions=collision_check,
                    seed=random.randint(0, 999999)
                )
        _apply_physics_hints(objects, physics_hints)

        return objects

    return randomize_objects


def create_material_variation_randomizer(
    variation_metadata: Dict[str, Any],
    target_semantic_class: str = "object",
    allow_textures: bool = True,
    physics_hints: Optional[Dict[str, Any]] = None,
):
    """Create a randomizer for material properties on spawned variant objects."""
    metadata_index = _build_material_metadata_index(variation_metadata)
    physics_hints = physics_hints or {}

    def _select_target_prims():
        if SPAWNED_OBJECTS:
            return SPAWNED_OBJECTS
        prims = rep.get.prims(semantics=[("class", target_semantic_class)])
        if prims:
            return [prims]
        prims = rep.get.prims(semantics=[("variant", "true")])
        if prims:
            return [prims]
        prims = rep.get.prims(semantics=[("variant", "variant")])
        if prims:
            return [prims]
        return []

    def _resolve_material_ranges(semantic_class: str) -> Dict[str, Any]:
        assets = metadata_index["by_semantic"].get(semantic_class, [])
        hints = [a.get("material_hint") for a in assets if a.get("material_hint")]
        if hints:
            return _material_ranges_from_hint(random.choice(hints))
        return _material_ranges_from_hint("")

    def _resolve_textures(semantic_class: str) -> List[str]:
        textures = metadata_index["textures_by_semantic"].get(semantic_class, [])
        return list(set(t for t in textures if isinstance(t, str)))

    def randomize_materials():
        target_groups = _select_target_prims()
        if not target_groups:
            return

        material_ranges = _resolve_material_ranges(target_semantic_class)
        textures = _resolve_textures(target_semantic_class) if allow_textures else []
        for target_prims in target_groups:
            with target_prims:
                rep.modify.attribute(
                    "inputs:base_color",
                    rep.distribution.uniform(
                        material_ranges["base_color_min"],
                        material_ranges["base_color_max"],
                    ),
                )
                rep.modify.attribute(
                    "inputs:roughness",
                    rep.distribution.uniform(
                        material_ranges["roughness"][0],
                        material_ranges["roughness"][1],
                    ),
                )
                rep.modify.attribute(
                    "inputs:metallic",
                    rep.distribution.uniform(
                        material_ranges["metallic"][0],
                        material_ranges["metallic"][1],
                    ),
                )
                if textures:
                    texture_choice = rep.distribution.choice(textures)
                    rep.modify.attribute("inputs:diffuse_texture", texture_choice)
                    rep.modify.attribute("inputs:diffuseTexture", texture_choice)
                    rep.modify.attribute("inputs:base_color_texture", texture_choice)
            _apply_physics_hints(target_prims, physics_hints)

    return randomize_materials


def create_lighting_randomizer(
    intensity_range: tuple = (0.5, 1.5),
    color_temp_range: tuple = (4000, 6500)
):
    """Create a randomizer for scene lighting."""

    def randomize_lighting():
        lights = rep.get.prims(path_pattern="/World/.*[Ll]ight.*")

        with lights:
            rep.modify.attribute(
                "inputs:intensity",
                rep.distribution.uniform(intensity_range[0], intensity_range[1])
            )

    return randomize_lighting


def create_camera_randomizer(
    camera_path: str = "/World/Camera",
    position_noise: tuple = (0.05, 0.05, 0.05),
    rotation_noise: tuple = (2, 2, 2)
):
    """Create a randomizer for camera pose with small perturbations."""

    def randomize_camera():
        camera = rep.get.prim_at_path(camera_path)

        if camera:
            with camera:
                # Small position noise
                rep.modify.pose(
                    position=rep.distribution.uniform(
                        (-position_noise[0], -position_noise[1], -position_noise[2]),
                        (position_noise[0], position_noise[1], position_noise[2])
                    ),
                    rotation=rep.distribution.uniform(
                        (-rotation_noise[0], -rotation_noise[1], -rotation_noise[2]),
                        (rotation_noise[0], rotation_noise[1], rotation_noise[2])
                    )
                )

    return randomize_camera


def create_articulation_state_randomizer(
    targets: List[str],
    open_probability: float = 0.5,
    normalize_range: bool = True,
):
    """Randomize articulated joints to open/closed states."""
    prims = _resolve_target_prims(targets, "articulation_state")

    def randomize_articulation_state():
        target_position = rep.distribution.choice(
            [0.0, 1.0],
            weights=[1.0 - open_probability, open_probability],
        )
        if not normalize_range:
            target_position = rep.distribution.choice(
                [0.0, 0.5, 1.0],
                weights=[1.0 - open_probability, open_probability * 0.5, open_probability * 0.5],
            )
        for prim in prims:
            with prim:
                rep.modify.attribute("drive:targetPosition", target_position)

    return randomize_articulation_state


def create_object_placement_randomizer(
    targets: List[str],
    position_noise: float = 0.05,
    rotation_noise: float = 5.0,
    maintain_surface_contact: bool = True,
    surfaces: Optional[List[Any]] = None,
    collision_check: bool = True,
):
    """Randomize poses for existing objects."""
    prims = _resolve_target_prims(targets, "object_placement")

    def randomize_object_placement():
        if maintain_surface_contact and surfaces:
            rep.randomizer.scatter_2d(
                prims=prims,
                surface_prims=surfaces,
                check_for_collisions=collision_check,
                seed=random.randint(0, 999999),
            )
        for prim in prims:
            with prim:
                rep.modify.pose(
                    position=rep.distribution.uniform(
                        (-position_noise, -position_noise, 0.0),
                        (position_noise, position_noise, position_noise),
                    ),
                    rotation=rep.distribution.uniform(
                        (-rotation_noise, -rotation_noise, -rotation_noise),
                        (rotation_noise, rotation_noise, rotation_noise),
                    ),
                )

    return randomize_object_placement


def create_drawer_state_randomizer(
    targets: List[str],
    open_range: List[float],
):
    """Randomize drawer joint positions."""
    prims = _resolve_target_prims(targets, "drawer_state")

    def randomize_drawer_state():
        target_position = rep.distribution.uniform(open_range[0], open_range[1])
        for prim in prims:
            with prim:
                rep.modify.attribute("drive:targetPosition", target_position)

    return randomize_drawer_state


def create_drawer_contents_randomizer(
    targets: List[str],
    asset_paths: List[str],
    fill_ratio: List[float],
    max_items: int = 8,
):
    """Scatter assets into drawer interiors."""
    prims = _resolve_target_prims(targets, "drawer_contents")

    def randomize_drawer_contents():
        if not asset_paths:
            raise RuntimeError("[REPLICATOR] Missing asset paths for drawer contents scatter")
        count = max(1, int(random.uniform(fill_ratio[0], fill_ratio[1]) * max_items))
        items = rep.create.from_usd(
            rep.distribution.choice(asset_paths, count),
            semantics=[("class", "drawer_contents")],
            count=count,
        )
        SPAWNED_OBJECTS.append(items)
        rep.randomizer.scatter_2d(
            prims=items,
            surface_prims=prims,
            check_for_collisions=True,
            seed=random.randint(0, 999999),
        )

    return randomize_drawer_contents


def create_door_state_randomizer(
    targets: List[str],
    open_range: List[float],
):
    """Randomize door joint positions."""
    prims = _resolve_target_prims(targets, "door_state")

    def randomize_door_state():
        target_position = rep.distribution.uniform(open_range[0], open_range[1])
        for prim in prims:
            with prim:
                rep.modify.attribute("drive:targetPosition", target_position)

    return randomize_door_state


def create_knob_state_randomizer(
    targets: List[str],
    rotation_range: List[float],
):
    """Randomize knob rotation."""
    prims = _resolve_target_prims(targets, "knob_state")

    def randomize_knob_state():
        target_position = rep.distribution.uniform(rotation_range[0], rotation_range[1])
        for prim in prims:
            with prim:
                rep.modify.attribute("drive:targetPosition", target_position)

    return randomize_knob_state


def create_cloth_scatter_randomizer(
    targets: List[str],
    asset_paths: List[str],
    min_items: int = 5,
    max_items: int = 20,
):
    """Scatter cloth assets across hamper/basket surfaces."""
    prims = _resolve_target_prims(targets, "cloth_scatter")

    def randomize_cloth_scatter():
        if not asset_paths:
            raise RuntimeError("[REPLICATOR] Missing asset paths for cloth scatter")
        count = random.randint(min_items, max_items)
        items = rep.create.from_usd(
            rep.distribution.choice(asset_paths, count),
            semantics=[("class", "cloth")],
            count=count,
        )
        SPAWNED_OBJECTS.append(items)
        rep.randomizer.scatter_2d(
            prims=items,
            surface_prims=prims,
            check_for_collisions=True,
            seed=random.randint(0, 999999),
        )

    return randomize_cloth_scatter


def create_cloth_deformation_randomizer(
    targets: List[str],
    simulation_steps: int = 10,
    gravity_variation: List[float] = None,
    wind_enabled: bool = False,
):
    """Randomize cloth simulation parameters."""
    prims = _resolve_target_prims(targets, "cloth_deformation")
    gravity_variation = gravity_variation or [-0.2, 0.2]

    def randomize_cloth_deformation():
        gravity_scale = rep.distribution.uniform(
            1.0 + gravity_variation[0],
            1.0 + gravity_variation[1],
        )
        for prim in prims:
            with prim:
                rep.modify.attribute("physxCloth:gravityScale", gravity_scale)
                rep.modify.attribute("physxCloth:solverIterations", simulation_steps)
                if wind_enabled:
                    rep.modify.attribute("physxCloth:windDrag", rep.distribution.uniform(0.1, 1.0))

    return randomize_cloth_deformation


def create_shelf_population_randomizer(
    targets: List[str],
    asset_paths: List[str],
    fill_ratio_range: List[float],
):
    """Populate shelves with random assets."""
    prims = _resolve_target_prims(targets, "shelf_population")

    def randomize_shelf_population():
        if not asset_paths:
            raise RuntimeError("[REPLICATOR] Missing asset paths for shelf population")
        count = max(1, int(random.uniform(fill_ratio_range[0], fill_ratio_range[1]) * 20))
        items = rep.create.from_usd(
            rep.distribution.choice(asset_paths, count),
            semantics=[("class", "shelf_item")],
            count=count,
        )
        SPAWNED_OBJECTS.append(items)
        rep.randomizer.scatter_2d(
            prims=items,
            surface_prims=prims,
            check_for_collisions=True,
            seed=random.randint(0, 999999),
        )

    return randomize_shelf_population


def create_table_setup_randomizer(
    targets: List[str],
    asset_paths: List[str],
    place_settings: List[int],
    include_centerpiece: bool,
):
    """Set up table settings with dishes and utensils."""
    prims = _resolve_target_prims(targets, "table_setup")

    def randomize_table_setup():
        if not asset_paths:
            raise RuntimeError("[REPLICATOR] Missing asset paths for table setup")
        count = random.randint(place_settings[0], place_settings[1])
        items = rep.create.from_usd(
            rep.distribution.choice(asset_paths, count),
            semantics=[("class", "table_setting")],
            count=count,
        )
        SPAWNED_OBJECTS.append(items)
        rep.randomizer.scatter_2d(
            prims=items,
            surface_prims=prims,
            check_for_collisions=True,
            seed=random.randint(0, 999999),
        )
        if include_centerpiece:
            centerpiece = rep.create.from_usd(
                rep.distribution.choice(asset_paths),
                semantics=[("class", "centerpiece")],
                count=1,
            )
            SPAWNED_OBJECTS.append(centerpiece)
            rep.randomizer.scatter_2d(
                prims=centerpiece,
                surface_prims=prims,
                check_for_collisions=True,
                seed=random.randint(0, 999999),
            )

    return randomize_table_setup


def create_dirty_state_randomizer(
    targets: List[str],
    dirty_probability: float,
    intensity_range: List[float],
):
    """Apply dirty material variations."""
    prims = _resolve_target_prims(targets, "dirty_state")

    def randomize_dirty_state():
        if random.random() > dirty_probability:
            return
        intensity = rep.distribution.uniform(intensity_range[0], intensity_range[1])
        for prim in prims:
            with prim:
                rep.modify.attribute(
                    "inputs:base_color",
                    rep.distribution.uniform((0.4, 0.3, 0.2), (0.9, 0.85, 0.8)),
                )
                rep.modify.attribute("inputs:roughness", intensity)

    return randomize_dirty_state


def create_dishwasher_state_randomizer(
    targets: List[str],
    door_state: str,
    loaded_probability: float,
    asset_paths: List[str],
):
    """Randomize dishwasher door and load contents."""
    prims = _resolve_target_prims(targets, "dishwasher_state")

    def randomize_dishwasher_state():
        open_range = (0.0, 1.0) if door_state == "variable" else (0.0, 0.0)
        if door_state == "open":
            open_range = (1.0, 1.0)
        target_position = rep.distribution.uniform(open_range[0], open_range[1])
        for prim in prims:
            with prim:
                rep.modify.attribute("drive:targetPosition", target_position)
        if asset_paths and random.random() < loaded_probability:
            count = random.randint(4, 12)
            items = rep.create.from_usd(
                rep.distribution.choice(asset_paths, count),
                semantics=[("class", "dishwasher_load")],
                count=count,
            )
            SPAWNED_OBJECTS.append(items)
            rep.randomizer.scatter_2d(
                prims=items,
                surface_prims=prims,
                check_for_collisions=True,
                seed=random.randint(0, 999999),
            )

    return randomize_dishwasher_state


def create_switch_states_randomizer(
    targets: List[str],
    on_probability: float,
):
    """Randomize binary switch states."""
    prims = _resolve_target_prims(targets, "switch_states")

    def randomize_switch_states():
        state = rep.distribution.choice([0, 1], weights=[1.0 - on_probability, on_probability])
        for prim in prims:
            with prim:
                rep.modify.attribute("inputs:state", state)

    return randomize_switch_states


def create_label_variation_randomizer(
    targets: List[str],
    variation_metadata: Dict[str, Any],
    texture_library: str,
):
    """Swap label textures on target assets."""
    prims = _resolve_target_prims(targets, "label_variation")
    metadata_index = _build_material_metadata_index(variation_metadata)
    textures = metadata_index["textures_by_semantic"].get(texture_library, [])

    if not textures:
        raise RuntimeError(f"[REPLICATOR] Missing label textures for library '{texture_library}'")

    def randomize_label_variation():
        texture_choice = rep.distribution.choice(textures)
        for prim in prims:
            with prim:
                rep.modify.attribute("inputs:diffuse_texture", texture_choice)
                rep.modify.attribute("inputs:diffuseTexture", texture_choice)
                rep.modify.attribute("inputs:base_color_texture", texture_choice)

    return randomize_label_variation


def create_pallet_placement_randomizer(
    targets: List[str],
    position_noise: float,
    rotation_noise: float,
):
    """Randomize pallet poses."""
    prims = _resolve_target_prims(targets, "pallet_placement")

    def randomize_pallet_placement():
        for prim in prims:
            with prim:
                rep.modify.pose(
                    position=rep.distribution.uniform(
                        (-position_noise, -position_noise, 0.0),
                        (position_noise, position_noise, position_noise),
                    ),
                    rotation=rep.distribution.uniform(
                        (-rotation_noise, -rotation_noise, -rotation_noise),
                        (rotation_noise, rotation_noise, rotation_noise),
                    ),
                )

    return randomize_pallet_placement


def create_load_variation_randomizer(
    targets: List[str],
    asset_paths: List[str],
    stack_height_range: List[int],
):
    """Randomize pallet load stacking."""
    prims = _resolve_target_prims(targets, "load_variation")

    def randomize_load_variation():
        if not asset_paths:
            raise RuntimeError("[REPLICATOR] Missing asset paths for load variation")
        count = random.randint(stack_height_range[0], stack_height_range[1])
        items = rep.create.from_usd(
            rep.distribution.choice(asset_paths, count),
            semantics=[("class", "pallet_load")],
            count=count,
        )
        SPAWNED_OBJECTS.append(items)
        rep.randomizer.scatter_2d(
            prims=items,
            surface_prims=prims,
            check_for_collisions=True,
            seed=random.randint(0, 999999),
        )

    return randomize_load_variation


# ============================================================================
# Main Replicator Setup
# ============================================================================

def setup_replicator():
    """Set up the complete Replicator pipeline for Room Tidying and Sorting."""

    print("[REPLICATOR] Setting up Room Tidying and Sorting...")

    # Create a new layer for replicator modifications
    with rep.new_layer():

        # Get placement surfaces
        surfaces = get_all_placement_surfaces()
        if not surfaces:
            print("[REPLICATOR] Warning: No placement surfaces found")
            surfaces = None

        # Load variation assets
        asset_paths = load_variation_assets()
        variation_metadata = load_variation_metadata()

        # Create render product
        resolution = tuple(CAPTURE_CONFIG.get("resolution", [1280, 720]))
        render_product = rep.create.render_product("/World/Camera", resolution)

        # Set up randomizers based on config
        registered_randomizers = []

        for config in RANDOMIZER_CONFIGS:
            if not config.get("enabled", True):
                continue

            name = config.get("name", "")
            params = config.get("parameters", {})
            targets = config.get("targets") or params.get("targets") or []
            metadata_assets_by_category = _collect_assets_by_category(variation_metadata)
            asset_categories = params.get("asset_categories", [])
            categorized_assets = []
            for category in asset_categories:
                categorized_assets.extend(metadata_assets_by_category.get(category, []))
            resolved_assets = categorized_assets or asset_paths

            if name == "object_scatter":
                physics_hints = _extract_physics_hints(params)
                randomizer = create_object_scatter_randomizer(
                    surfaces=surfaces,
                    asset_paths=asset_paths,
                    min_objects=params.get("min_objects", 5),
                    max_objects=params.get("max_objects", 15),
                    semantic_class=params.get("semantic_class", "object"),
                    collision_check=params.get("collision_check", True),
                    physics_hints=physics_hints,
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("object_scatter", randomizer, config.get("frequency", "per_frame")))

            elif name == "material_variation":
                physics_hints = _extract_physics_hints(params)
                randomizer = create_material_variation_randomizer(
                    variation_metadata=variation_metadata,
                    target_semantic_class=params.get("semantic_class", "object"),
                    allow_textures=params.get("allow_textures", True),
                    physics_hints=physics_hints,
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append((
                    "material_variation",
                    randomizer,
                    config.get("frequency", "per_frame")
                ))

            elif name == "lighting_variation":
                randomizer = create_lighting_randomizer(
                    intensity_range=tuple(params.get("intensity_range", [0.5, 1.5])),
                    color_temp_range=tuple(params.get("color_temperature_range", [4000, 6500]))
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("lighting", randomizer, config.get("frequency", "per_episode")))

            elif name == "camera_variation":
                randomizer = create_camera_randomizer(
                    position_noise=tuple(params.get("position_noise", [0.05, 0.05, 0.05])),
                    rotation_noise=tuple(params.get("rotation_noise", [2, 2, 2]))
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("camera", randomizer, config.get("frequency", "per_frame")))

            elif name == "articulation_state":
                randomizer = create_articulation_state_randomizer(
                    targets=targets,
                    open_probability=params.get("open_probability", 0.5),
                    normalize_range=params.get("normalize_range", True),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("articulation_state", randomizer, config.get("frequency", "per_frame")))

            elif name == "object_placement":
                randomizer = create_object_placement_randomizer(
                    targets=targets,
                    position_noise=params.get("position_noise", 0.05),
                    rotation_noise=params.get("rotation_noise", 5),
                    maintain_surface_contact=params.get("maintain_surface_contact", True),
                    surfaces=surfaces,
                    collision_check=params.get("collision_check", True),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("object_placement", randomizer, config.get("frequency", "per_frame")))

            elif name == "drawer_state":
                randomizer = create_drawer_state_randomizer(
                    targets=targets,
                    open_range=params.get("open_range", [0.0, 1.0]),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("drawer_state", randomizer, config.get("frequency", "per_frame")))

            elif name == "drawer_contents":
                randomizer = create_drawer_contents_randomizer(
                    targets=targets,
                    asset_paths=resolved_assets,
                    fill_ratio=params.get("fill_ratio", [0.2, 0.8]),
                    max_items=params.get("max_items", 8),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("drawer_contents", randomizer, config.get("frequency", "per_frame")))

            elif name == "door_state":
                randomizer = create_door_state_randomizer(
                    targets=targets,
                    open_range=params.get("open_range", [0.0, 1.57]),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("door_state", randomizer, config.get("frequency", "per_frame")))

            elif name == "knob_state":
                randomizer = create_knob_state_randomizer(
                    targets=targets,
                    rotation_range=params.get("rotation_range", [0.0, 6.28]),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("knob_state", randomizer, config.get("frequency", "per_frame")))

            elif name == "cloth_scatter":
                randomizer = create_cloth_scatter_randomizer(
                    targets=targets,
                    asset_paths=resolved_assets,
                    min_items=params.get("min_items", 5),
                    max_items=params.get("max_items", 20),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("cloth_scatter", randomizer, config.get("frequency", "per_frame")))

            elif name == "cloth_deformation":
                randomizer = create_cloth_deformation_randomizer(
                    targets=targets,
                    simulation_steps=params.get("simulation_steps", 10),
                    gravity_variation=params.get("gravity_variation", [-0.2, 0.2]),
                    wind_enabled=params.get("wind_enabled", False),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("cloth_deformation", randomizer, config.get("frequency", "per_frame")))

            elif name == "shelf_population":
                randomizer = create_shelf_population_randomizer(
                    targets=targets,
                    asset_paths=resolved_assets,
                    fill_ratio_range=params.get("fill_ratio_range", [0.3, 0.9]),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("shelf_population", randomizer, config.get("frequency", "per_frame")))

            elif name == "table_setup":
                randomizer = create_table_setup_randomizer(
                    targets=targets,
                    asset_paths=resolved_assets,
                    place_settings=params.get("place_settings", [1, 6]),
                    include_centerpiece=params.get("include_centerpiece", True),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("table_setup", randomizer, config.get("frequency", "per_frame")))

            elif name == "dirty_state":
                randomizer = create_dirty_state_randomizer(
                    targets=targets,
                    dirty_probability=params.get("dirty_probability", 0.7),
                    intensity_range=params.get("intensity_range", [0.1, 0.8]),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("dirty_state", randomizer, config.get("frequency", "per_frame")))

            elif name == "dishwasher_state":
                randomizer = create_dishwasher_state_randomizer(
                    targets=targets,
                    door_state=params.get("door_state", "variable"),
                    loaded_probability=params.get("loaded_probability", 0.3),
                    asset_paths=resolved_assets,
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("dishwasher_state", randomizer, config.get("frequency", "per_frame")))

            elif name == "switch_states":
                randomizer = create_switch_states_randomizer(
                    targets=targets,
                    on_probability=params.get("on_probability", 0.5),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("switch_states", randomizer, config.get("frequency", "per_frame")))

            elif name == "label_variation":
                randomizer = create_label_variation_randomizer(
                    targets=targets,
                    variation_metadata=variation_metadata,
                    texture_library=params.get("texture_library", "shipping_labels"),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("label_variation", randomizer, config.get("frequency", "per_frame")))

            elif name == "pallet_placement":
                randomizer = create_pallet_placement_randomizer(
                    targets=targets,
                    position_noise=params.get("position_noise", 0.1),
                    rotation_noise=params.get("rotation_noise", 10),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("pallet_placement", randomizer, config.get("frequency", "per_frame")))

            elif name == "load_variation":
                randomizer = create_load_variation_randomizer(
                    targets=targets,
                    asset_paths=resolved_assets,
                    stack_height_range=params.get("stack_height_range", [1, 4]),
                )
                rep.randomizer.register(randomizer)
                registered_randomizers.append(("load_variation", randomizer, config.get("frequency", "per_frame")))

        # Set up writer for annotations
        annotations = CAPTURE_CONFIG.get("annotations", ["rgb"])

        writer = rep.WriterRegistry.get("BasicWriter")
        writer.initialize(
            output_dir=f"./synthetic_data/ChIJBc5E5wTjrIkRKrrWR_meHbc/general_manipulation",
            rgb=("rgb" in annotations),
            distance_to_camera=("depth" in annotations),
            semantic_segmentation=("semantic_segmentation" in annotations),
            instance_segmentation=("instance_segmentation" in annotations),
            bounding_box_2d_tight=("bounding_box_2d" in annotations),
            bounding_box_3d=("bounding_box_3d" in annotations),
        )
        writer.attach([render_product])

        print(f"[REPLICATOR] Registered {len(registered_randomizers)} randomizers")
        print(f"[REPLICATOR] Output annotations: {annotations}")

        return registered_randomizers, render_product


def run_replicator(num_frames: int = None):
    """Run the Replicator data generation."""

    if num_frames is None:
        num_frames = CAPTURE_CONFIG.get("frames_per_episode", 100)

    print(f"[REPLICATOR] Starting data generation: {num_frames} frames")

    randomizers, render_product = setup_replicator()

    # Trigger randomization on each frame
    with rep.trigger.on_frame(num_frames=num_frames):
        for name, randomizer, frequency in randomizers:
            if frequency == "per_frame":
                randomizer()

    print("[REPLICATOR] Data generation complete!")


# ============================================================================
# Entry Point
# ============================================================================

if __name__ == "__main__":
    # Default: run with configured frame count
    run_replicator()
else:
    # When imported in Isaac Sim Script Editor
    print("[REPLICATOR] Script loaded. Call run_replicator() to start.")
    print(f"[REPLICATOR] Policy: Room Tidying and Sorting")
    print(f"[REPLICATOR] Regions: {list(PLACEMENT_REGIONS.keys())}")
    print(f"[REPLICATOR] Assets: {len(VARIATION_ASSETS)} variation assets configured")
