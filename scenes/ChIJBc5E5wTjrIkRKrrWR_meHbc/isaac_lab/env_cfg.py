"""
Environment Configuration - bedroom_manipulation
Generated by BlueprintRecipe (Gemini-guided)

This file defines the environment configuration for Isaac Lab.
"""

from __future__ import annotations

from dataclasses import MISSING
from typing import Literal

import torch
import isaaclab.sim as sim_utils
import isaaclab.utils.math as math_utils
from isaaclab.assets import ArticulationCfg, AssetBaseCfg, RigidObjectCfg
from isaaclab.envs import ManagerBasedEnvCfg
from isaaclab.managers import EventTermCfg, ObservationGroupCfg, ObservationTermCfg
from isaaclab.managers import RewardTermCfg, SceneEntityCfg, TerminationTermCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sensors import CameraCfg, ContactSensorCfg
from isaaclab.utils import configclass
from . import reward_functions


SCENE_ENTITY_MAP = {
    "robot": "/World/Robot",
    "scene_root": "/World/Bedroom",
    "obj_0": "/World/Bedroom/Objects/obj_0",
    "obj_1": "/World/Bedroom/Objects/obj_1",
    "obj_2": "/World/Bedroom/Objects/obj_2",
    "obj_3": "/World/Bedroom/Objects/obj_3",
    "obj_4": "/World/Bedroom/Objects/obj_4",
    "scene_background": "/World/Bedroom/Objects/scene_background",
}


def resolve_scene_entity(name: str, fallback: str | None = None) -> SceneEntityCfg:
    """Resolve a SceneEntityCfg using the recipe-aware prim mapping."""

    prim = SCENE_ENTITY_MAP.get(name, fallback)
    if prim:
        return SceneEntityCfg(name, prim_path=prim)
    return SceneEntityCfg(name)


def observation_target_relative(
    env,
    source_entity: SceneEntityCfg,
    target_entity: SceneEntityCfg,
):
    """Return target position relative to a source asset (EE or link)."""

    source = env.scene.get(source_entity.name)
    target = env.scene.get(target_entity.name)
    if source is None or target is None:
        return torch.zeros(env.num_envs, 3, device=env.device)

    source_pos = source.data.root_pos_w
    target_pos = target.data.root_pos_w
    return target_pos - source_pos


def observation_gripper_width(env, gripper_dof_indices: tuple[int, int] | None = None):
    """Compute gripper opening width from joint positions."""

    robot = env.scene.get("robot")
    if robot is None:
        return torch.zeros(env.num_envs, 1, device=env.device)

    if gripper_dof_indices is None:
        gripper_dof_indices = (-2, -1)
    joint_pos = robot.data.joint_pos[:, list(gripper_dof_indices)]
    width = torch.abs(joint_pos[:, 0]) + torch.abs(joint_pos[:, 1])
    return width.unsqueeze(-1)


def reward_reaching(
    env,
    target_entity: SceneEntityCfg = SceneEntityCfg("obj_0", prim_path=SCENE_ENTITY_MAP.get("obj_0")),
    ee_body: str = "panda_hand",
    distance_scale: float = 5.0,
    success_threshold: float = 0.05,
):
    """Dense reaching reward towards the scene-aware target."""

    robot = env.scene.get("robot")
    target = env.scene.get(target_entity.name)
    if robot is None or target is None:
        return torch.zeros(env.num_envs, device=env.device)

    ee_id = robot.find_bodies(ee_body)[0]
    ee_pos = robot.data.body_pos_w[:, ee_id]
    target_pos = target.data.root_pos_w
    dist = torch.norm(target_pos - ee_pos, dim=-1)

    shaped = 1.0 - torch.tanh(distance_scale * dist)
    success_bonus = (dist < success_threshold).float() * 2.0
    return shaped + success_bonus


def reward_task_success(env, success_flag: str = "task_success", bonus: float = 10.0):
    """Reward emitted when the task_success flag is true."""

    status = getattr(env, success_flag, torch.zeros(env.num_envs, dtype=torch.bool, device=env.device))
    return status.float() * bonus


def termination_object_dropped(
    env,
    object_entity: SceneEntityCfg = SceneEntityCfg("obj_0", prim_path=SCENE_ENTITY_MAP.get("obj_0")),
    threshold: float = -0.05,
):
    """Terminate if the tracked object falls below the workspace floor."""

    target = env.scene.get(object_entity.name)
    if target is None:
        return torch.zeros(env.num_envs, dtype=torch.bool, device=env.device)

    z_height = target.data.root_pos_w[:, 2]
    return z_height < threshold


def termination_task_success(env, success_attr: str = "task_success"):
    """Terminate successful rollouts early."""

    status = getattr(env, success_attr, torch.zeros(env.num_envs, dtype=torch.bool, device=env.device))
    return status


@configclass
class SceneCfg(InteractiveSceneCfg):
    """Configuration for the scene."""

    # Ground plane (from recipe room)
    ground = AssetBaseCfg(
        prim_path="/World/ground",
        spawn=sim_utils.GroundPlaneCfg(),
    )

    # Scene USD (from recipe)
    scene = AssetBaseCfg(
        prim_path="/World/Scene",
        spawn=sim_utils.UsdFileCfg(
            usd_path="/Users/nijelhunt_1/workspace/BlueprintPipeline/scenes/ChIJBc5E5wTjrIkRKrrWR_meHbc/usd/scene.usda",
            scale=(1.0, 1.0, 1.0),
        ),
    )

    # Robot configuration
    robot = ArticulationCfg(
        prim_path=SCENE_ENTITY_MAP.get("robot", "/World/Robot"),
        spawn=sim_utils.UsdFileCfg(
            usd_path="{ROBOT_USD_PATH}",  # Resolved at runtime
            activate_contact_sensors=True,
        ),
        init_state=ArticulationCfg.InitialStateCfg(
            pos=(0.0, 0.0, 0.0),
            joint_pos={"joint_0": 0.0, "joint_1": -0.785, "joint_2": 0.0, "joint_3": -2.356, "joint_4": 0.0, "joint_5": 1.571, "joint_6": 0.785},
        ),
    )

    # Primary task object (optional static registration for sensors)
    if "obj_0":
        obj_0 = RigidObjectCfg(
            prim_path=SCENE_ENTITY_MAP.get("obj_0", "/World/Scene/obj_0"),
            spawn=None,
            init_state=RigidObjectCfg.InitialStateCfg(),
        )

    # Lighting
    light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(
            intensity=1500.0,
            color=(1.0, 1.0, 1.0),
        ),
    )


@configclass
class ObservationsCfg:
    """Observation configuration."""

    @configclass
    class PolicyCfg(ObservationGroupCfg):
        """Observations for the policy."""

        # Robot state observations
        joint_pos = ObservationTermCfg(
            func="isaaclab.envs.mdp.joint_pos",
            params={"asset_cfg": resolve_scene_entity("robot")},
        )
        joint_vel = ObservationTermCfg(
            func="isaaclab.envs.mdp.joint_vel",
            params={"asset_cfg": resolve_scene_entity("robot")},
        )
        ee_pos = ObservationTermCfg(
            func="isaaclab.envs.mdp.body_pos_w",
            params={
                "asset_cfg": resolve_scene_entity("robot"),
                "body_name": "panda_hand"
            },
        )
        target_rel_pos = ObservationTermCfg(
            func="observation_target_relative",
            params={
                "source_entity": resolve_scene_entity("robot"),
                "target_entity": resolve_scene_entity("obj_0")
            },
        )
        gripper_width = ObservationTermCfg(
            func="observation_gripper_width",
            params={"gripper_dof_indices": (-2, -1)},
        )

        def __post_init__(self):
            self.enable_corruption = False
            self.concatenate_terms = True

    policy: PolicyCfg = PolicyCfg()


@configclass
class ActionsCfg:
    """Action configuration."""

    joint_vel = {
        "class_type": "isaaclab.envs.mdp.JointVelocityActionCfg",
        "asset_name": "robot",
        "joint_names": [".*"],
        "scale": 0.1,
    }


@configclass
class RewardsCfg:
    """Reward configuration."""

    action_jerk_penalty = RewardTermCfg(
        func=reward_functions.reward_action_jerk_penalty,
        weight=0.01,
    )

    action_magnitude_penalty = RewardTermCfg(
        func=reward_functions.reward_action_magnitude_penalty,
        weight=0.001,
    )


@configclass
class TerminationsCfg:
    """Termination configuration."""

    time_out = TerminationTermCfg(
        func="isaaclab.envs.mdp.time_out",
        time_out=True,
    )

    object_dropped = TerminationTermCfg(
        func="termination_object_dropped",
    )

    task_success = TerminationTermCfg(
        func="termination_task_success",
    )


@configclass
class EventsCfg:
    """Event configuration for domain randomization."""

    pass  # No event terms configured


@configclass
class BedroomManipulationEnvCfg(ManagerBasedEnvCfg):
    """Configuration for bedroom_manipulation environment."""

    # Scene
    scene: SceneCfg = SceneCfg(num_envs=1024, env_spacing=2.0)

    # Basic settings
    observations: ObservationsCfg = ObservationsCfg()
    actions: ActionsCfg = ActionsCfg()
    rewards: RewardsCfg = RewardsCfg()
    terminations: TerminationsCfg = TerminationsCfg()
    events: EventsCfg = EventsCfg()

    # Episode settings
    episode_length_s = 8.3  # seconds

    def __post_init__(self):
        """Post initialization with physics profile for sim2real optimization."""
        # Physics profile: Balanced settings for general manipulation tasks. Good accuracy with reasonable speed.
        # Selected based on task type for optimal sim2real transfer

        # Simulation settings from physics profile
        self.sim.dt = 0.008
        self.sim.substeps = 2
        self.sim.render_interval = 1

        # PhysX solver settings
        self.sim.physx.solver_type = 1  # 0=PGS, 1=TGS
        self.sim.physx.num_position_iterations = 16
        self.sim.physx.num_velocity_iterations = 4
        self.sim.physx.enable_stabilization = True
        self.sim.physx.enable_gyroscopic_forces = True

        # Contact settings for accurate manipulation
        self.sim.physx.bounce_threshold_velocity = 0.5
        self.sim.physx.friction_offset_threshold = 0.04
        self.sim.physx.friction_correlation_distance = 0.025

        # Update scene settings
        self.scene.num_envs = 1024
        self.scene_entity_map = SCENE_ENTITY_MAP
