# arena-export-pipeline.yaml
#
# Google Cloud Workflows pipeline that exports Blueprint scenes to Isaac Lab-Arena format.
#
# This pipeline:
#   1. Triggers on completion markers from multiple upstream jobs
#   2. Runs arena-export-job to detect affordances and generate Arena format
#   3. Optionally registers the environment with LeRobot Hub
#
# IMPORTANT: Arena export now runs in BOTH paths:
#   - Path A (Isaac Lab mode): Triggers on .isaac_lab_complete or .usd_complete
#   - Path B (Genie Sim mode): Triggers on .geniesim_complete
#
# This ensures you always have:
#   - Training DATA (from Genie Sim or Isaac Lab episode generation)
#   - Evaluation INFRASTRUCTURE (from Arena) to benchmark trained policies
#
# Trigger: Cloud Storage object finalized event for:
#   - .usd_complete (fallback)
#   - .isaac_lab_complete (Isaac Lab path)
#   - .geniesim_complete (Genie Sim path - NEW)
#
# Isaac Lab-Arena is NVIDIA's open-source framework for robot policy evaluation
# at scale using standardized affordances and benchmarks.
# Reference: https://developer.nvidia.com/isaac/lab-arena

main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: ${default(sys.get_env("WORKFLOW_REGION"), "us-central1")}
        next: filter_completion_markers

    - filter_completion_markers:
        switch:
          # Trigger on USD completion (preferred - has scene baseline)
          - condition: '${text.match_regex(object, "^scenes/.+/usd/\\.usd_complete$")}'
            next: derive_from_usd
          # Trigger on Genie Sim completion (Genie Sim path - enables Arena for both paths)
          - condition: '${text.match_regex(object, "^scenes/.+/geniesim/\\.geniesim_complete$")}'
            next: derive_from_geniesim
          # Also trigger on Isaac Lab completion if available (enhanced RL task data)
          - condition: '${text.match_regex(object, "^scenes/.+/isaac_lab/\\.isaac_lab_complete$")}'
            next: derive_from_isaac_lab
        next: skip

    - derive_from_isaac_lab:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - arenaPrefix: '${"scenes/" + sceneId + "/arena"}'
          - arenaFailedMarker: '${"scenes/" + sceneId + "/arena/.failed"}'
          - geniesimPrefix: ""
          - arenaJobName: "arena-export-job"
          - triggerSource: "isaac_lab"
        next: log_start

    - derive_from_geniesim:
        # Triggered after Genie Sim completes - ensures Arena runs in BOTH paths
        # This is critical: Genie Sim generates DATA, Arena provides EVALUATION infrastructure
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - arenaPrefix: '${"scenes/" + sceneId + "/arena"}'
          - arenaFailedMarker: '${"scenes/" + sceneId + "/arena/.failed"}'
          - geniesimPrefix: '${"scenes/" + sceneId + "/geniesim"}'
          - arenaJobName: "arena-export-job"
          - triggerSource: "geniesim"
        next: log_start

    - derive_from_usd:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - arenaPrefix: '${"scenes/" + sceneId + "/arena"}'
          - arenaFailedMarker: '${"scenes/" + sceneId + "/arena/.failed"}'
          - geniesimPrefix: ""
          - arenaJobName: "arena-export-job"
          - triggerSource: "usd"
        next: log_start

    - log_start:
        call: sys.log
        args:
          text: '${"Arena export triggered for scene " + sceneId + " (source: " + triggerSource + ") - detecting affordances and generating Arena format"}'
          severity: "INFO"
        next: init_arena_metrics

    # =========================================================================
    # Arena Export Job - Generate Isaac Lab-Arena compatible format
    # =========================================================================

    - init_arena_metrics:
        assign:
          - arenaStartTime: '${time.format(sys.now())}'
          - arenaTimeoutSeconds: 1800
        next: emit_arena_metrics_start

    - emit_arena_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "arena-export-pipeline"
            job: ${arenaJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${arenaTimeoutSeconds}
            retry_max: 3
            start_time: ${arenaStartTime}
          severity: "INFO"
        next: run_arena_export_job

    - run_arena_export_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + arenaJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: ARENA_PREFIX
                        value: ${arenaPrefix}
                      # Genie Sim prefix (when triggered from Genie Sim path)
                      # This allows Arena to reference the generated training data
                      - name: GENIESIM_PREFIX
                        value: '${default(geniesimPrefix, "")}'
                      # Source that triggered this Arena export
                      - name: TRIGGER_SOURCE
                        value: ${triggerSource}
                      # Enable LLM-based affordance detection
                      - name: USE_LLM_AFFORDANCES
                        value: "true"
                      # Enable Hub registration (requires HF_TOKEN secret)
                      - name: ENABLE_HUB_REGISTRATION
                        value: '${sys.get_env("ENABLE_HUB_REGISTRATION", "false")}'
                      - name: HUB_NAMESPACE
                        value: '${sys.get_env("HUB_NAMESPACE", "blueprint-robotics")}'
              timeout: "1800s"  # 30 minutes max for Arena export
          result: arenaExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_arena_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "arena-export-pipeline"
                    job: ${arenaJobName}
                    scene_id: ${sceneId}
                    retry_max: 3
                    error: ${e.message}
                  severity: "ERROR"
            - log_arena_error:
                call: sys.log
                args:
                  text: '${"Failed to start Arena export job after retries: " + e.message}'
                  severity: "ERROR"
            - list_arena_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${arenaPrefix + "/"}
                  maxResults: 1000
                result: arenaCleanupList
            - delete_arena_outputs_for_cleanup:
                for:
                  value: arenaCleanupItem
                  in: ${default(arenaCleanupList.items, [])}
                  steps:
                    - delete_arena_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${arenaCleanupItem.name}
            - write_arena_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${arenaFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": arenaJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "arena_export_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "arena_prefix": arenaPrefix
                      }
                    }
                  })}
            - raise_arena_error:
                raise: ${e}
        next: set_arena_execution_name

    - set_arena_execution_name:
        assign:
          - arenaExecutionName: '${if(arenaExec.metadata != null and arenaExec.metadata.name != null, arenaExec.metadata.name, arenaExec.name)}'
        next: wait_for_arena

    - wait_for_arena:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${arenaExecutionName}
        result: arenaStatus
        next: check_arena_status

    - check_arena_status:
        assign:
          - arenaState: '${if(arenaStatus.state != null, arenaStatus.state, if(arenaStatus.status != null, arenaStatus.status.state, null))}'
          - arenaFailedCount: '${if(arenaStatus.failedCount != null, arenaStatus.failedCount, if(arenaStatus.status != null, arenaStatus.status.failedCount, null))}'
          - arenaSucceededCount: '${if(arenaStatus.succeededCount != null, arenaStatus.succeededCount, if(arenaStatus.status != null, arenaStatus.status.succeededCount, null))}'
        next: arena_status_switch

    - arena_status_switch:
        switch:
          - condition: '${arenaState == "FAILED" or (arenaFailedCount != null and arenaFailedCount > 0)}'
            next: arena_failed
          - condition: '${arenaState == "SUCCEEDED" or (arenaSucceededCount != null and arenaSucceededCount > 0)}'
            next: log_arena_complete
        next: wait_arena_poll

    - wait_arena_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_arena

    - log_arena_complete:
        assign:
          - arenaEndTime: '${time.format(sys.now())}'
          - arenaDurationSeconds: '${time.parse(arenaEndTime) - time.parse(arenaStartTime)}'
          - arenaTimeoutUsageRatio: '${arenaDurationSeconds / arenaTimeoutSeconds}'
          - arenaTimedOut: '${arenaDurationSeconds >= arenaTimeoutSeconds}'
        next: emit_arena_metrics_complete

    - emit_arena_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "arena-export-pipeline"
            job: ${arenaJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${arenaTimeoutSeconds}
            duration_seconds: ${arenaDurationSeconds}
            timeout_usage_ratio: ${arenaTimeoutUsageRatio}
            timed_out: ${arenaTimedOut}
            status: "SUCCEEDED"
            execution_name: ${arenaExecutionName}
            start_time: ${arenaStartTime}
            end_time: ${arenaEndTime}
          severity: "INFO"
        next: log_arena_complete_message

    - log_arena_complete_message:
        call: sys.log
        args:
          text: '${"Arena export completed for scene " + sceneId + " - affordances detected and Arena format generated"}'
          severity: "INFO"
        next: done

    - arena_failed:
        # Arena export failure is non-fatal - scene is still usable without Arena format
        assign:
          - arenaEndTime: '${time.format(sys.now())}'
          - arenaDurationSeconds: '${time.parse(arenaEndTime) - time.parse(arenaStartTime)}'
          - arenaTimeoutUsageRatio: '${arenaDurationSeconds / arenaTimeoutSeconds}'
          - arenaTimedOut: '${arenaDurationSeconds >= arenaTimeoutSeconds}'
        next: emit_arena_metrics_failed

    - emit_arena_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "arena-export-pipeline"
            job: ${arenaJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${arenaTimeoutSeconds}
            duration_seconds: ${arenaDurationSeconds}
            timeout_usage_ratio: ${arenaTimeoutUsageRatio}
            timed_out: ${arenaTimedOut}
            status: "FAILED"
            execution_name: ${arenaExecutionName}
            start_time: ${arenaStartTime}
            end_time: ${arenaEndTime}
          severity: "WARNING"
        next: log_arena_failed_message

    - log_arena_failed_message:
        call: sys.log
        args:
          text: '${"WARNING: Arena export failed for scene " + sceneId + " - scene is still usable but without Arena evaluation support"}'
          severity: "WARNING"
        next: done_without_arena

    # =========================================================================
    # Completion
    # =========================================================================

    - done:
        return:
          status: "SUCCESS"
          scene_id: ${sceneId}
          message: '${"Arena export completed for scene " + sceneId}'
          trigger_source: ${triggerSource}
          arena_execution: ${arenaExec.name}
          outputs:
            arena_manifest: '${"scenes/" + sceneId + "/arena/arena_manifest.json"}'
            scene_module: '${"scenes/" + sceneId + "/arena/scene_module.py"}'
            tasks_dir: '${"scenes/" + sceneId + "/arena/tasks/"}'
            hub_config: '${"scenes/" + sceneId + "/arena/hub_config.yaml"}'
            asset_registry: '${"scenes/" + sceneId + "/arena/asset_registry.json"}'

    - done_without_arena:
        return:
          status: "PARTIAL_SUCCESS"
          scene_id: ${sceneId}
          message: '${"Arena export FAILED for scene " + sceneId + " - scene is available but without Arena evaluation support"}'
          failure_details: "Arena export failed - scene is still usable for simulation but lacks Arena-specific affordances and evaluation infrastructure"
          trigger_source: ${triggerSource}
          arena_execution: ${arenaExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'

    - skip:
        return:
          status: "SKIPPED"
          message: '${"Not an Arena trigger marker file: " + object}'
