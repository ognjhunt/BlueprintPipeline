# dream2flow-preparation-pipeline.yaml
#
# Google Cloud Workflows pipeline that:
#   1. Triggers on completion marker file from regen3d-job (.regen3d_complete)
#   2. Runs dream2flow-preparation-job to generate Dream2Flow bundles
#   3. Writes .dream2flow_complete marker when finished
#   4. Optionally runs dream2flow-inference-job for full pipeline
#
# Trigger: Cloud Storage object finalized event for .regen3d_complete
#
# NOTE: This pipeline runs in parallel with usd-assembly-pipeline and dwm-preparation-pipeline
# (all trigger on the same .regen3d_complete marker). This is safe because:
# - Each pipeline writes to different output prefixes (dream2flow/*, usd/*, dwm/*)
# - No shared state is modified
# - Idempotency checks prevent duplicate processing
#
# Dream2Flow (arXiv:2512.24766) pipeline:
#   - Input: RGB-D observation + language instruction
#   - Video generation: Generate "dreamed" task execution video
#   - Flow extraction: Extract 3D object flow (masks, depth, point tracking)
#   - Robot control: Use flow as goal/reward for trajectory optimization or RL
#
# Reference: https://arxiv.org/abs/2512.24766
#
# EventArc Setup:
#   gcloud eventarc triggers create dream2flow-preparation-trigger \
#     --location=us-central1 \
#     --service-account="${WORKFLOW_SA}@${PROJECT_ID}.iam.gserviceaccount.com" \
#     --destination-workflow=dream2flow-preparation-pipeline \
#     --destination-workflow-location=us-central1 \
#     --event-filters="type=google.cloud.storage.object.v1.finalized" \
#     --event-filters="bucket=${BUCKET}" \
#     --event-data-content-type="application/json"

main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - primaryRegion: ${default(sys.get_env("PRIMARY_WORKFLOW_REGION"), "us-central1")}
          - secondaryRegion: ${default(sys.get_env("SECONDARY_WORKFLOW_REGION"), "us-east1")}
          - region: ${primaryRegion}
        next: filter_completion_markers

    # Filter for .regen3d_complete marker files
    # This runs in parallel with other pipelines on the same trigger
    - filter_completion_markers:
        switch:
          - condition: '${text.match_regex(object, "^scenes/.+/assets/\\.regen3d_complete$")}'
            next: derive
        next: skip

    - derive:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - dream2flowPrefix: '${"scenes/" + sceneId + "/dream2flow"}'
          - lockObject: '${"scenes/" + sceneId + "/locks/regen3d-prep.lock"}'
          - dream2flowJobName: "dream2flow-preparation-job"
          # Explicitly set to the Cloud Run default for consistency/metrics.
          - dream2flowTimeoutSeconds: 3600
          - dream2flowCompleteMarker: '${"scenes/" + sceneId + "/dream2flow/.dream2flow_complete"}'
          - dream2flowInferenceJobName: "dream2flow-inference-job"
          # Explicitly set to the Cloud Run default for consistency/metrics.
          - dream2flowInferenceTimeoutSeconds: 3600
          - dream2flowInferenceCompleteMarker: '${"scenes/" + sceneId + "/dream2flow/.dream2flow_inference_complete"}'
          - dream2flowFailedMarker: '${"scenes/" + sceneId + "/dream2flow/.failed"}'
          - dream2flowLegacyFailedMarker: '${"scenes/" + sceneId + "/dream2flow/.dream2flow_failed"}'
          - dream2flowInferenceFailedMarker: '${"scenes/" + sceneId + "/dream2flow/.failed"}'
          - dream2flowInferenceLegacyFailedMarker: '${"scenes/" + sceneId + "/dream2flow/.dream2flow_inference_failed"}'
        next: init_region_health

    - init_region_health:
        assign:
          - primaryHealthy: false
          - secondaryHealthy: false
        next: check_primary_region

    - check_primary_region:
        try:
          call: googleapis.run.v1.projects.locations.jobs.get
          args:
            name: '${"projects/" + projectId + "/locations/" + primaryRegion + "/jobs/" + dream2flowJobName}'
          result: primaryJob
        next: mark_primary_healthy
        except:
          as: primaryError
          steps:
            - log_primary_unhealthy:
                call: sys.log
                args:
                  text: '${"Primary region " + primaryRegion + " job " + dream2flowJobName + " unavailable: " + primaryError.message}'
                  severity: "WARNING"
            - check_secondary_region:
                try:
                  call: googleapis.run.v1.projects.locations.jobs.get
                  args:
                    name: '${"projects/" + projectId + "/locations/" + secondaryRegion + "/jobs/" + dream2flowJobName}'
                  result: secondaryJob
                next: mark_secondary_healthy
                except:
                  as: secondaryError
                  steps:
                    - log_secondary_unhealthy:
                        call: sys.log
                        args:
                          text: '${"Secondary region " + secondaryRegion + " job " + dream2flowJobName + " unavailable: " + secondaryError.message}'
                          severity: "ERROR"
                    - select_region

    - mark_primary_healthy:
        assign:
          - primaryHealthy: true
        next: select_region

    - mark_secondary_healthy:
        assign:
          - secondaryHealthy: true
        next: select_region

    - select_region:
        switch:
          - condition: ${primaryHealthy}
            next: use_primary_region
          - condition: ${secondaryHealthy}
            next: use_secondary_region
        next: use_primary_region

    - use_primary_region:
        assign:
          - region: ${primaryRegion}
        next: acquire_lock

    - use_secondary_region:
        assign:
          - region: ${secondaryRegion}
        next: acquire_lock

    - acquire_lock:
        try:
          call: googleapis.storage.v1.objects.insert
          args:
            bucket: ${bucket}
            name: ${lockObject}
            ifGenerationMatch: 0
            uploadType: "media"
            body: ${json.encode({
              "scene_id": sceneId,
              "workflow": "dream2flow-preparation-pipeline",
              "lock": "regen3d-prep",
              "timestamp": time.format(sys.now()),
              "execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID")
            })}
        except:
          as: e
          steps:
            - lock_exists_check:
                switch:
                  - condition: '${e.code == 409 or e.code == 412}'
                    next: log_lock_exists
                next: raise_lock_error
        next: log_lock_acquired

    - log_lock_exists:
        call: sys.log
        args:
          text: '${"Lock already exists for scene " + sceneId + " at " + lockObject + " - skipping"}'
          severity: "INFO"
        next: skip_locked

    - raise_lock_error:
        raise: ${e}

    - log_lock_acquired:
        call: sys.log
        args:
          text: '${"Acquired lock for scene " + sceneId + " at " + lockObject}'
          severity: "INFO"
        next: check_already_processed

    # Check if Dream2Flow bundles already generated (idempotence)
    - check_already_processed:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${dream2flowCompleteMarker}
          result: existingMarker
        except:
          as: e
          steps:
            - check_not_found:
                switch:
                  - condition: '${e.code == 404}'
                    next: log_start
                next: raise_check_error
        next: skip_already_processed

    - skip_already_processed:
        call: sys.log
        args:
          text: '${"Dream2Flow bundles already generated for scene " + sceneId + " - skipping"}'
          severity: "INFO"
        next: release_lock_before_skip

    - raise_check_error:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_check_error_final

    - raise_check_error_final:
        raise: '${e}'

    - log_start:
        call: sys.log
        args:
          text: '${"Dream2Flow preparation triggered for scene " + sceneId}'
          severity: "INFO"
        next: init_dream2flow_metrics

    - init_dream2flow_metrics:
        assign:
          - dream2flowStartTime: '${time.format(sys.now())}'
        next: emit_dream2flow_metrics_start

    - emit_dream2flow_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "dream2flow-preparation-pipeline"
            job: ${dream2flowJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${dream2flowTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${dream2flowStartTime}
          severity: "INFO"
        next: run_dream2flow_job

    # Run the Dream2Flow preparation job
    - run_dream2flow_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + dream2flowJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: DREAM2FLOW_PREFIX
                        value: ${dream2flowPrefix}
                      - name: NUM_TASKS
                        value: "5"
                      - name: RESOLUTION_WIDTH
                        value: "720"
                      - name: RESOLUTION_HEIGHT
                        value: "480"
                      - name: NUM_FRAMES
                        value: "49"
                      - name: FPS
                        value: "24"
                      - name: ROBOT
                        value: "franka_panda"
              timeout: '${string(dream2flowTimeoutSeconds) + "s"}'
          result: dream2flowExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_dream2flow_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "dream2flow-preparation-pipeline"
                    job: ${dream2flowJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - capture_dream2flow_failure_metrics:
                assign:
                  - dream2flowEndTime: '${time.format(sys.now())}'
                  - dream2flowDurationSeconds: '${time.parse(dream2flowEndTime) - time.parse(dream2flowStartTime)}'
                  - dream2flowTimeoutUsageRatio: '${dream2flowDurationSeconds / dream2flowTimeoutSeconds}'
                  - dream2flowTimedOut: '${dream2flowDurationSeconds >= dream2flowTimeoutSeconds}'
            - emit_dream2flow_metrics_failed:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_invocation"
                    event: "complete"
                    workflow: "dream2flow-preparation-pipeline"
                    job: ${dream2flowJobName}
                    scene_id: ${sceneId}
                    timeout_seconds: ${dream2flowTimeoutSeconds}
                    duration_seconds: ${dream2flowDurationSeconds}
                    timeout_usage_ratio: ${dream2flowTimeoutUsageRatio}
                    timed_out: ${dream2flowTimedOut}
                    status: "FAILED"
                    start_time: ${dream2flowStartTime}
                    end_time: ${dream2flowEndTime}
                  severity: "ERROR"
            - log_dream2flow_job_error:
                call: sys.log
                args:
                  text: '${"Failed to start Dream2Flow job after retries: " + e.message}'
                  severity: "ERROR"
            - list_dream2flow_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${dream2flowPrefix + "/"}
                  maxResults: 1000
                result: dream2flowCleanupList
            - delete_dream2flow_outputs_for_cleanup:
                for:
                  value: dream2flowCleanupItem
                  in: ${default(dream2flowCleanupList.items, [])}
                  steps:
                    - delete_dream2flow_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${dream2flowCleanupItem.name}
            - write_dream2flow_start_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${dream2flowFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": dream2flowJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "dream2flow_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "dream2flow_prefix": dream2flowPrefix
                      }
                    }
                  })}
            - release_lock_after_dream2flow_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_dream2flow_job_error:
                raise: ${e}
        next: set_dream2flow_execution_name

    - set_dream2flow_execution_name:
        assign:
          - dream2flowExecutionName: '${if(dream2flowExec.metadata != null and dream2flowExec.metadata.name != null, dream2flowExec.metadata.name, dream2flowExec.name)}'
        next: wait_for_dream2flow

    # Poll for job completion
    - wait_for_dream2flow:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${dream2flowExecutionName}
        result: dream2flowStatus
        next: check_dream2flow_status

    - check_dream2flow_status:
        assign:
          - dream2flowState: '${if(dream2flowStatus.state != null, dream2flowStatus.state, if(dream2flowStatus.status != null, dream2flowStatus.status.state, null))}'
          - dream2flowFailedCount: '${if(dream2flowStatus.failedCount != null, dream2flowStatus.failedCount, if(dream2flowStatus.status != null, dream2flowStatus.status.failedCount, null))}'
          - dream2flowSucceededCount: '${if(dream2flowStatus.succeededCount != null, dream2flowStatus.succeededCount, if(dream2flowStatus.status != null, dream2flowStatus.status.succeededCount, null))}'
        next: dream2flow_status_switch

    - dream2flow_status_switch:
        switch:
          - condition: '${dream2flowState == "FAILED" or (dream2flowFailedCount != null and dream2flowFailedCount > 0)}'
            next: dream2flow_failed
          - condition: '${dream2flowState == "SUCCEEDED" or (dream2flowSucceededCount != null and dream2flowSucceededCount > 0)}'
            next: log_dream2flow_complete
        next: wait_dream2flow_poll

    - wait_dream2flow_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_dream2flow

    - log_dream2flow_complete:
        assign:
          - dream2flowEndTime: '${time.format(sys.now())}'
          - dream2flowDurationSeconds: '${time.parse(dream2flowEndTime) - time.parse(dream2flowStartTime)}'
          - dream2flowTimeoutUsageRatio: '${dream2flowDurationSeconds / dream2flowTimeoutSeconds}'
          - dream2flowTimedOut: '${dream2flowDurationSeconds >= dream2flowTimeoutSeconds}'
        next: emit_dream2flow_metrics_complete

    - emit_dream2flow_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "dream2flow-preparation-pipeline"
            job: ${dream2flowJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${dream2flowTimeoutSeconds}
            duration_seconds: ${dream2flowDurationSeconds}
            timeout_usage_ratio: ${dream2flowTimeoutUsageRatio}
            timed_out: ${dream2flowTimedOut}
            status: "SUCCEEDED"
            start_time: ${dream2flowStartTime}
            end_time: ${dream2flowEndTime}
          severity: "INFO"
        next: log_dream2flow_complete_message

    - log_dream2flow_complete_message:
        call: sys.log
        args:
          text: '${"Dream2Flow preparation completed for scene " + sceneId}'
          severity: "INFO"
        next: write_completion_marker

    # Write completion marker for downstream processes
    - write_completion_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${dream2flowCompleteMarker}
          uploadType: "media"
          body: '${"{\"scene_id\": \"" + sceneId + "\", \"status\": \"completed\", \"timestamp\": \"" + time.format(sys.now()) + "\"}"}'
        result: markerResult
        next: log_inference_start

    - log_inference_start:
        call: sys.log
        args:
          text: '${"Starting Dream2Flow inference for scene " + sceneId}'
          severity: "INFO"
        next: init_dream2flow_inference_metrics

    - init_dream2flow_inference_metrics:
        assign:
          - dream2flowInferenceStartTime: '${time.format(sys.now())}'
        next: emit_dream2flow_inference_metrics_start

    - emit_dream2flow_inference_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "dream2flow-preparation-pipeline"
            job: ${dream2flowInferenceJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${dream2flowInferenceTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${dream2flowInferenceStartTime}
          severity: "INFO"
        next: run_dream2flow_inference_job

    # Run the Dream2Flow inference job
    - run_dream2flow_inference_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + dream2flowInferenceJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: DREAM2FLOW_PREFIX
                        value: ${dream2flowPrefix}
              timeout: '${string(dream2flowInferenceTimeoutSeconds) + "s"}'
          result: dream2flowInferenceExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_dream2flow_inference_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "dream2flow-preparation-pipeline"
                    job: ${dream2flowInferenceJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - capture_dream2flow_inference_failure_metrics:
                assign:
                  - dream2flowInferenceEndTime: '${time.format(sys.now())}'
                  - dream2flowInferenceDurationSeconds: '${time.parse(dream2flowInferenceEndTime) - time.parse(dream2flowInferenceStartTime)}'
                  - dream2flowInferenceTimeoutUsageRatio: '${dream2flowInferenceDurationSeconds / dream2flowInferenceTimeoutSeconds}'
                  - dream2flowInferenceTimedOut: '${dream2flowInferenceDurationSeconds >= dream2flowInferenceTimeoutSeconds}'
            - emit_dream2flow_inference_metrics_failed:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_invocation"
                    event: "complete"
                    workflow: "dream2flow-preparation-pipeline"
                    job: ${dream2flowInferenceJobName}
                    scene_id: ${sceneId}
                    timeout_seconds: ${dream2flowInferenceTimeoutSeconds}
                    duration_seconds: ${dream2flowInferenceDurationSeconds}
                    timeout_usage_ratio: ${dream2flowInferenceTimeoutUsageRatio}
                    timed_out: ${dream2flowInferenceTimedOut}
                    status: "FAILED"
                    start_time: ${dream2flowInferenceStartTime}
                    end_time: ${dream2flowInferenceEndTime}
                  severity: "ERROR"
            - log_dream2flow_inference_job_error:
                call: sys.log
                args:
                  text: '${"Failed to start Dream2Flow inference job after retries: " + e.message}'
                  severity: "ERROR"
            - list_dream2flow_inference_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${dream2flowPrefix + "/"}
                  maxResults: 1000
                result: dream2flowInferenceCleanupList
            - delete_dream2flow_inference_outputs_for_cleanup:
                for:
                  value: dream2flowInferenceCleanupItem
                  in: ${default(dream2flowInferenceCleanupList.items, [])}
                  steps:
                    - delete_dream2flow_inference_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${dream2flowInferenceCleanupItem.name}
            - write_dream2flow_inference_start_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${dream2flowInferenceFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": dream2flowInferenceJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "dream2flow_inference_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "dream2flow_prefix": dream2flowPrefix
                      }
                    }
                  })}
            - release_lock_after_dream2flow_inference_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_dream2flow_inference_job_error:
                raise: ${e}
        next: set_dream2flow_inference_execution_name

    - set_dream2flow_inference_execution_name:
        assign:
          - dream2flowInferenceExecutionName: '${if(dream2flowInferenceExec.metadata != null and dream2flowInferenceExec.metadata.name != null, dream2flowInferenceExec.metadata.name, dream2flowInferenceExec.name)}'
        next: wait_for_dream2flow_inference

    - wait_for_dream2flow_inference:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${dream2flowInferenceExecutionName}
        result: dream2flowInferenceStatus
        next: check_dream2flow_inference_status

    - check_dream2flow_inference_status:
        assign:
          - dream2flowInferenceState: '${if(dream2flowInferenceStatus.state != null, dream2flowInferenceStatus.state, if(dream2flowInferenceStatus.status != null, dream2flowInferenceStatus.status.state, null))}'
          - dream2flowInferenceFailedCount: '${if(dream2flowInferenceStatus.failedCount != null, dream2flowInferenceStatus.failedCount, if(dream2flowInferenceStatus.status != null, dream2flowInferenceStatus.status.failedCount, null))}'
          - dream2flowInferenceSucceededCount: '${if(dream2flowInferenceStatus.succeededCount != null, dream2flowInferenceStatus.succeededCount, if(dream2flowInferenceStatus.status != null, dream2flowInferenceStatus.status.succeededCount, null))}'
        next: dream2flow_inference_status_switch

    - dream2flow_inference_status_switch:
        switch:
          - condition: '${dream2flowInferenceState == "FAILED" or (dream2flowInferenceFailedCount != null and dream2flowInferenceFailedCount > 0)}'
            next: dream2flow_inference_failed
          - condition: '${dream2flowInferenceState == "SUCCEEDED" or (dream2flowInferenceSucceededCount != null and dream2flowInferenceSucceededCount > 0)}'
            next: log_dream2flow_inference_complete
        next: wait_inference_poll

    - wait_inference_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_dream2flow_inference

    - log_dream2flow_inference_complete:
        assign:
          - dream2flowInferenceEndTime: '${time.format(sys.now())}'
          - dream2flowInferenceDurationSeconds: '${time.parse(dream2flowInferenceEndTime) - time.parse(dream2flowInferenceStartTime)}'
          - dream2flowInferenceTimeoutUsageRatio: '${dream2flowInferenceDurationSeconds / dream2flowInferenceTimeoutSeconds}'
          - dream2flowInferenceTimedOut: '${dream2flowInferenceDurationSeconds >= dream2flowInferenceTimeoutSeconds}'
        next: emit_dream2flow_inference_metrics_complete

    - emit_dream2flow_inference_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "dream2flow-preparation-pipeline"
            job: ${dream2flowInferenceJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${dream2flowInferenceTimeoutSeconds}
            duration_seconds: ${dream2flowInferenceDurationSeconds}
            timeout_usage_ratio: ${dream2flowInferenceTimeoutUsageRatio}
            timed_out: ${dream2flowInferenceTimedOut}
            status: "SUCCEEDED"
            start_time: ${dream2flowInferenceStartTime}
            end_time: ${dream2flowInferenceEndTime}
          severity: "INFO"
        next: log_dream2flow_inference_complete_message

    - log_dream2flow_inference_complete_message:
        call: sys.log
        args:
          text: '${"Dream2Flow inference completed for scene " + sceneId}'
          severity: "INFO"
        next: write_inference_completion_marker

    - write_inference_completion_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${dream2flowInferenceCompleteMarker}
          uploadType: "media"
          body: '${"{\"scene_id\": \"" + sceneId + "\", \"status\": \"completed\", \"timestamp\": \"" + time.format(sys.now()) + "\"}"}'
        next: release_lock_before_done

    - dream2flow_inference_failed:
        assign:
          - dream2flowInferenceEndTime: '${time.format(sys.now())}'
          - dream2flowInferenceDurationSeconds: '${time.parse(dream2flowInferenceEndTime) - time.parse(dream2flowInferenceStartTime)}'
          - dream2flowInferenceTimeoutUsageRatio: '${dream2flowInferenceDurationSeconds / dream2flowInferenceTimeoutSeconds}'
          - dream2flowInferenceTimedOut: '${dream2flowInferenceDurationSeconds >= dream2flowInferenceTimeoutSeconds}'
        next: emit_dream2flow_inference_metrics_failed_from_status

    - emit_dream2flow_inference_metrics_failed_from_status:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "dream2flow-preparation-pipeline"
            job: ${dream2flowInferenceJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${dream2flowInferenceTimeoutSeconds}
            duration_seconds: ${dream2flowInferenceDurationSeconds}
            timeout_usage_ratio: ${dream2flowInferenceTimeoutUsageRatio}
            timed_out: ${dream2flowInferenceTimedOut}
            status: "FAILED"
            start_time: ${dream2flowInferenceStartTime}
            end_time: ${dream2flowInferenceEndTime}
          severity: "ERROR"
        next: log_dream2flow_inference_failed_message

    - log_dream2flow_inference_failed_message:
        call: sys.log
        args:
          text: '${"WARNING: Dream2Flow inference failed for scene " + sceneId}'
          severity: "WARNING"
        next: read_inference_failure_marker

    - read_inference_failure_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${dream2flowInferenceFailedMarker}
            alt: "media"
          result: dream2flowInferenceFailurePayload
        except:
          as: e
          steps:
            - handle_missing_dream2flow_inference_marker:
                switch:
                  - condition: '${e.code == 404}'
                    next: write_inference_failure_marker
                next: log_dream2flow_inference_marker_read_error
        next: log_dream2flow_inference_marker_payload

    - log_dream2flow_inference_marker_read_error:
        call: sys.log
        args:
          text: '${"Failed to read .failed inference marker for Dream2Flow in scene " + sceneId + ": " + e.message}'
          severity: "WARNING"
        next: write_inference_failure_marker

    - log_dream2flow_inference_marker_payload:
        call: sys.log
        args:
          text: '${"Dream2Flow inference failure marker payload for scene " + sceneId + ": " + dream2flowInferenceFailurePayload}'
          severity: "ERROR"
        next: write_inference_legacy_failure_marker

    - write_inference_failure_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${dream2flowInferenceFailedMarker}
          uploadType: "media"
          body: ${json.encode({
            "scene_id": sceneId,
            "job_name": dream2flowInferenceJobName,
            "status": "failed",
            "timestamp": time.format(sys.now()),
            "error": {
              "code": "dream2flow_inference_failed",
              "message": "Dream2Flow inference failed",
              "type": "workflow_failure",
              "stack_trace": null
            },
            "context": {
              "execution_id": dream2flowInferenceExecutionName,
              "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
              "attempt_number": 1,
              "config_context": {
                "dream2flow_prefix": dream2flowPrefix
              }
            },
            "input_params": {
              "scene_id": sceneId,
              "bucket": bucket
            }
          })}
        next: write_inference_legacy_failure_marker

    - write_inference_legacy_failure_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${dream2flowInferenceLegacyFailedMarker}
          uploadType: "media"
          body: '${"{\"scene_id\": \"" + sceneId + "\", \"status\": \"failed\", \"timestamp\": \"" + time.format(sys.now()) + "\"}"}'
        next: release_lock_before_done_with_failure

    - dream2flow_failed:
        # Dream2Flow failure is non-fatal - scene is still usable for other purposes
        assign:
          - dream2flowEndTime: '${time.format(sys.now())}'
          - dream2flowDurationSeconds: '${time.parse(dream2flowEndTime) - time.parse(dream2flowStartTime)}'
          - dream2flowTimeoutUsageRatio: '${dream2flowDurationSeconds / dream2flowTimeoutSeconds}'
          - dream2flowTimedOut: '${dream2flowDurationSeconds >= dream2flowTimeoutSeconds}'
        next: emit_dream2flow_metrics_failed_from_status

    - emit_dream2flow_metrics_failed_from_status:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "dream2flow-preparation-pipeline"
            job: ${dream2flowJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${dream2flowTimeoutSeconds}
            duration_seconds: ${dream2flowDurationSeconds}
            timeout_usage_ratio: ${dream2flowTimeoutUsageRatio}
            timed_out: ${dream2flowTimedOut}
            status: "FAILED"
            start_time: ${dream2flowStartTime}
            end_time: ${dream2flowEndTime}
          severity: "ERROR"
        next: log_dream2flow_failed_message

    - log_dream2flow_failed_message:
        call: sys.log
        args:
          text: '${"WARNING: Dream2Flow preparation failed for scene " + sceneId + " - scene still usable for simulation"}'
          severity: "WARNING"
        next: read_failure_marker

    - read_failure_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${dream2flowFailedMarker}
            alt: "media"
          result: dream2flowFailurePayload
        except:
          as: e
          steps:
            - handle_missing_dream2flow_failure_marker:
                switch:
                  - condition: '${e.code == 404}'
                    next: write_failure_marker
                next: log_dream2flow_failure_marker_read_error
        next: log_dream2flow_failure_marker_payload

    - log_dream2flow_failure_marker_read_error:
        call: sys.log
        args:
          text: '${"Failed to read .failed marker for Dream2Flow in scene " + sceneId + ": " + e.message}'
          severity: "WARNING"
        next: write_failure_marker

    - log_dream2flow_failure_marker_payload:
        call: sys.log
        args:
          text: '${"Dream2Flow failure marker payload for scene " + sceneId + ": " + dream2flowFailurePayload}'
          severity: "ERROR"
        next: write_legacy_failure_marker

    - write_failure_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${dream2flowFailedMarker}
          uploadType: "media"
          body: ${json.encode({
            "scene_id": sceneId,
            "job_name": dream2flowJobName,
            "status": "failed",
            "timestamp": time.format(sys.now()),
            "error": {
              "code": "dream2flow_failed",
              "message": "Dream2Flow preparation failed",
              "type": "workflow_failure",
              "stack_trace": null
            },
            "context": {
              "execution_id": dream2flowExecutionName,
              "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
              "attempt_number": 1,
              "config_context": {
                "dream2flow_prefix": dream2flowPrefix
              }
            },
            "input_params": {
              "scene_id": sceneId,
              "bucket": bucket
            }
          })}
        result: failMarkerResult
        next: write_legacy_failure_marker

    - write_legacy_failure_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${dream2flowLegacyFailedMarker}
          uploadType: "media"
          body: '${"{\"scene_id\": \"" + sceneId + "\", \"status\": \"failed\", \"timestamp\": \"" + time.format(sys.now()) + "\"}"}'
        result: legacyFailMarkerResult
        next: release_lock_before_done_with_failure

    - release_lock_before_done:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: done

    - release_lock_before_done_with_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: done_with_failure

    - release_lock_before_skip:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: skip

    # =========================================================================
    # Completion
    # =========================================================================

    - done:
        return:
          status: "SUCCESS"
          scene_id: ${sceneId}
          message: '${"Dream2Flow preparation and inference completed for scene " + sceneId}'
          dream2flow_execution: ${dream2flowExec.name}
          outputs:
            dream2flow_bundles: '${"scenes/" + sceneId + "/dream2flow/"}'
            completion_marker: ${dream2flowCompleteMarker}
            inference_marker: ${dream2flowInferenceCompleteMarker}

    - done_with_failure:
        return:
          status: "FAILED"
          scene_id: ${sceneId}
          message: '${"Dream2Flow preparation failed for scene " + sceneId}'
          dream2flow_execution: ${dream2flowExec.name}

    - skip_locked:
        return:
          status: "SKIPPED"
          scene_id: ${sceneId}
          message: '${"Lock already exists for scene " + sceneId + " at " + lockObject}'

    - skip:
        return:
          status: "SKIPPED"
          message: '${"Not a completion marker file: " + object}'
