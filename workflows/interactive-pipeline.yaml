main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}
          - region: "us-central1"
        next: filter_scene_assets

    # Trigger only when scene_assets.json is created by assets-plan.
    - filter_scene_assets:
        switch:
          - condition: ${text.match_regex(object, "^scenes/.+/assets/scene_assets\\.json$")}
            next: derive
        next: skip

    - derive:
        assign:
          - parts: ${text.split(object, "/")}
          - sceneId: ${parts[1]}
          - multiviewPrefix: ${"scenes/" + sceneId + "/multiview"}
          - assetsPrefix: ${"scenes/" + sceneId + "/assets"}
          - layoutPrefix: ${"scenes/" + sceneId + "/layout"}
          # NOTE: Set PARTICULATE_ENDPOINT environment variable for articulation detection.
          # Falls back to heuristic detection if not available.
          - particulateEndpoint: ${default(sys.get_env("PARTICULATE_ENDPOINT"), "")}
          - disallowPlaceholderUrdf: ${default(sys.get_env("DISALLOW_PLACEHOLDER_URDF"), "false")}
          - articulationBackend: ${if(particulateEndpoint != "", "particulate", "heuristic")}
          - jobName: "interactive-job"
          - simreadyJobName: "simready-job"
          # Explicit override: 30 minutes for interactive processing.
          - interactiveTimeoutSeconds: 1800
          - interactiveFailedMarker: ${"scenes/" + sceneId + "/assets/.failed"}
        next: log_articulation_mode

    - log_articulation_mode:
        call: sys.log
        args:
          text: ${"Using " + articulationBackend + " backend for articulation detection in scene " + sceneId}
          severity: "INFO"
        next: init_interactive_metrics

    - init_interactive_metrics:
        assign:
          - interactiveStartTime: '${time.format(sys.now())}'
        next: emit_interactive_metrics_start

    - emit_interactive_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "interactive-pipeline"
            job: ${jobName}
            scene_id: ${sceneId}
            timeout_seconds: ${interactiveTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${interactiveStartTime}
          severity: "INFO"
        next: run_interactive_job

    - run_interactive_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: ${"projects/" + projectId + "/locations/" + region + "/jobs/" + jobName}
            body:
              overrides:
                containerOverrides:
                  - name: "interactive"
                    env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: MULTIVIEW_PREFIX
                        value: ${multiviewPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: LAYOUT_PREFIX
                        value: ${layoutPrefix}
                      - name: ARTICULATION_BACKEND
                        value: ${articulationBackend}
                      - name: PARTICULATE_ENDPOINT
                        value: ${particulateEndpoint}
                      - name: DISALLOW_PLACEHOLDER_URDF
                        value: ${disallowPlaceholderUrdf}
                timeout: '${string(interactiveTimeoutSeconds) + "s"}'
          result: interactiveJobExecution
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_interactive_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "interactive-pipeline"
                    job: ${jobName}
                    scene_id: ${sceneId}
                    retry_max: 3
                    error: ${e.message}
                  severity: "ERROR"
            - capture_interactive_start_failure_metrics:
                assign:
                  - interactiveEndTime: '${time.format(sys.now())}'
                  - interactiveDurationSeconds: '${time.parse(interactiveEndTime) - time.parse(interactiveStartTime)}'
                  - interactiveTimeoutUsageRatio: '${interactiveDurationSeconds / interactiveTimeoutSeconds}'
                  - interactiveTimedOut: '${interactiveDurationSeconds >= interactiveTimeoutSeconds}'
            - emit_interactive_metrics_failed:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_invocation"
                    event: "complete"
                    workflow: "interactive-pipeline"
                    job: ${jobName}
                    scene_id: ${sceneId}
                    timeout_seconds: ${interactiveTimeoutSeconds}
                    duration_seconds: ${interactiveDurationSeconds}
                    timeout_usage_ratio: ${interactiveTimeoutUsageRatio}
                    timed_out: ${interactiveTimedOut}
                    status: "FAILED"
                    start_time: ${interactiveStartTime}
                    end_time: ${interactiveEndTime}
                  severity: "ERROR"
            - log_interactive_error:
                call: sys.log
                args:
                  text: ${"ERROR: Interactive job failed: " + e.message}
                  severity: "ERROR"
            - write_interactive_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${interactiveFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": jobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "interactive_job_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "assets_prefix": assetsPrefix,
                        "layout_prefix": layoutPrefix,
                        "multiview_prefix": multiviewPrefix
                      }
                    }
                  })}
            - next: done_failed
        next: set_interactive_execution_name

    - set_interactive_execution_name:
        assign:
          - interactiveExecutionName: '${if(interactiveJobExecution.metadata != null and interactiveJobExecution.metadata.name != null, interactiveJobExecution.metadata.name, interactiveJobExecution.name)}'
        next: wait_for_interactive_job

    - wait_for_interactive_job:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${interactiveExecutionName}
        result: interactiveStatus
        next: check_interactive_status

    - check_interactive_status:
        assign:
          - interactiveState: '${if(interactiveStatus.state != null, interactiveStatus.state, if(interactiveStatus.status != null, interactiveStatus.status.state, null))}'
          - interactiveFailedCount: '${if(interactiveStatus.failedCount != null, interactiveStatus.failedCount, if(interactiveStatus.status != null, interactiveStatus.status.failedCount, null))}'
          - interactiveSucceededCount: '${if(interactiveStatus.succeededCount != null, interactiveStatus.succeededCount, if(interactiveStatus.status != null, interactiveStatus.status.succeededCount, null))}'
        next: interactive_status_switch

    - interactive_status_switch:
        switch:
          - condition: '${interactiveState == "FAILED" or (interactiveFailedCount != null and interactiveFailedCount > 0)}'
            next: check_interactive_failure
          - condition: '${interactiveState == "SUCCEEDED" or (interactiveSucceededCount != null and interactiveSucceededCount > 0)}'
            next: log_interactive_success
        next: wait_interactive_poll

    - wait_interactive_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_interactive_job

    - check_interactive_failure:
        assign:
          - interactiveEndTime: '${time.format(sys.now())}'
          - interactiveDurationSeconds: '${time.parse(interactiveEndTime) - time.parse(interactiveStartTime)}'
          - interactiveTimeoutUsageRatio: '${interactiveDurationSeconds / interactiveTimeoutSeconds}'
          - interactiveTimedOut: '${interactiveDurationSeconds >= interactiveTimeoutSeconds}'
        next: emit_interactive_metrics_failed_from_status

    - emit_interactive_metrics_failed_from_status:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "interactive-pipeline"
            job: ${jobName}
            scene_id: ${sceneId}
            timeout_seconds: ${interactiveTimeoutSeconds}
            duration_seconds: ${interactiveDurationSeconds}
            timeout_usage_ratio: ${interactiveTimeoutUsageRatio}
            timed_out: ${interactiveTimedOut}
            status: "FAILED"
            start_time: ${interactiveStartTime}
            end_time: ${interactiveEndTime}
          severity: "ERROR"
        next: log_interactive_failed_message

    - log_interactive_failed_message:
        call: sys.log
        args:
          text: ${"Interactive job failed for scene " + sceneId}
          severity: "ERROR"
        next: write_interactive_failure_marker_on_failure

    - write_interactive_failure_marker_on_failure:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${interactiveFailedMarker}
          uploadType: "media"
          body: ${json.encode({
            "scene_id": sceneId,
            "job_name": jobName,
            "status": "failed",
            "timestamp": time.format(sys.now()),
            "error": {
              "code": "interactive_job_failed",
              "message": "Interactive job failed",
              "type": "workflow_failure",
              "stack_trace": null
            },
            "context": {
              "execution_id": interactiveExecutionName,
              "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
              "attempt_number": 1,
              "config_context": {
                "assets_prefix": assetsPrefix,
                "layout_prefix": layoutPrefix,
                "multiview_prefix": multiviewPrefix
              }
            }
          })}
        next: read_interactive_failure_marker

    - read_interactive_failure_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${interactiveFailedMarker}
            alt: "media"
          result: interactiveFailurePayload
        except:
          as: e
          steps:
            - log_interactive_failure_marker_read_error:
                call: sys.log
                args:
                  text: ${"Failed to read .failed marker for interactive job in scene " + sceneId + ": " + e.message}
                  severity: "WARNING"
        next: log_interactive_failure_marker_payload

    - log_interactive_failure_marker_payload:
        call: sys.log
        args:
          text: ${"Interactive failure marker payload for scene " + sceneId + ": " + interactiveFailurePayload}
          severity: "ERROR"
        next: done_failed

    - log_interactive_success:
        assign:
          - interactiveEndTime: '${time.format(sys.now())}'
          - interactiveDurationSeconds: '${time.parse(interactiveEndTime) - time.parse(interactiveStartTime)}'
          - interactiveTimeoutUsageRatio: '${interactiveDurationSeconds / interactiveTimeoutSeconds}'
          - interactiveTimedOut: '${interactiveDurationSeconds >= interactiveTimeoutSeconds}'
        next: emit_interactive_metrics_complete

    - emit_interactive_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "interactive-pipeline"
            job: ${jobName}
            scene_id: ${sceneId}
            timeout_seconds: ${interactiveTimeoutSeconds}
            duration_seconds: ${interactiveDurationSeconds}
            timeout_usage_ratio: ${interactiveTimeoutUsageRatio}
            timed_out: ${interactiveTimedOut}
            status: "SUCCEEDED"
            start_time: ${interactiveStartTime}
            end_time: ${interactiveEndTime}
          severity: "INFO"
        next: log_interactive_success_message

    - log_interactive_success_message:
        call: sys.log
        args:
          text: ${"Interactive job completed successfully for scene " + sceneId}
          severity: "INFO"
        next: create_completion_marker

    - create_completion_marker:
        try:
          call: googleapis.storage.v1.objects.insert
          args:
            bucket: ${bucket}
            uploadType: "media"
            name: ${assetsPrefix + "/.interactive_complete"}
            body: ${"{\\"scene_id\\": \\"" + sceneId + "\\", \\"status\\": \\"completed\\", \\"backend\\": \\"" + articulationBackend + "\\", \\"timestamp\\": \\"" + time.format(sys.now()) + "\\"}" }
          result: markerResult
        except:
          as: e
          steps:
            - log_marker_error:
                call: sys.log
                args:
                  text: ${"ERROR: Failed to create .interactive_complete marker: " + e.message}
                  severity: "ERROR"
        next: log_marker_created

    - log_marker_created:
        call: sys.log
        args:
          text: ${"Created .interactive_complete marker for scene " + sceneId + " (backend: " + articulationBackend + ")"}
          severity: "INFO"
        next: done

    - done:
        return: ${"Interactive pipeline completed for " + object}

    - done_failed:
        return: ${"Interactive + simready pipeline failed for " + object}

    - skip:
        return: ${"interactive skip " + object}
