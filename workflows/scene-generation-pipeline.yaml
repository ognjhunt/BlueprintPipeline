# scene-generation-pipeline.yaml
#
# Google Cloud Workflows pipeline that:
#   1. Triggers scene-generation-job to create new scene images
#   2. Monitors for successful generation
#   3. For each generated scene, triggers the downstream 3D reconstruction pipeline
#
# This workflow can be triggered by:
#   - Cloud Scheduler (daily at 8:00 AM)
#   - Manual invocation via gcloud or API
#   - Other workflows
#
# IMPORTANT: This workflow is NOT automatically scheduled.
# The scheduler (scene-generation-job/scheduler_config.yaml) is paused by default.
# Enable it manually when ready to go live.
#
# To manually trigger:
#   gcloud workflows run scene-generation-pipeline \
#     --location=us-central1 \
#     --data='{"scenes_per_run": 10, "bucket": "your-bucket"}'

main:
  params: [args]
  steps:
    - init:
        assign:
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: "us-central1"
          - bucket: '${default(map.get(args, "bucket"), "blueprint-scenes")}'
          - scenesPerRun: '${default(map.get(args, "scenes_per_run"), 10)}'
          - dryRun: '${default(map.get(args, "dry_run"), false)}'
          - jobName: "scene-generation-job"
          # Explicitly set to the Cloud Run default for consistency/metrics.
          - jobTimeoutSeconds: 3600
          - failedMarkerPath: "scene-generation/.failed"
          - generationOutputPrefix: "scene-generation"
          - startTime: '${time.format(sys.now())}'
        next: log_start

    - log_start:
        call: sys.log
        args:
          text: '${"Scene generation pipeline started - generating " + string(scenesPerRun) + " scenes"}'
          severity: "INFO"
        next: check_dry_run

    - check_dry_run:
        switch:
          - condition: ${dryRun == true}
            next: dry_run_log
        next: init_generation_metrics

    - init_generation_metrics:
        assign:
          - generationStartTime: '${time.format(sys.now())}'
        next: emit_generation_metrics_start

    - emit_generation_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "scene-generation-pipeline"
            job: ${jobName}
            timeout_seconds: ${jobTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${generationStartTime}
          severity: "INFO"
        next: run_generation_job

    - dry_run_log:
        call: sys.log
        args:
          text: "DRY RUN MODE - would generate scenes but skipping actual execution"
          severity: "WARNING"
        next: done_dry_run

    - run_generation_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + jobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENES_PER_RUN
                        value: '${string(scenesPerRun)}'
                      - name: DRY_RUN
                        value: '${if(dryRun, "true", "false")}'
              timeout: '${string(jobTimeoutSeconds) + "s"}'
          result: jobExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_generation_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "scene-generation-pipeline"
                    job: ${jobName}
                    retry_max: 3
                    error: ${e.message}
                  severity: "ERROR"
            - list_generation_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${generationOutputPrefix + "/"}
                  maxResults: 1000
                result: generationCleanupList
            - delete_generation_outputs_for_cleanup:
                for:
                  value: generationCleanupItem
                  in: ${default(generationCleanupList.items, [])}
                  steps:
                    - delete_generation_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${generationCleanupItem.name}
            - write_generation_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${failedMarkerPath}
                  uploadType: "media"
                  body: ${json.encode({
                    "job_name": jobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "scene_generation_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "scenes_per_run": scenesPerRun,
                        "bucket": bucket
                      }
                    }
                  })}
            - raise_generation_start_error:
                raise: ${e}
        next: set_execution_name

    - set_execution_name:
        assign:
          - executionName: '${if(jobExec.metadata != null and jobExec.metadata.name != null, jobExec.metadata.name, jobExec.name)}'
        next: wait_for_generation

    - wait_for_generation:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${executionName}
        result: execStatus
        next: check_generation_status

    - check_generation_status:
        assign:
          - execState: '${if(execStatus.state != null, execStatus.state, if(execStatus.status != null, execStatus.status.state, null))}'
          - failedCount: '${if(execStatus.failedCount != null, execStatus.failedCount, if(execStatus.status != null, execStatus.status.failedCount, null))}'
          - succeededCount: '${if(execStatus.succeededCount != null, execStatus.succeededCount, if(execStatus.status != null, execStatus.status.succeededCount, null))}'
        next: generation_status_switch

    - generation_status_switch:
        switch:
          - condition: '${execState == "FAILED" or (failedCount != null and failedCount > 0)}'
            next: generation_failed
          - condition: '${execState == "SUCCEEDED" or (succeededCount != null and succeededCount > 0)}'
            next: log_generation_complete
        next: wait_generation_poll

    - wait_generation_poll:
        call: sys.sleep
        args:
          seconds: 30
        next: wait_for_generation

    - log_generation_complete:
        assign:
          - generationEndTime: '${time.format(sys.now())}'
          - generationDurationSeconds: '${time.parse(generationEndTime) - time.parse(generationStartTime)}'
          - generationTimeoutUsageRatio: '${generationDurationSeconds / jobTimeoutSeconds}'
          - generationTimedOut: '${generationDurationSeconds >= jobTimeoutSeconds}'
        next: emit_generation_metrics_complete

    - emit_generation_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "scene-generation-pipeline"
            job: ${jobName}
            timeout_seconds: ${jobTimeoutSeconds}
            duration_seconds: ${generationDurationSeconds}
            timeout_usage_ratio: ${generationTimeoutUsageRatio}
            timed_out: ${generationTimedOut}
            status: "SUCCEEDED"
            start_time: ${generationStartTime}
            end_time: ${generationEndTime}
          severity: "INFO"
        next: log_generation_complete_message

    - log_generation_complete_message:
        call: sys.log
        args:
          text: '${"Scene generation job completed successfully"}'
          severity: "INFO"
        next: list_generated_scenes

    - generation_failed:
        assign:
          - generationEndTime: '${time.format(sys.now())}'
          - generationDurationSeconds: '${time.parse(generationEndTime) - time.parse(generationStartTime)}'
          - generationTimeoutUsageRatio: '${generationDurationSeconds / jobTimeoutSeconds}'
          - generationTimedOut: '${generationDurationSeconds >= jobTimeoutSeconds}'
        next: emit_generation_metrics_failed

    - emit_generation_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "scene-generation-pipeline"
            job: ${jobName}
            timeout_seconds: ${jobTimeoutSeconds}
            duration_seconds: ${generationDurationSeconds}
            timeout_usage_ratio: ${generationTimeoutUsageRatio}
            timed_out: ${generationTimedOut}
            status: "FAILED"
            start_time: ${generationStartTime}
            end_time: ${generationEndTime}
          severity: "ERROR"
        next: log_generation_failed_message

    - log_generation_failed_message:
        call: sys.log
        args:
          text: "Scene generation job FAILED"
          severity: "ERROR"
        next: write_generation_failure_marker_on_timeout

    - write_generation_failure_marker_on_timeout:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${failedMarkerPath}
          uploadType: "media"
          body: ${json.encode({
            "job_name": jobName,
            "status": "failed",
            "timestamp": time.format(sys.now()),
            "error": {
              "code": "scene_generation_failed",
              "message": "Scene generation job failed",
              "type": "workflow_failure",
              "stack_trace": null
            },
            "context": {
              "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
              "attempt_number": 1,
              "config_context": {
                "scenes_per_run": scenesPerRun,
                "bucket": bucket
              }
            }
          })}
        next: raise_generation_error

    - raise_generation_error:
        raise: "Scene generation job failed"

    # List newly generated scenes by checking for completion markers
    - list_generated_scenes:
        try:
          call: googleapis.storage.v1.objects.list
          args:
            bucket: ${bucket}
            prefix: "scenes/"
            # Look for recent scene_generation_complete markers
            # In practice, you might filter by timestamp
          result: scenesList
        except:
          as: e
          steps:
            - log_list_error:
                call: sys.log
                args:
                  text: '${"Warning: Could not list scenes: " + e.message}'
                  severity: "WARNING"
                next: done_partial
        next: process_scenes

    - process_scenes:
        # In a real implementation, you would:
        # 1. Filter to only newly generated scenes (by timestamp)
        # 2. For each scene, check if it needs downstream processing
        # 3. Optionally trigger 3D-RE-GEN pipeline for each
        #
        # For now, we just log completion since 3D-RE-GEN integration
        # is handled by the scene generation job writing trigger markers
        call: sys.log
        args:
          text: '${"Scene generation complete. Downstream pipelines will be triggered by completion markers."}'
          severity: "INFO"
        next: done

    # Completion states
    - done:
        return:
          status: "SUCCESS"
          message: '${"Generated " + string(scenesPerRun) + " scenes successfully"}'
          execution: ${executionName}
          bucket: ${bucket}
          started_at: ${startTime}
          completed_at: '${time.format(sys.now())}'

    - done_partial:
        return:
          status: "PARTIAL_SUCCESS"
          message: "Scene generation completed but could not verify all scenes"
          execution: ${executionName}
          bucket: ${bucket}

    - done_dry_run:
        return:
          status: "DRY_RUN"
          message: '${"Would have generated " + string(scenesPerRun) + " scenes"}'
          bucket: ${bucket}

---
# Deployment instructions:
#
# 1. Deploy the workflow:
#    gcloud workflows deploy scene-generation-pipeline \
#      --location=us-central1 \
#      --source=workflows/scene-generation-pipeline.yaml \
#      --service-account=WORKFLOW_SA@PROJECT_ID.iam.gserviceaccount.com
#
# 2. Create the Cloud Run job:
#    gcloud run jobs create scene-generation-job \
#      --image=gcr.io/PROJECT_ID/scene-generation-job:latest \
#      --region=us-central1 \
#      --set-env-vars=GEMINI_API_KEY=your-key \
#      --memory=4Gi \
#      --timeout=3600
#
# 3. Create the scheduler (paused):
#    gcloud scheduler jobs create http scene-generation-daily \
#      --schedule="0 8 * * *" \
#      --location=us-central1 \
#      --uri="https://workflowexecutions.googleapis.com/v1/projects/PROJECT_ID/locations/us-central1/workflows/scene-generation-pipeline/executions" \
#      --http-method=POST \
#      --oauth-service-account-email=SCHEDULER_SA@PROJECT_ID.iam.gserviceaccount.com \
#      --message-body='{"argument": "{\"scenes_per_run\": 10}"}' \
#      --paused
#
# 4. When ready to go live, enable the scheduler:
#    gcloud scheduler jobs resume scene-generation-daily --location=us-central1
