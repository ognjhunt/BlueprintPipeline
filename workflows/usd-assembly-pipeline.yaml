# usd-assembly-pipeline.yaml
#
# Google Cloud Workflows pipeline that:
#   1. Triggers on completion marker file from regen3d-job
#   2. Runs usd-assembly-job in CONVERT_ONLY mode to convert GLB->USDZ before simready
#   3. Runs simready-job to prepare simulation-ready assets (now sees USD-compatible files)
#   4. Runs usd-assembly-job to build scene.usda
#   5. Runs replicator-job to generate Replicator bundle for Isaac Sim domain randomization
#
# Trigger: Cloud Storage object finalized event for .regen3d_complete
#
# 3D-RE-GEN (arXiv:2512.17459) is a modular, compositional pipeline for
# "image â†’ sim-ready 3D reconstruction" with explicit physical constraints.
# Reference: https://3dregen.jdihlmann.com/

main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: "us-central1"
        next: filter_completion_markers

    - filter_completion_markers:
        switch:
          - condition: '${text.match_regex(object, "^scenes/.+/assets/\\.regen3d_complete$")}'
            next: derive
        next: skip

    - derive:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - segPrefix: '${"scenes/" + sceneId + "/seg"}'
          - layoutPrefix: '${"scenes/" + sceneId + "/layout"}'
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - replicatorPrefix: '${"scenes/" + sceneId + "/replicator"}'
          - usdJobName: "usd-assembly-job"
          - replicatorJobName: "replicator-job"
        next: log_start

    - log_start:
        call: sys.log
        args:
          text: '${"USD assembly triggered for scene " + sceneId + " (3D-RE-GEN) - starting pre-simready GLB->USDZ conversion"}'
          severity: "INFO"
        next: run_convert_job

    - run_convert_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + usdJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: LAYOUT_PREFIX
                        value: ${layoutPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: CONVERT_ONLY
                        value: "true"
          result: convertExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_convert_error:
                call: sys.log
                args:
                  text: '${"Failed to start USD convert job after retries: " + e.message}'
                  severity: "ERROR"
            - raise_convert_error:
                raise: ${e}
        next: set_convert_execution_name

    - set_convert_execution_name:
        # jobs.run returns a long-running operation; prefer the execution name from metadata when present
        assign:
          - convertExecutionName: '${if(convertExec.metadata != null and convertExec.metadata.name != null, convertExec.metadata.name, convertExec.name)}'
        next: wait_for_convert

    - wait_for_convert:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${convertExecutionName}
        result: convertStatus
        next: check_convert_status

    - check_convert_status:
        assign:
          - convertState: '${if(convertStatus.state != null, convertStatus.state, if(convertStatus.status != null, convertStatus.status.state, null))}'
          - convertFailedCount: '${if(convertStatus.failedCount != null, convertStatus.failedCount, if(convertStatus.status != null, convertStatus.status.failedCount, null))}'
          - convertSucceededCount: '${if(convertStatus.succeededCount != null, convertStatus.succeededCount, if(convertStatus.status != null, convertStatus.status.succeededCount, null))}'
        next: convert_status_switch

    - convert_status_switch:
        switch:
          - condition: '${convertState == "FAILED" or (convertFailedCount != null and convertFailedCount > 0)}'
            next: convert_failed
          - condition: '${convertState == "SUCCEEDED" or (convertSucceededCount != null and convertSucceededCount > 0)}'
            next: log_convert_complete
        next: wait_convert_poll

    - wait_convert_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_convert

    - log_convert_complete:
        call: sys.log
        args:
          text: '${"GLB->USDZ conversion completed for scene " + sceneId + " - starting simready-job"}'
          severity: "INFO"
        next: run_simready_job

    - convert_failed:
        assign:
          - errorMsg: '${"USD conversion job FAILED for scene " + sceneId}'
        next: log_convert_error

    - log_convert_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: raise_convert_error

    - raise_convert_error:
        raise: ${errorMsg}

    - run_simready_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/simready-job"}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
              timeout: "3600s"  # 1 hour max for simready
        result: simreadyExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_simready_error:
                call: sys.log
                args:
                  text: '${"Failed to start simready job after retries: " + e.message}'
                  severity: "ERROR"
            - raise_simready_error:
                raise: ${e}
        next: init_simready_poll

    - init_simready_poll:
        assign:
          - simreadyAttempts: 0
          - simreadyCompleteObject: '${assetsPrefix + "/.simready_complete"}'
        next: wait_for_simready_complete

    - wait_for_simready_complete:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${simreadyCompleteObject}
          result: simreadyComplete
        except:
          as: e
          steps:
            - simready_poll_switch:
                switch:
                  - condition: ${simreadyAttempts < 90}
                    next: bump_simready_attempt
                next: simready_failed
        next: log_simready_complete

    - bump_simready_attempt:
        assign:
          - simreadyAttempts: ${simreadyAttempts + 1}
        next: sleep_simready_poll

    - sleep_simready_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_simready_complete

    - log_simready_complete:
        call: sys.log
        args:
          text: '${"Simready job completed for scene " + sceneId + " - proceeding with USD assembly"}'
          severity: "INFO"
        next: run_usd_job

    - simready_failed:
        assign:
          - errorMsg: '${"Simready job FAILED for scene " + sceneId + " (missing .simready_complete after " + string(simreadyAttempts) + " checks)"}'
        next: log_simready_error

    - log_simready_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: raise_simready_error

    - raise_simready_error:
        raise: ${errorMsg}

    - run_usd_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + usdJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: LAYOUT_PREFIX
                        value: ${layoutPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
              timeout: "3600s"  # 1 hour max for USD assembly
          result: usdExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_usd_error:
                call: sys.log
                args:
                  text: '${"Failed to start USD job after retries: " + e.message}'
                  severity: "ERROR"
            - raise_usd_error:
                raise: ${e}
        next: set_usd_execution_name

    - set_usd_execution_name:
        # jobs.run returns a long-running operation; prefer the execution name from metadata when present
        assign:
          - usdExecutionName: '${if(usdExec.metadata != null and usdExec.metadata.name != null, usdExec.metadata.name, usdExec.name)}'
        next: wait_for_usd

    - wait_for_usd:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${usdExecutionName}
        result: usdStatus
        next: check_usd_status

    - check_usd_status:
        assign:
          - usdState: '${if(usdStatus.state != null, usdStatus.state, if(usdStatus.status != null, usdStatus.status.state, null))}'
          - usdFailedCount: '${if(usdStatus.failedCount != null, usdStatus.failedCount, if(usdStatus.status != null, usdStatus.status.failedCount, null))}'
          - usdSucceededCount: '${if(usdStatus.succeededCount != null, usdStatus.succeededCount, if(usdStatus.status != null, usdStatus.status.succeededCount, null))}'
        next: usd_status_switch

    - usd_status_switch:
        switch:
          - condition: '${usdState == "FAILED" or (usdFailedCount != null and usdFailedCount > 0)}'
            next: usd_failed
          - condition: '${usdState == "SUCCEEDED" or (usdSucceededCount != null and usdSucceededCount > 0)}'
            next: log_usd_complete
        next: wait_usd_poll

    - wait_usd_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_usd

    - log_usd_complete:
        call: sys.log
        args:
          text: '${"USD assembly completed for scene " + sceneId + " - starting replicator bundle generation"}'
          severity: "INFO"
        next: run_replicator_job

    - usd_failed:
        assign:
          - errorMsg: '${"USD assembly job FAILED for scene " + sceneId}'
        next: log_usd_error

    - log_usd_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: raise_usd_error

    - raise_usd_error:
        raise: ${errorMsg}

    # =========================================================================
    # Replicator Job - Generate domain randomization bundle for Isaac Sim
    # =========================================================================

    - run_replicator_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + replicatorJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: SEG_PREFIX
                        value: ${segPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: REPLICATOR_PREFIX
                        value: ${replicatorPrefix}
              timeout: "1800s"  # 30 minutes max for replicator
          result: replicatorExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_replicator_error:
                call: sys.log
                args:
                  text: '${"Failed to start replicator job after retries: " + e.message}'
                  severity: "ERROR"
            - raise_replicator_error:
                raise: ${e}
        next: set_replicator_execution_name

    - set_replicator_execution_name:
        assign:
          - replicatorExecutionName: '${if(replicatorExec.metadata != null and replicatorExec.metadata.name != null, replicatorExec.metadata.name, replicatorExec.name)}'
        next: wait_for_replicator

    - wait_for_replicator:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${replicatorExecutionName}
        result: replicatorStatus
        next: check_replicator_status

    - check_replicator_status:
        assign:
          - replicatorState: '${if(replicatorStatus.state != null, replicatorStatus.state, if(replicatorStatus.status != null, replicatorStatus.status.state, null))}'
          - replicatorFailedCount: '${if(replicatorStatus.failedCount != null, replicatorStatus.failedCount, if(replicatorStatus.status != null, replicatorStatus.status.failedCount, null))}'
          - replicatorSucceededCount: '${if(replicatorStatus.succeededCount != null, replicatorStatus.succeededCount, if(replicatorStatus.status != null, replicatorStatus.status.succeededCount, null))}'
        next: replicator_status_switch

    - replicator_status_switch:
        switch:
          - condition: '${replicatorState == "FAILED" or (replicatorFailedCount != null and replicatorFailedCount > 0)}'
            next: replicator_failed
          - condition: '${replicatorState == "SUCCEEDED" or (replicatorSucceededCount != null and replicatorSucceededCount > 0)}'
            next: log_replicator_complete
        next: wait_replicator_poll

    - wait_replicator_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_replicator

    - log_replicator_complete:
        call: sys.log
        args:
          text: '${"Replicator bundle generation completed for scene " + sceneId + " - starting Isaac Lab task generation"}'
          severity: "INFO"
        next: run_isaac_lab_job

    - replicator_failed:
        # Replicator failure is non-fatal - scene is still usable without it
        call: sys.log
        args:
          text: '${"WARNING: Replicator job failed for scene " + sceneId + " - proceeding with Isaac Lab generation anyway"}'
          severity: "WARNING"
        next: run_isaac_lab_job

    # =========================================================================
    # Isaac Lab Job - Generate RL training task packages
    # =========================================================================

    - run_isaac_lab_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/isaac-lab-job"}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: REPLICATOR_PREFIX
                        value: ${replicatorPrefix}
                      - name: ISAAC_LAB_PREFIX
                        value: '${"scenes/" + sceneId + "/isaac_lab"}'
              timeout: "1800s"  # 30 minutes max for Isaac Lab task generation
          result: isaacLabExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 30
            multiplier: 2
        except:
          as: e
          steps:
            - log_isaac_lab_error:
                call: sys.log
                args:
                  text: '${"Failed to start Isaac Lab job after retries: " + e.message}'
                  severity: "ERROR"
            - raise_isaac_lab_error:
                raise: ${e}
        next: set_isaac_lab_execution_name

    - set_isaac_lab_execution_name:
        assign:
          - isaacLabExecutionName: '${if(isaacLabExec.metadata != null and isaacLabExec.metadata.name != null, isaacLabExec.metadata.name, isaacLabExec.name)}'
        next: wait_for_isaac_lab

    - wait_for_isaac_lab:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${isaacLabExecutionName}
        result: isaacLabStatus
        next: check_isaac_lab_status

    - check_isaac_lab_status:
        assign:
          - isaacLabState: '${if(isaacLabStatus.state != null, isaacLabStatus.state, if(isaacLabStatus.status != null, isaacLabStatus.status.state, null))}'
          - isaacLabFailedCount: '${if(isaacLabStatus.failedCount != null, isaacLabStatus.failedCount, if(isaacLabStatus.status != null, isaacLabStatus.status.failedCount, null))}'
          - isaacLabSucceededCount: '${if(isaacLabStatus.succeededCount != null, isaacLabStatus.succeededCount, if(isaacLabStatus.status != null, isaacLabStatus.status.succeededCount, null))}'
        next: isaac_lab_status_switch

    - isaac_lab_status_switch:
        switch:
          - condition: '${isaacLabState == "FAILED" or (isaacLabFailedCount != null and isaacLabFailedCount > 0)}'
            next: isaac_lab_failed
          - condition: '${isaacLabState == "SUCCEEDED" or (isaacLabSucceededCount != null and isaacLabSucceededCount > 0)}'
            next: log_isaac_lab_complete
        next: wait_isaac_lab_poll

    - wait_isaac_lab_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_isaac_lab

    - log_isaac_lab_complete:
        call: sys.log
        args:
          text: '${"Isaac Lab task generation completed for scene " + sceneId}'
          severity: "INFO"
        next: done

    - isaac_lab_failed:
        # Isaac Lab failure is non-fatal - scene is usable for sim without RL tasks
        call: sys.log
        args:
          text: '${"WARNING: Isaac Lab task generation failed for scene " + sceneId + " - scene is still usable but without RL training packages"}'
          severity: "WARNING"
        next: done_without_isaac_lab

    # =========================================================================
    # Completion
    # =========================================================================

    - done:
        return:
          status: "SUCCESS"
          scene_id: ${sceneId}
          message: '${"Full pipeline completed for scene " + sceneId + " (USD + Replicator + Isaac Lab)"}'
          convert_execution: ${convertExec.name}
          usd_execution: ${usdExec.name}
          replicator_execution: ${replicatorExec.name}
          isaac_lab_execution: ${isaacLabExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'
            replicator_bundle: '${"scenes/" + sceneId + "/replicator/"}'
            isaac_lab_package: '${"scenes/" + sceneId + "/isaac_lab/"}'

    - done_without_isaac_lab:
        return:
          status: "PARTIAL_SUCCESS"
          scene_id: ${sceneId}
          message: '${"Pipeline completed for scene " + sceneId + " (USD + Replicator, Isaac Lab failed)"}'
          convert_execution: ${convertExec.name}
          usd_execution: ${usdExec.name}
          replicator_execution: ${replicatorExec.name}
          isaac_lab_execution: ${isaacLabExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'
            replicator_bundle: '${"scenes/" + sceneId + "/replicator/"}'

    - done_without_replicator:
        return:
          status: "PARTIAL_SUCCESS"
          scene_id: ${sceneId}
          message: '${"USD assembly completed for scene " + sceneId + " (Replicator generation failed)"}'
          convert_execution: ${convertExec.name}
          usd_execution: ${usdExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'

    - skip_not_ready:
        return:
          status: "WAITING"
          scene_id: ${sceneId}
          message: '${"Waiting for all asset generation jobs to complete for scene " + sceneId}'

    - skip:
        return:
          status: "SKIPPED"
          message: '${"Not a completion marker file: " + object}'
