# usd-assembly-pipeline.yaml
#
# Google Cloud Workflows pipeline that:
#   1. Triggers on completion marker file from text-scene-adapter-job
#   2. Runs usd-assembly-job in CONVERT_ONLY mode to convert GLB->USDZ before simready
#   3. Runs simready-job to prepare simulation-ready assets (now sees USD-compatible files)
#   4. Runs interactive-job when required articulated objects are present
#   5. Runs usd-assembly-job to build scene.usda
#   6. Runs replicator-job to generate Replicator bundle for Isaac Sim domain randomization
#   7. Runs isaac-lab-job baseline task package generation
#
# Trigger: Cloud Storage object finalized event for .stage1_complete
#
# NOTE: This pipeline runs in parallel with dwm-preparation-pipeline and dream2flow-preparation-pipeline
# (all trigger on the same .stage1_complete marker). This is safe because:
# - Each pipeline writes to different output prefixes (usd/*, dwm/*, dream2flow/*)
# - Each pipeline uses a distinct lock object, so only duplicate runs of the same pipeline are blocked
# - Idempotency checks prevent duplicate processing
#
# Stage 1 text generation (arXiv:2512.17459) is a modular, compositional pipeline for
# "image â†’ sim-ready 3D reconstruction" with explicit physical constraints.
# Reference: https://3dregen.jdihlmann.com/
#
# Timeout defaults align with policy_configs/adaptive_timeouts.yaml; workflow-specific
# values are defined in top-level variables to keep runtime settings consistent.

main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: ${default(sys.get_env("WORKFLOW_REGION"), "us-central1")}
        next: filter_completion_markers

    - filter_completion_markers:
        switch:
          - condition: '${text.match_regex(object, "^scenes/.+/assets/\\.stage1_complete$")}'
            next: derive
        next: skip

    - derive:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - segPrefix: '${"scenes/" + sceneId + "/seg"}'
          - layoutPrefix: '${"scenes/" + sceneId + "/layout"}'
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - replicatorPrefix: '${"scenes/" + sceneId + "/replicator"}'
          - isaacLabPrefix: '${"scenes/" + sceneId + "/isaac_lab"}'
          - interactiveOutputPrefix: '${"scenes/" + sceneId + "/assets/interactive"}'
          - interactiveCompleteObject: '${"scenes/" + sceneId + "/assets/.interactive_complete"}'
          - interactiveSummaryObject: '${"scenes/" + sceneId + "/assets/.interactive_summary.json"}'
          - simreadyOutputPrefix: '${"scenes/" + sceneId + "/simready"}'
          - usdFailedMarker: '${"scenes/" + sceneId + "/usd/.failed"}'
          - interactiveFailedMarker: '${"scenes/" + sceneId + "/assets/.interactive_failed"}'
          - simreadyFailedMarker: '${"scenes/" + sceneId + "/simready/.failed"}'
          - replicatorFailedMarker: '${"scenes/" + sceneId + "/replicator/.failed"}'
          - isaacLabFailedMarker: '${"scenes/" + sceneId + "/isaac_lab/.failed"}'
          - lockObject: '${"scenes/" + sceneId + "/locks/usd-assembly.lock"}'
          - usdJobName: "usd-assembly-job"
          - interactiveJobName: "interactive-job"
          - interactiveFailurePolicy: '${default(map.get(event, "interactive_failure_policy"), default(sys.get_env("INTERACTIVE_FAILURE_POLICY"), "hybrid_strict"))}'
          - interactiveForceRun: '${text.lower(string(default(map.get(event, "interactive_force_run"), default(sys.get_env("INTERACTIVE_FORCE_RUN"), "false")))) == "true"}'
          - requireReplicator: '${text.lower(string(default(map.get(event, "require_replicator"), default(sys.get_env("REQUIRE_REPLICATOR"), "true")))) == "true"}'
          - requireIsaac: '${text.lower(string(default(map.get(event, "require_isaac"), default(sys.get_env("REQUIRE_ISAAC"), "true")))) == "true"}'
          # Timeout defaults align with policy_configs/adaptive_timeouts.yaml unless overridden.
          - adaptiveTimeoutConfigPath: "policy_configs/adaptive_timeouts.yaml"
          - convertTimeoutSeconds: 1800
          - simreadyTimeoutSeconds: 3600
          - interactiveTimeoutSeconds: 1800
          - usdAssemblyTimeoutSeconds: 3600
          - replicatorJobName: "replicator-job"
          - replicatorTimeoutSeconds: 1800
          - isaacLabTimeoutSeconds: 1800
        next: acquire_lock

    - acquire_lock:
        try:
          call: googleapis.storage.v1.objects.insert
          args:
            bucket: ${bucket}
            name: ${lockObject}
            ifGenerationMatch: 0
            uploadType: "media"
            body: ${json.encode({
              "scene_id": sceneId,
              "workflow": "usd-assembly-pipeline",
              "lock": "usd-assembly",
              "timestamp": time.format(sys.now()),
              "execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID")
            })}
        except:
          as: e
          steps:
            - lock_exists_check:
                switch:
                  - condition: '${e.code == 409 or e.code == 412}'
                    next: log_lock_exists
                next: raise_lock_error
        next: log_lock_acquired

    - log_lock_exists:
        call: sys.log
        args:
          text: '${"Lock already exists for scene " + sceneId + " at " + lockObject + " - skipping"}'
          severity: "INFO"
        next: skip_locked

    - raise_lock_error:
        raise: ${e}

    - log_lock_acquired:
        call: sys.log
        args:
          text: '${"Acquired lock for scene " + sceneId + " at " + lockObject}'
          severity: "INFO"
        next: log_start

    - log_start:
        call: sys.log
        args:
          text: '${"USD assembly triggered for scene " + sceneId + " (Stage 1 text generation) - starting pre-simready GLB->USDZ conversion"}'
          severity: "INFO"
        next: init_convert_metrics

    - init_convert_metrics:
        assign:
          - convertStartTime: '${time.format(sys.now())}'
        next: emit_convert_metrics_start

    - emit_convert_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "usd-assembly-pipeline"
            job: ${usdJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${convertTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${convertStartTime}
          severity: "INFO"
        next: run_convert_job

    - run_convert_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + usdJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: LAYOUT_PREFIX
                        value: ${layoutPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: CONVERT_ONLY
                        value: "true"
              timeout: '${string(convertTimeoutSeconds) + "s"}'
          result: convertExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_convert_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "usd-assembly-pipeline"
                    job: ${usdJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - list_convert_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${usdPrefix + "/"}
                  maxResults: 1000
                result: convertCleanupList
            - delete_convert_outputs_for_cleanup:
                for:
                  value: convertCleanupItem
                  in: ${default(convertCleanupList.items, [])}
                  steps:
                    - delete_convert_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${convertCleanupItem.name}
            - write_convert_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${usdFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": usdJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "usd_convert_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "usd_prefix": usdPrefix
                      }
                    }
                  })}
            - log_convert_error:
                call: sys.log
                args:
                  text: '${"Failed to start USD convert job after retries: " + e.message}'
                  severity: "ERROR"
            - release_lock_after_convert_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_convert_error:
                raise: ${e}
        next: set_convert_execution_name

    - set_convert_execution_name:
        # jobs.run returns a long-running operation; prefer the execution name from metadata when present
        assign:
          - convertExecutionName: '${if(convertExec.metadata != null and convertExec.metadata.name != null, convertExec.metadata.name, convertExec.name)}'
        next: wait_for_convert

    - wait_for_convert:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${convertExecutionName}
        result: convertStatus
        next: check_convert_status

    - check_convert_status:
        assign:
          - convertState: '${if(convertStatus.state != null, convertStatus.state, if(convertStatus.status != null, convertStatus.status.state, null))}'
          - convertFailedCount: '${if(convertStatus.failedCount != null, convertStatus.failedCount, if(convertStatus.status != null, convertStatus.status.failedCount, null))}'
          - convertSucceededCount: '${if(convertStatus.succeededCount != null, convertStatus.succeededCount, if(convertStatus.status != null, convertStatus.status.succeededCount, null))}'
        next: convert_status_switch

    - convert_status_switch:
        switch:
          - condition: '${convertState == "FAILED" or (convertFailedCount != null and convertFailedCount > 0)}'
            next: convert_failed
          - condition: '${convertState == "SUCCEEDED" or (convertSucceededCount != null and convertSucceededCount > 0)}'
            next: log_convert_complete
        next: wait_convert_poll

    - wait_convert_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_convert

    - log_convert_complete:
        assign:
          - convertEndTime: '${time.format(sys.now())}'
          - convertDurationSeconds: '${time.parse(convertEndTime) - time.parse(convertStartTime)}'
          - convertTimeoutUsageRatio: '${convertDurationSeconds / convertTimeoutSeconds}'
          - convertTimedOut: '${convertDurationSeconds >= convertTimeoutSeconds}'
        next: emit_convert_metrics_complete

    - emit_convert_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: ${usdJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${convertTimeoutSeconds}
            duration_seconds: ${convertDurationSeconds}
            timeout_usage_ratio: ${convertTimeoutUsageRatio}
            timed_out: ${convertTimedOut}
            status: "SUCCEEDED"
            start_time: ${convertStartTime}
            end_time: ${convertEndTime}
          severity: "INFO"
        next: log_convert_complete_message

    - log_convert_complete_message:
        call: sys.log
        args:
          text: '${"GLB->USDZ conversion completed for scene " + sceneId + " - starting simready-job"}'
          severity: "INFO"
        next: init_simready_metrics

    - init_simready_metrics:
        assign:
          - simreadyStartTime: '${time.format(sys.now())}'
        next: emit_simready_metrics_start

    - emit_simready_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "usd-assembly-pipeline"
            job: "simready-job"
            scene_id: ${sceneId}
            timeout_seconds: ${simreadyTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${simreadyStartTime}
          severity: "INFO"
        next: run_simready_job

    - convert_failed:
        assign:
          - errorMsg: '${"USD conversion job FAILED for scene " + sceneId}'
          - convertEndTime: '${time.format(sys.now())}'
          - convertDurationSeconds: '${time.parse(convertEndTime) - time.parse(convertStartTime)}'
          - convertTimeoutUsageRatio: '${convertDurationSeconds / convertTimeoutSeconds}'
          - convertTimedOut: '${convertDurationSeconds >= convertTimeoutSeconds}'
        next: emit_convert_metrics_failed

    - emit_convert_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: ${usdJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${convertTimeoutSeconds}
            duration_seconds: ${convertDurationSeconds}
            timeout_usage_ratio: ${convertTimeoutUsageRatio}
            timed_out: ${convertTimedOut}
            status: "FAILED"
            start_time: ${convertStartTime}
            end_time: ${convertEndTime}
          severity: "ERROR"
        next: log_convert_error

    - log_convert_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: release_lock_after_convert_failure

    - release_lock_after_convert_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_convert_error

    - raise_convert_error:
        raise: ${errorMsg}

    - run_simready_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/simready-job"}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: SIMREADY_PHYSICS_MODE
                        value: "deterministic"
              timeout: '${string(simreadyTimeoutSeconds) + "s"}'
        result: simreadyExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_simready_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "usd-assembly-pipeline"
                    job: "simready-job"
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - list_simready_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${simreadyOutputPrefix + "/"}
                  maxResults: 1000
                result: simreadyCleanupList
            - delete_simready_outputs_for_cleanup:
                for:
                  value: simreadyCleanupItem
                  in: ${default(simreadyCleanupList.items, [])}
                  steps:
                    - delete_simready_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${simreadyCleanupItem.name}
            - write_simready_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${simreadyFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": "simready-job",
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "simready_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "simready_prefix": simreadyOutputPrefix
                      }
                    }
                  })}
            - log_simready_error:
                call: sys.log
                args:
                  text: '${"Failed to start simready job after retries: " + e.message}'
                  severity: "ERROR"
            - release_lock_after_simready_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_simready_error:
                raise: ${e}
        next: init_simready_poll

    - init_simready_poll:
        assign:
          - simreadyAttempts: 0
          - simreadyWaitSeconds: 5
          - simreadyCompleteObject: '${assetsPrefix + "/.simready_complete"}'
        next: wait_for_simready_complete

    - wait_for_simready_complete:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${simreadyCompleteObject}
          result: simreadyComplete
        except:
          as: e
          steps:
            - simready_poll_switch:
                switch:
                  - condition: ${simreadyAttempts < 12}
                    next: bump_simready_attempt
                next: simready_failed
        next: log_simready_complete

    - bump_simready_attempt:
        assign:
          - simreadyAttempts: ${simreadyAttempts + 1}
          # Exponential backoff: 5s, 10s, 20s, 40s... capped at 60s
          - simreadyWaitSeconds: ${if(simreadyWaitSeconds * 2 > 60, 60, simreadyWaitSeconds * 2)}
        next: sleep_simready_poll

    - sleep_simready_poll:
        call: sys.sleep
        args:
          seconds: ${simreadyWaitSeconds}
        next: wait_for_simready_complete

    - log_simready_complete:
        assign:
          - simreadyEndTime: '${time.format(sys.now())}'
          - simreadyDurationSeconds: '${time.parse(simreadyEndTime) - time.parse(simreadyStartTime)}'
          - simreadyTimeoutUsageRatio: '${simreadyDurationSeconds / simreadyTimeoutSeconds}'
          - simreadyTimedOut: '${simreadyDurationSeconds >= simreadyTimeoutSeconds}'
        next: emit_simready_metrics_complete

    - emit_simready_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: "simready-job"
            scene_id: ${sceneId}
            timeout_seconds: ${simreadyTimeoutSeconds}
            duration_seconds: ${simreadyDurationSeconds}
            timeout_usage_ratio: ${simreadyTimeoutUsageRatio}
            timed_out: ${simreadyTimedOut}
            status: "SUCCEEDED"
            start_time: ${simreadyStartTime}
            end_time: ${simreadyEndTime}
          severity: "INFO"
        next: log_simready_complete_message

    - log_simready_complete_message:
        call: sys.log
        args:
          text: '${"Simready job completed for scene " + sceneId + " - evaluating articulation requirements"}'
          severity: "INFO"
        next: read_scene_manifest_for_interactive_gate

    - read_scene_manifest_for_interactive_gate:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: '${assetsPrefix + "/scene_manifest.json"}'
            alt: "media"
          result: sceneManifestRaw
        except:
          as: e
          steps:
            - set_scene_manifest_fallback:
                assign:
                  - sceneManifestRaw: '{"objects":[]}'
            - log_scene_manifest_read_warning:
                call: sys.log
                args:
                  text: '${"WARNING: Failed to read scene_manifest.json for interactive gate: " + e.message}'
                  severity: "WARNING"
        next: parse_scene_manifest_for_interactive_gate

    - parse_scene_manifest_for_interactive_gate:
        assign:
          - sceneManifestForInteractive: ${json.decode(sceneManifestRaw)}
          - candidateArticulationCount: 0
          - requiredArticulationCount: 0
        next: scan_articulation_candidates_and_required

    - scan_articulation_candidates_and_required:
        for:
          value: manifestObject
          in: ${default(map.get(sceneManifestForInteractive, "objects"), [])}
          steps:
            - detect_candidate_articulation_object:
                switch:
                  - condition: '${default(map.get(default(map.get(manifestObject, "articulation"), {}), "candidate"), false) == true or default(map.get(manifestObject, "sim_role"), "") == "articulated_furniture" or default(map.get(manifestObject, "sim_role"), "") == "articulated_appliance"}'
                    next: increment_candidate_articulation_count
                next: continue_candidate_articulation_scan
            - increment_candidate_articulation_count:
                assign:
                  - candidateArticulationCount: ${candidateArticulationCount + 1}
                next: continue_candidate_articulation_scan
            - continue_candidate_articulation_scan:
                assign:
                  - candidateArticulationCount: ${candidateArticulationCount}
                next: detect_required_articulation_object
            - detect_required_articulation_object:
                switch:
                  - condition: '${default(map.get(default(map.get(manifestObject, "articulation"), {}), "required"), false) == true}'
                    next: increment_required_articulation_count
                next: continue_required_articulation_scan
            - increment_required_articulation_count:
                assign:
                  - requiredArticulationCount: ${requiredArticulationCount + 1}
                next: continue_required_articulation_scan
            - continue_required_articulation_scan:
                assign:
                  - requiredArticulationCount: ${requiredArticulationCount}
        next: decide_interactive_phase

    - decide_interactive_phase:
        assign:
          - runInteractivePhase: '${interactiveForceRun or candidateArticulationCount > 0}'
        next: interactive_phase_switch

    - interactive_phase_switch:
        switch:
          - condition: ${runInteractivePhase}
            next: init_interactive_metrics
        next: log_interactive_skipped

    - log_interactive_skipped:
        call: sys.log
        args:
          text: '${"Skipping interactive-job for scene " + sceneId + " (candidate articulated objects: " + string(candidateArticulationCount) + ", required articulated objects: " + string(requiredArticulationCount) + ")"}'
          severity: "INFO"
        next: init_usd_metrics

    - init_interactive_metrics:
        assign:
          - interactiveStartTime: '${time.format(sys.now())}'
        next: emit_interactive_metrics_start

    - emit_interactive_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "usd-assembly-pipeline"
            job: ${interactiveJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${interactiveTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${interactiveStartTime}
            candidate_articulation_count: ${candidateArticulationCount}
            required_articulation_count: ${requiredArticulationCount}
            policy: ${interactiveFailurePolicy}
          severity: "INFO"
        next: run_interactive_job

    - run_interactive_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + interactiveJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
              timeout: '${string(interactiveTimeoutSeconds) + "s"}'
          result: interactiveExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_interactive_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "usd-assembly-pipeline"
                    job: ${interactiveJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - list_interactive_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${interactiveOutputPrefix + "/"}
                  maxResults: 1000
                result: interactiveCleanupList
            - delete_interactive_outputs_for_cleanup:
                for:
                  value: interactiveCleanupItem
                  in: ${default(interactiveCleanupList.items, [])}
                  steps:
                    - delete_interactive_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${interactiveCleanupItem.name}
            - write_interactive_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${interactiveFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": interactiveJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "interactive_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "assets_prefix": assetsPrefix
                      }
                    }
                  })}
            - set_interactive_failed_state_from_start_error:
                assign:
                  - interactiveState: "FAILED"
                  - interactiveMarkerMissing: true
                  - interactiveMarkerStatus: "failed"
                  - interactiveSummaryMissing: true
                  - interactiveRequiredFailureCount: ${requiredArticulationCount}
                next: evaluate_interactive_policy
        next: set_interactive_execution_name

    - set_interactive_execution_name:
        assign:
          - interactiveExecutionName: '${if(interactiveExec.metadata != null and interactiveExec.metadata.name != null, interactiveExec.metadata.name, interactiveExec.name)}'
        next: wait_for_interactive_job

    - wait_for_interactive_job:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${interactiveExecutionName}
        result: interactiveStatus
        next: check_interactive_status

    - check_interactive_status:
        assign:
          - interactiveState: '${if(interactiveStatus.state != null, interactiveStatus.state, if(interactiveStatus.status != null, interactiveStatus.status.state, null))}'
          - interactiveFailedCount: '${if(interactiveStatus.failedCount != null, interactiveStatus.failedCount, if(interactiveStatus.status != null, interactiveStatus.status.failedCount, null))}'
          - interactiveSucceededCount: '${if(interactiveStatus.succeededCount != null, interactiveStatus.succeededCount, if(interactiveStatus.status != null, interactiveStatus.status.succeededCount, null))}'
        next: interactive_status_switch

    - interactive_status_switch:
        switch:
          - condition: '${interactiveState == "FAILED" or (interactiveFailedCount != null and interactiveFailedCount > 0)}'
            next: interactive_failed_from_status
          - condition: '${interactiveState == "SUCCEEDED" or (interactiveSucceededCount != null and interactiveSucceededCount > 0)}'
            next: verify_interactive_marker
        next: wait_interactive_poll

    - wait_interactive_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_interactive_job

    - interactive_failed_from_status:
        assign:
          - interactiveMarkerMissing: true
          - interactiveMarkerStatus: "failed"
          - interactiveSummaryMissing: true
          - interactiveRequiredFailureCount: ${requiredArticulationCount}
        next: evaluate_interactive_policy

    - verify_interactive_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${interactiveCompleteObject}
            alt: "media"
          result: interactiveMarkerRaw
        except:
          as: e
          steps:
            - set_interactive_marker_missing:
                assign:
                  - interactiveMarkerRaw: '{}'
                  - interactiveMarkerMissing: true
            - log_interactive_marker_missing:
                call: sys.log
                args:
                  text: '${"ERROR: interactive marker missing after interactive-job run for scene " + sceneId + ": " + e.message}'
                  severity: "ERROR"
        next: parse_interactive_marker_payload

    - parse_interactive_marker_payload:
        assign:
          - interactiveMarkerMissing: '${default(interactiveMarkerMissing, false)}'
          - interactiveMarkerPayload: ${json.decode(default(interactiveMarkerRaw, '{}'))}
          - interactiveMarkerStatus: '${default(map.get(interactiveMarkerPayload, "status"), "unknown")}'
          - interactiveRequiredFailureCount: '${len(default(map.get(default(map.get(interactiveMarkerPayload, "summary"), {}), "required_failures"), []))}'
        next: read_interactive_summary

    - read_interactive_summary:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${interactiveSummaryObject}
            alt: "media"
          result: interactiveSummaryRaw
        except:
          as: e
          steps:
            - set_interactive_summary_missing:
                assign:
                  - interactiveSummaryRaw: '{}'
                  - interactiveSummaryMissing: true
            - log_interactive_summary_missing:
                call: sys.log
                args:
                  text: '${"WARNING: interactive summary missing for scene " + sceneId + ": " + e.message}'
                  severity: "WARNING"
        next: parse_interactive_summary_payload

    - parse_interactive_summary_payload:
        assign:
          - interactiveSummaryMissing: '${default(interactiveSummaryMissing, false)}'
          - interactiveSummaryPayload: ${json.decode(default(interactiveSummaryRaw, '{}'))}
          - interactiveRequiredFailureCountFromMarker: ${interactiveRequiredFailureCount}
          - interactiveRequiredFailureCount: '${if(default(map.get(interactiveSummaryPayload, "required_failure_count"), null) != null, map.get(interactiveSummaryPayload, "required_failure_count"), interactiveRequiredFailureCount)}'
        next: log_interactive_count_override_check

    - log_interactive_count_override_check:
        switch:
          - condition: '${interactiveRequiredFailureCountFromMarker != interactiveRequiredFailureCount}'
            steps:
              - log_count_override:
                  call: sys.log
                  args:
                    text: '${"WARNING: interactive required_failure_count overridden by summary for scene " + sceneId + " (marker=" + string(interactiveRequiredFailureCountFromMarker) + ", summary=" + string(interactiveRequiredFailureCount) + ")"}'
                    severity: "WARNING"
        next: evaluate_interactive_policy

    - evaluate_interactive_policy:
        switch:
          - condition: '${interactiveFailurePolicy == "warn"}'
            next: log_interactive_warn_mode_continue
          - condition: '${interactiveFailurePolicy == "strict" and (interactiveState == "FAILED" or interactiveMarkerMissing or interactiveMarkerStatus == "failure")}'
            next: interactive_gate_failed
          - condition: '${interactiveFailurePolicy == "hybrid_strict" and (interactiveMarkerMissing or (requiredArticulationCount > 0 and (interactiveState == "FAILED" or interactiveMarkerStatus == "failure" or interactiveRequiredFailureCount > 0)))}'
            next: interactive_gate_failed
        next: log_interactive_complete_message

    - log_interactive_warn_mode_continue:
        call: sys.log
        args:
          text: '${"Interactive policy is warn; continuing despite interactive issues for scene " + sceneId}'
          severity: "WARNING"
        next: log_interactive_complete_message

    - interactive_gate_failed:
        assign:
          - errorMsg: '${"Interactive gate failed for scene " + sceneId + " (policy=" + interactiveFailurePolicy + ", candidate_articulation_count=" + string(candidateArticulationCount) + ", required_articulation_count=" + string(requiredArticulationCount) + ", marker_status=" + interactiveMarkerStatus + ", required_failure_count=" + string(interactiveRequiredFailureCount) + ")"}'
        next: release_lock_after_interactive_failure

    - release_lock_after_interactive_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_interactive_error

    - raise_interactive_error:
        raise: ${errorMsg}

    - log_interactive_complete_message:
        call: sys.log
        args:
          text: '${"Interactive phase completed for scene " + sceneId + " (candidate_articulation_count=" + string(candidateArticulationCount) + ", required_articulation_count=" + string(requiredArticulationCount) + ", marker_status=" + interactiveMarkerStatus + ", required_failure_count=" + string(interactiveRequiredFailureCount) + ") - proceeding with full USD assembly"}'
          severity: "INFO"
        next: init_usd_metrics

    - init_usd_metrics:
        assign:
          - usdStartTime: '${time.format(sys.now())}'
        next: emit_usd_metrics_start

    - emit_usd_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "usd-assembly-pipeline"
            job: ${usdJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${usdAssemblyTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${usdStartTime}
          severity: "INFO"
        next: run_usd_job

    - simready_failed:
        assign:
          - errorMsg: '${"Simready job FAILED for scene " + sceneId + " (missing .simready_complete after " + string(simreadyAttempts) + " checks)"}'
          - simreadyEndTime: '${time.format(sys.now())}'
          - simreadyDurationSeconds: '${time.parse(simreadyEndTime) - time.parse(simreadyStartTime)}'
          - simreadyTimeoutUsageRatio: '${simreadyDurationSeconds / simreadyTimeoutSeconds}'
          - simreadyTimedOut: '${simreadyDurationSeconds >= simreadyTimeoutSeconds}'
        next: emit_simready_metrics_failed

    - emit_simready_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: "simready-job"
            scene_id: ${sceneId}
            timeout_seconds: ${simreadyTimeoutSeconds}
            duration_seconds: ${simreadyDurationSeconds}
            timeout_usage_ratio: ${simreadyTimeoutUsageRatio}
            timed_out: ${simreadyTimedOut}
            status: "FAILED"
            start_time: ${simreadyStartTime}
            end_time: ${simreadyEndTime}
          severity: "ERROR"
        next: log_simready_error

    - log_simready_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: release_lock_after_simready_failure

    - release_lock_after_simready_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_simready_error

    - raise_simready_error:
        raise: ${errorMsg}

    - run_usd_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + usdJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: LAYOUT_PREFIX
                        value: ${layoutPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
              timeout: '${string(usdAssemblyTimeoutSeconds) + "s"}'
          result: usdExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_usd_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "usd-assembly-pipeline"
                    job: ${usdJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - list_usd_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${usdPrefix + "/"}
                  maxResults: 1000
                result: usdCleanupList
            - delete_usd_outputs_for_cleanup:
                for:
                  value: usdCleanupItem
                  in: ${default(usdCleanupList.items, [])}
                  steps:
                    - delete_usd_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${usdCleanupItem.name}
            - write_usd_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${usdFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": usdJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "usd_assembly_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "usd_prefix": usdPrefix
                      }
                    }
                  })}
            - log_usd_error:
                call: sys.log
                args:
                  text: '${"Failed to start USD job after retries: " + e.message}'
                  severity: "ERROR"
            - release_lock_after_usd_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_usd_error:
                raise: ${e}
        next: set_usd_execution_name

    - set_usd_execution_name:
        # jobs.run returns a long-running operation; prefer the execution name from metadata when present
        assign:
          - usdExecutionName: '${if(usdExec.metadata != null and usdExec.metadata.name != null, usdExec.metadata.name, usdExec.name)}'
        next: wait_for_usd

    - wait_for_usd:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${usdExecutionName}
        result: usdStatus
        next: check_usd_status

    - check_usd_status:
        assign:
          - usdState: '${if(usdStatus.state != null, usdStatus.state, if(usdStatus.status != null, usdStatus.status.state, null))}'
          - usdFailedCount: '${if(usdStatus.failedCount != null, usdStatus.failedCount, if(usdStatus.status != null, usdStatus.status.failedCount, null))}'
          - usdSucceededCount: '${if(usdStatus.succeededCount != null, usdStatus.succeededCount, if(usdStatus.status != null, usdStatus.status.succeededCount, null))}'
        next: usd_status_switch

    - usd_status_switch:
        switch:
          - condition: '${usdState == "FAILED" or (usdFailedCount != null and usdFailedCount > 0)}'
            next: usd_failed
          - condition: '${usdState == "SUCCEEDED" or (usdSucceededCount != null and usdSucceededCount > 0)}'
            next: log_usd_complete
        next: wait_usd_poll

    - wait_usd_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_usd

    - log_usd_complete:
        assign:
          - usdEndTime: '${time.format(sys.now())}'
          - usdDurationSeconds: '${time.parse(usdEndTime) - time.parse(usdStartTime)}'
          - usdTimeoutUsageRatio: '${usdDurationSeconds / usdAssemblyTimeoutSeconds}'
          - usdTimedOut: '${usdDurationSeconds >= usdAssemblyTimeoutSeconds}'
        next: emit_usd_metrics_complete

    - emit_usd_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: ${usdJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${usdAssemblyTimeoutSeconds}
            duration_seconds: ${usdDurationSeconds}
            timeout_usage_ratio: ${usdTimeoutUsageRatio}
            timed_out: ${usdTimedOut}
            status: "SUCCEEDED"
            start_time: ${usdStartTime}
            end_time: ${usdEndTime}
          severity: "INFO"
        next: log_usd_complete_message

    - log_usd_complete_message:
        call: sys.log
        args:
          text: '${"USD assembly completed for scene " + sceneId + " - starting replicator bundle generation"}'
          severity: "INFO"
        next: init_replicator_metrics

    - init_replicator_metrics:
        assign:
          - replicatorStartTime: '${time.format(sys.now())}'
        next: emit_replicator_metrics_start

    - emit_replicator_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "usd-assembly-pipeline"
            job: ${replicatorJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${replicatorTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${replicatorStartTime}
          severity: "INFO"
        next: run_replicator_job

    - usd_failed:
        assign:
          - errorMsg: '${"USD assembly job FAILED for scene " + sceneId}'
          - usdEndTime: '${time.format(sys.now())}'
          - usdDurationSeconds: '${time.parse(usdEndTime) - time.parse(usdStartTime)}'
          - usdTimeoutUsageRatio: '${usdDurationSeconds / usdAssemblyTimeoutSeconds}'
          - usdTimedOut: '${usdDurationSeconds >= usdAssemblyTimeoutSeconds}'
        next: emit_usd_metrics_failed

    - emit_usd_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: ${usdJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${usdAssemblyTimeoutSeconds}
            duration_seconds: ${usdDurationSeconds}
            timeout_usage_ratio: ${usdTimeoutUsageRatio}
            timed_out: ${usdTimedOut}
            status: "FAILED"
            start_time: ${usdStartTime}
            end_time: ${usdEndTime}
          severity: "ERROR"
        next: log_usd_error

    - log_usd_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: release_lock_after_usd_failure

    - release_lock_after_usd_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_usd_error

    - raise_usd_error:
        raise: ${errorMsg}

    # =========================================================================
    # Replicator Job - Generate domain randomization bundle for Isaac Sim
    # =========================================================================

    - run_replicator_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + replicatorJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: SEG_PREFIX
                        value: ${segPrefix}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: REPLICATOR_PREFIX
                        value: ${replicatorPrefix}
              timeout: '${string(replicatorTimeoutSeconds) + "s"}'
          result: replicatorExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_replicator_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "usd-assembly-pipeline"
                    job: ${replicatorJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - list_replicator_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${replicatorPrefix + "/"}
                  maxResults: 1000
                result: replicatorCleanupList
            - delete_replicator_outputs_for_cleanup:
                for:
                  value: replicatorCleanupItem
                  in: ${default(replicatorCleanupList.items, [])}
                  steps:
                    - delete_replicator_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${replicatorCleanupItem.name}
            - write_replicator_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${replicatorFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": replicatorJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "replicator_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "replicator_prefix": replicatorPrefix
                      }
                    }
                  })}
            - log_replicator_error:
                call: sys.log
                args:
                  text: '${"Failed to start replicator job after retries: " + e.message}'
                  severity: "ERROR"
            - release_lock_after_replicator_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_replicator_error:
                raise: ${e}
        next: set_replicator_execution_name

    - set_replicator_execution_name:
        assign:
          - replicatorExecutionName: '${if(replicatorExec.metadata != null and replicatorExec.metadata.name != null, replicatorExec.metadata.name, replicatorExec.name)}'
        next: wait_for_replicator

    - wait_for_replicator:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${replicatorExecutionName}
        result: replicatorStatus
        next: check_replicator_status

    - check_replicator_status:
        assign:
          - replicatorState: '${if(replicatorStatus.state != null, replicatorStatus.state, if(replicatorStatus.status != null, replicatorStatus.status.state, null))}'
          - replicatorFailedCount: '${if(replicatorStatus.failedCount != null, replicatorStatus.failedCount, if(replicatorStatus.status != null, replicatorStatus.status.failedCount, null))}'
          - replicatorSucceededCount: '${if(replicatorStatus.succeededCount != null, replicatorStatus.succeededCount, if(replicatorStatus.status != null, replicatorStatus.status.succeededCount, null))}'
        next: replicator_status_switch

    - replicator_status_switch:
        switch:
          - condition: '${replicatorState == "FAILED" or (replicatorFailedCount != null and replicatorFailedCount > 0)}'
            next: replicator_failed
          - condition: '${replicatorState == "SUCCEEDED" or (replicatorSucceededCount != null and replicatorSucceededCount > 0)}'
            next: log_replicator_complete
        next: wait_replicator_poll

    - wait_replicator_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_replicator

    - log_replicator_complete:
        assign:
          - replicatorEndTime: '${time.format(sys.now())}'
          - replicatorDurationSeconds: '${time.parse(replicatorEndTime) - time.parse(replicatorStartTime)}'
          - replicatorTimeoutUsageRatio: '${replicatorDurationSeconds / replicatorTimeoutSeconds}'
          - replicatorTimedOut: '${replicatorDurationSeconds >= replicatorTimeoutSeconds}'
        next: emit_replicator_metrics_complete

    - emit_replicator_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: ${replicatorJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${replicatorTimeoutSeconds}
            duration_seconds: ${replicatorDurationSeconds}
            timeout_usage_ratio: ${replicatorTimeoutUsageRatio}
            timed_out: ${replicatorTimedOut}
            status: "SUCCEEDED"
            start_time: ${replicatorStartTime}
            end_time: ${replicatorEndTime}
          severity: "INFO"
        next: log_replicator_complete_message

    - log_replicator_complete_message:
        call: sys.log
        args:
          text: '${"Replicator bundle generation completed for scene " + sceneId + " - starting Isaac Lab task generation"}'
          severity: "INFO"
        next: verify_replicator_marker

    - verify_replicator_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: '${replicatorPrefix + "/.replicator_complete"}'
          result: replicatorMarkerObject
        except:
          as: e
          steps:
            - log_replicator_marker_missing:
                call: sys.log
                args:
                  text: '${"WARNING: .replicator_complete marker missing after replicator-job succeeded for scene " + sceneId + " (error: " + e.message + ")"}'
                  severity: "WARNING"
            - replicator_marker_missing_policy:
                switch:
                  - condition: ${requireReplicator}
                    next: release_lock_after_required_replicator_failure
                next: init_isaac_lab_metrics
        next: init_isaac_lab_metrics

    - replicator_failed:
        assign:
          - replicatorEndTime: '${time.format(sys.now())}'
          - replicatorDurationSeconds: '${time.parse(replicatorEndTime) - time.parse(replicatorStartTime)}'
          - replicatorTimeoutUsageRatio: '${replicatorDurationSeconds / replicatorTimeoutSeconds}'
          - replicatorTimedOut: '${replicatorDurationSeconds >= replicatorTimeoutSeconds}'
        next: emit_replicator_metrics_failed

    - emit_replicator_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: ${replicatorJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${replicatorTimeoutSeconds}
            duration_seconds: ${replicatorDurationSeconds}
            timeout_usage_ratio: ${replicatorTimeoutUsageRatio}
            timed_out: ${replicatorTimedOut}
            status: "FAILED"
            start_time: ${replicatorStartTime}
            end_time: ${replicatorEndTime}
          severity: "WARNING"
        next: log_replicator_failed_message

    - log_replicator_failed_message:
        call: sys.log
        args:
          text: '${"Replicator job failed for scene " + sceneId + " (require_replicator=" + string(requireReplicator) + ")"}'
          severity: "WARNING"
        next: replicator_failure_policy_switch

    - replicator_failure_policy_switch:
        switch:
          - condition: ${requireReplicator}
            next: release_lock_after_required_replicator_failure
        next: init_isaac_lab_metrics

    - init_isaac_lab_metrics:
        assign:
          - isaacLabStartTime: '${time.format(sys.now())}'
        next: emit_isaac_lab_metrics_start

    - emit_isaac_lab_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "usd-assembly-pipeline"
            job: "isaac-lab-job"
            scene_id: ${sceneId}
            timeout_seconds: ${isaacLabTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${isaacLabStartTime}
          severity: "INFO"
        next: run_isaac_lab_job

    # =========================================================================
    # Isaac Lab Job - Generate RL training task packages
    # =========================================================================

    - run_isaac_lab_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/isaac-lab-job"}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: REPLICATOR_PREFIX
                        value: ${replicatorPrefix}
                      - name: ISAAC_LAB_PREFIX
                        value: ${isaacLabPrefix}
              timeout: '${string(isaacLabTimeoutSeconds) + "s"}'
          result: isaacLabExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_isaac_lab_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "usd-assembly-pipeline"
                    job: "isaac-lab-job"
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - list_isaac_lab_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${isaacLabPrefix + "/"}
                  maxResults: 1000
                result: isaacLabCleanupList
            - delete_isaac_lab_outputs_for_cleanup:
                for:
                  value: isaacLabCleanupItem
                  in: ${default(isaacLabCleanupList.items, [])}
                  steps:
                    - delete_isaac_lab_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${isaacLabCleanupItem.name}
            - write_isaac_lab_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${isaacLabFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": "isaac-lab-job",
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "isaac_lab_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "isaac_lab_prefix": isaacLabPrefix
                      }
                    }
                  })}
            - log_isaac_lab_error:
                call: sys.log
                args:
                  text: '${"Failed to start Isaac Lab job after retries: " + e.message}'
                  severity: "ERROR"
            - release_lock_after_isaac_lab_start_error:
                call: googleapis.storage.v1.objects.delete
                args:
                  bucket: ${bucket}
                  object: ${lockObject}
            - raise_isaac_lab_error:
                raise: ${e}
        next: set_isaac_lab_execution_name

    - set_isaac_lab_execution_name:
        assign:
          - isaacLabExecutionName: '${if(isaacLabExec.metadata != null and isaacLabExec.metadata.name != null, isaacLabExec.metadata.name, isaacLabExec.name)}'
        next: wait_for_isaac_lab

    - wait_for_isaac_lab:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${isaacLabExecutionName}
        result: isaacLabStatus
        next: check_isaac_lab_status

    - check_isaac_lab_status:
        assign:
          - isaacLabState: '${if(isaacLabStatus.state != null, isaacLabStatus.state, if(isaacLabStatus.status != null, isaacLabStatus.status.state, null))}'
          - isaacLabFailedCount: '${if(isaacLabStatus.failedCount != null, isaacLabStatus.failedCount, if(isaacLabStatus.status != null, isaacLabStatus.status.failedCount, null))}'
          - isaacLabSucceededCount: '${if(isaacLabStatus.succeededCount != null, isaacLabStatus.succeededCount, if(isaacLabStatus.status != null, isaacLabStatus.status.succeededCount, null))}'
        next: isaac_lab_status_switch

    - isaac_lab_status_switch:
        switch:
          - condition: '${isaacLabState == "FAILED" or (isaacLabFailedCount != null and isaacLabFailedCount > 0)}'
            next: isaac_lab_failed
          - condition: '${isaacLabState == "SUCCEEDED" or (isaacLabSucceededCount != null and isaacLabSucceededCount > 0)}'
            next: log_isaac_lab_complete
        next: wait_isaac_lab_poll

    - wait_isaac_lab_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_isaac_lab

    - log_isaac_lab_complete:
        assign:
          - isaacLabEndTime: '${time.format(sys.now())}'
          - isaacLabDurationSeconds: '${time.parse(isaacLabEndTime) - time.parse(isaacLabStartTime)}'
          - isaacLabTimeoutUsageRatio: '${isaacLabDurationSeconds / isaacLabTimeoutSeconds}'
          - isaacLabTimedOut: '${isaacLabDurationSeconds >= isaacLabTimeoutSeconds}'
        next: emit_isaac_lab_metrics_complete

    - emit_isaac_lab_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: "isaac-lab-job"
            scene_id: ${sceneId}
            timeout_seconds: ${isaacLabTimeoutSeconds}
            duration_seconds: ${isaacLabDurationSeconds}
            timeout_usage_ratio: ${isaacLabTimeoutUsageRatio}
            timed_out: ${isaacLabTimedOut}
            status: "SUCCEEDED"
            start_time: ${isaacLabStartTime}
            end_time: ${isaacLabEndTime}
          severity: "INFO"
        next: log_isaac_lab_complete_message

    - log_isaac_lab_complete_message:
        call: sys.log
        args:
          text: '${"Isaac Lab task generation completed for scene " + sceneId}'
          severity: "INFO"
        next: verify_isaac_lab_marker

    - verify_isaac_lab_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: '${isaacLabPrefix + "/.isaac_lab_complete"}'
          result: isaacLabMarkerObject
        except:
          as: e
          steps:
            - log_isaac_lab_marker_missing:
                call: sys.log
                args:
                  text: '${"WARNING: .isaac_lab_complete marker missing after isaac-lab-job succeeded for scene " + sceneId + " (error: " + e.message + ")"}'
                  severity: "WARNING"
            - isaac_lab_marker_missing_policy:
                switch:
                  - condition: ${requireIsaac}
                    next: release_lock_after_required_isaac_lab_failure
                next: release_lock_before_done_without_isaac_lab
        next: release_lock_before_done

    - isaac_lab_failed:
        # Isaac Lab failure is fatal when requireIsaac=true; otherwise it is partial success.
        assign:
          - isaacLabEndTime: '${time.format(sys.now())}'
          - isaacLabDurationSeconds: '${time.parse(isaacLabEndTime) - time.parse(isaacLabStartTime)}'
          - isaacLabTimeoutUsageRatio: '${isaacLabDurationSeconds / isaacLabTimeoutSeconds}'
          - isaacLabTimedOut: '${isaacLabDurationSeconds >= isaacLabTimeoutSeconds}'
        next: emit_isaac_lab_metrics_failed

    - emit_isaac_lab_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "usd-assembly-pipeline"
            job: "isaac-lab-job"
            scene_id: ${sceneId}
            timeout_seconds: ${isaacLabTimeoutSeconds}
            duration_seconds: ${isaacLabDurationSeconds}
            timeout_usage_ratio: ${isaacLabTimeoutUsageRatio}
            timed_out: ${isaacLabTimedOut}
            status: "FAILED"
            start_time: ${isaacLabStartTime}
            end_time: ${isaacLabEndTime}
          severity: "WARNING"
        next: log_isaac_lab_failed_message

    - log_isaac_lab_failed_message:
        call: sys.log
        args:
          text: '${"WARNING: Isaac Lab baseline generation failed for scene " + sceneId + " (require_isaac=" + string(requireIsaac) + ")"}'
          severity: "WARNING"
        next: isaac_lab_failure_policy_switch

    - isaac_lab_failure_policy_switch:
        switch:
          - condition: ${requireIsaac}
            next: release_lock_after_required_isaac_lab_failure
        next: release_lock_before_done_without_isaac_lab

    - release_lock_after_required_isaac_lab_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_required_isaac_lab_error

    - raise_required_isaac_lab_error:
        raise: '${"Isaac Lab job failed and REQUIRE_ISAAC=true for scene " + sceneId}'

    - release_lock_after_required_replicator_failure:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: raise_required_replicator_error

    - raise_required_replicator_error:
        raise: '${"Replicator job failed and REQUIRE_REPLICATOR=true for scene " + sceneId}'

    - release_lock_before_done:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: done

    - release_lock_before_done_without_isaac_lab:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: done_without_isaac_lab

    - release_lock_before_done_without_replicator:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: done_without_replicator

    - release_lock_before_skip_not_ready:
        call: googleapis.storage.v1.objects.delete
        args:
          bucket: ${bucket}
          object: ${lockObject}
        next: skip_not_ready

    # =========================================================================
    # Completion
    # =========================================================================

    - done:
        return:
          status: "SUCCESS"
          scene_id: ${sceneId}
          message: '${"Full pipeline completed for scene " + sceneId + " (USD + Replicator + Isaac Lab)"}'
          convert_execution: ${convertExec.name}
          usd_execution: ${usdExec.name}
          replicator_execution: ${replicatorExec.name}
          isaac_lab_execution: ${isaacLabExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'
            replicator_bundle: '${"scenes/" + sceneId + "/replicator/"}'
            isaac_lab_package: '${"scenes/" + sceneId + "/isaac_lab/"}'

    - done_without_isaac_lab:
        return:
          status: "PARTIAL_SUCCESS"
          scene_id: ${sceneId}
          message: '${"Pipeline completed for scene " + sceneId + " (USD + Replicator, Isaac Lab failed)"}'
          convert_execution: ${convertExec.name}
          usd_execution: ${usdExec.name}
          replicator_execution: ${replicatorExec.name}
          isaac_lab_execution: ${isaacLabExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'
            replicator_bundle: '${"scenes/" + sceneId + "/replicator/"}'

    - done_without_replicator:
        return:
          status: "PARTIAL_SUCCESS"
          scene_id: ${sceneId}
          message: '${"USD assembly completed for scene " + sceneId + " (Replicator generation failed)"}'
          convert_execution: ${convertExec.name}
          usd_execution: ${usdExec.name}
          outputs:
            scene_usda: '${"scenes/" + sceneId + "/usd/scene.usda"}'

    - skip_not_ready:
        return:
          status: "WAITING"
          scene_id: ${sceneId}
          message: '${"Waiting for all asset generation jobs to complete for scene " + sceneId}'

    - skip_locked:
        return:
          status: "SKIPPED"
          scene_id: ${sceneId}
          message: '${"Lock already exists for scene " + sceneId + " at " + lockObject}'

    - skip:
        return:
          status: "SKIPPED"
          message: '${"Not a completion marker file: " + object}'
