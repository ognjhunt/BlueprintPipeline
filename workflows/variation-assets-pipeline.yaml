# variation-assets-pipeline.yaml
#
# Google Cloud Workflows pipeline that generates variation assets for domain randomization.
#
# This pipeline:
#   1. Triggers on .replicator_complete marker from replicator-job
#   2. Runs variation-gen-job to generate variation asset specifications
#   3. Runs simready-job to add physics properties to the assets
#   4. Runs isaac-lab-job refresh-only pass to update task spawn plans from generated variations
#
# Note: With 3D-RE-GEN pipeline, 3D model generation is handled by regen3d-job.
#
# Trigger: Cloud Storage object finalized event for .replicator_complete
#
# The generated variation assets are placed in scenes/{sceneId}/variation_assets/
# and can be used by Replicator scripts for domain randomization.

main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: ${default(sys.get_env("WORKFLOW_REGION"), "us-central1")}
        next: filter_replicator_complete

    - filter_replicator_complete:
        switch:
          - condition: '${text.match_regex(object, "^scenes/.+/replicator/\\.replicator_complete$")}'
            next: derive
        next: skip

    - derive:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - assetsPrefix: '${"scenes/" + sceneId + "/assets"}'
          - usdPrefix: '${"scenes/" + sceneId + "/usd"}'
          - replicatorPrefix: '${"scenes/" + sceneId + "/replicator"}'
          - isaacLabPrefix: '${"scenes/" + sceneId + "/isaac_lab"}'
          - variationAssetsPrefix: '${"scenes/" + sceneId + "/variation_assets"}'
          - variationAssetsProgressMarker: '${"scenes/" + sceneId + "/variation_assets/.progress.json"}'
          - variationAssetsReportObject: '${"scenes/" + sceneId + "/variation_assets/generation_report.json"}'
          - variationAssetsFailedMarker: '${"scenes/" + sceneId + "/variation_assets/.failed"}'
          - variationSimreadyFailedMarker: '${"scenes/" + sceneId + "/variation_assets/simready/.failed"}'
          - isaacLabRefreshCompleteObject: '${"scenes/" + sceneId + "/isaac_lab/.isaac_lab_refresh_complete"}'
          - variationGenJobName: "variation-gen-job"
          - variationGenTimeoutSeconds: '${int(default(sys.get_env("VARIATION_GEN_TIMEOUT_SECONDS"), "1800"))}'
          - simreadyJobName: "simready-job"
          - simreadyTimeoutSeconds: '${int(default(sys.get_env("SIMREADY_TIMEOUT_SECONDS"), "3600"))}'
          - isaacLabJobName: "isaac-lab-job"
          - isaacLabTimeoutSeconds: '${int(default(sys.get_env("ISAAC_LAB_TIMEOUT_SECONDS"), "1800"))}'
          - enableStage3IsaacRefresh: '${text.lower(string(default(map.get(event, "enable_stage3_isaac_refresh"), default(sys.get_env("ENABLE_STAGE3_ISAAC_REFRESH"), "true")))) == "true"}'
          - requireIsaac: '${text.lower(string(default(map.get(event, "require_isaac"), default(sys.get_env("REQUIRE_ISAAC"), "true")))) == "true"}'
        next: log_start

    - log_start:
        call: sys.log
        args:
          text: '${"Variation assets pipeline triggered for scene " + sceneId}'
          severity: "INFO"
        next: init_pipeline_metrics

    - init_pipeline_metrics:
        assign:
          - pipelineStartTime: '${time.format(sys.now())}'
          - pipelineTimeoutSeconds: '${variationGenTimeoutSeconds + simreadyTimeoutSeconds + if(enableStage3IsaacRefresh, isaacLabTimeoutSeconds, 0)}'
          - pipelineStatus: "SUCCESS"
          - isaacRefreshState: "SKIPPED"
          - isaacRefreshExecutionName: ""
        next: emit_pipeline_metrics_start

    - emit_pipeline_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "pipeline_invocation"
            event: "start"
            workflow: "variation-assets-pipeline"
            scene_id: ${sceneId}
            timeout_seconds: ${pipelineTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${pipelineStartTime}
          severity: "INFO"
        next: check_variation_assets_progress_marker

    - check_variation_assets_progress_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${variationAssetsProgressMarker}
          result: variationAssetsProgressMarkerObject
        except:
          as: e
          steps:
            - handle_progress_marker_missing:
                switch:
                  - condition: '${e.code == 404}'
                    next: detect_partial_outputs
                next: raise_progress_marker_error
        next: set_resume_from_progress

    - detect_partial_outputs:
        call: googleapis.storage.v1.objects.list
        args:
          bucket: ${bucket}
          prefix: ${variationAssetsPrefix + "/"}
          maxResults: 1
        result: variationAssetsPartialList
        next: set_resume_from_partial_outputs

    - set_resume_from_partial_outputs:
        assign:
          - resumeFromProgress: '${len(default(variationAssetsPartialList.items, [])) > 0}'
        next: init_variation_gen_metrics

    - set_resume_from_progress:
        assign:
          - resumeFromProgress: true
        next: init_variation_gen_metrics

    - raise_progress_marker_error:
        raise: '${e}'

    - init_variation_gen_metrics:
        assign:
          - variationGenStartTime: '${time.format(sys.now())}'
        next: emit_variation_gen_metrics_start

    - emit_variation_gen_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "variation-assets-pipeline"
            job: ${variationGenJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${variationGenTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${variationGenStartTime}
          severity: "INFO"
        next: run_variation_gen_job

    # =========================================================================
    # Stage 1: Generate variation asset specifications
    # =========================================================================

    - run_variation_gen_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + variationGenJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: REPLICATOR_PREFIX
                        value: ${replicatorPrefix}
                      - name: VARIATION_ASSETS_PREFIX
                        value: ${variationAssetsPrefix}
                      - name: PROGRESS_MARKER_PATH
                        value: ${variationAssetsProgressMarker}
                      - name: RESUME_FROM_PROGRESS
                        value: '${if(resumeFromProgress, "true", "false")}'
                      # Generate only required and recommended assets by default
                      # Set to empty string to generate all
                      - name: PRIORITY_FILTER
                        value: ""
              timeout: '${string(variationGenTimeoutSeconds) + "s"}'
          result: variationGenExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_variation_gen_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "variation-assets-pipeline"
                    job: ${variationGenJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - log_variation_gen_job_error:
                call: sys.log
                args:
                  text: '${"Failed to start variation-gen job after retries: " + e.message}'
                  severity: "ERROR"
            - list_variation_gen_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${variationAssetsPrefix + "/"}
                  maxResults: 1000
                result: variationGenCleanupList
            - delete_variation_gen_outputs_for_cleanup:
                for:
                  value: variationGenCleanupItem
                  in: ${default(variationGenCleanupList.items, [])}
                  steps:
                    - delete_variation_gen_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${variationGenCleanupItem.name}
            - write_variation_gen_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${variationAssetsFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": variationGenJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "variation_gen_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "variation_assets_prefix": variationAssetsPrefix
                      }
                    }
                  })}
            - raise_variation_gen_job_error:
                raise: ${e}
        next: set_variation_gen_execution_name

    - set_variation_gen_execution_name:
        assign:
          - variationGenExecutionName: '${if(variationGenExec.metadata != null and variationGenExec.metadata.name != null, variationGenExec.metadata.name, variationGenExec.name)}'
        next: wait_for_variation_gen

    - wait_for_variation_gen:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${variationGenExecutionName}
        result: variationGenStatus
        next: check_variation_gen_status

    - check_variation_gen_status:
        assign:
          - variationGenState: '${if(variationGenStatus.state != null, variationGenStatus.state, if(variationGenStatus.status != null, variationGenStatus.status.state, null))}'
          - variationGenFailedCount: '${if(variationGenStatus.failedCount != null, variationGenStatus.failedCount, if(variationGenStatus.status != null, variationGenStatus.status.failedCount, null))}'
          - variationGenSucceededCount: '${if(variationGenStatus.succeededCount != null, variationGenStatus.succeededCount, if(variationGenStatus.status != null, variationGenStatus.status.succeededCount, null))}'
        next: variation_gen_status_switch

    - variation_gen_status_switch:
        switch:
          - condition: '${variationGenState == "FAILED" or (variationGenFailedCount != null and variationGenFailedCount > 0)}'
            next: variation_gen_failed
          - condition: '${variationGenState == "SUCCEEDED" or (variationGenSucceededCount != null and variationGenSucceededCount > 0)}'
            next: log_variation_gen_complete
        next: wait_variation_gen_poll

    - wait_variation_gen_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_variation_gen

    - log_variation_gen_complete:
        assign:
          - variationGenEndTime: '${time.format(sys.now())}'
          - variationGenDurationSeconds: '${time.parse(variationGenEndTime) - time.parse(variationGenStartTime)}'
          - variationGenTimeoutUsageRatio: '${variationGenDurationSeconds / variationGenTimeoutSeconds}'
          - variationGenTimedOut: '${variationGenDurationSeconds >= variationGenTimeoutSeconds}'
        next: emit_variation_gen_metrics_complete

    - emit_variation_gen_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            job: ${variationGenJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${variationGenTimeoutSeconds}
            duration_seconds: ${variationGenDurationSeconds}
            timeout_usage_ratio: ${variationGenTimeoutUsageRatio}
            timed_out: ${variationGenTimedOut}
            status: "SUCCEEDED"
            start_time: ${variationGenStartTime}
            end_time: ${variationGenEndTime}
          severity: "INFO"
        next: log_variation_gen_complete_message

    - log_variation_gen_complete_message:
        call: sys.log
        args:
          text: '${"Variation generation completed for scene " + sceneId + " - starting simready-job"}'
          severity: "INFO"
        next: read_variation_gen_report

    - read_variation_gen_report:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${variationAssetsReportObject}
            alt: "media"
          result: variationGenReportRaw
        except:
          as: e
          steps:
            - handle_variation_gen_report_missing:
                switch:
                  - condition: ${e.code == 404}
                    next: set_variation_gen_report_missing
                next: raise_variation_gen_report_error
        next: parse_variation_gen_report

    - parse_variation_gen_report:
        assign:
          - variationGenReport: ${json.decode(variationGenReportRaw)}
          - variationGenReportMissing: false
        next: write_variation_gen_progress_marker

    - set_variation_gen_report_missing:
        assign:
          - variationGenReport: null
          - variationGenReportMissing: true
        next: write_variation_gen_progress_marker

    - raise_variation_gen_report_error:
        raise: '${e}'

    - write_variation_gen_progress_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${variationAssetsProgressMarker}
          uploadType: "media"
          body: ${json.encode({
            "scene_id": sceneId,
            "variation_assets_prefix": variationAssetsPrefix,
            "updated_at": time.format(sys.now()),
            "report_missing": variationGenReportMissing,
            "variation_gen": variationGenReport
          })}
        next: check_variation_assets_exist

    - variation_gen_failed:
        assign:
          - errorMsg: '${"Variation generation job FAILED for scene " + sceneId}'
          - variationGenEndTime: '${time.format(sys.now())}'
          - variationGenDurationSeconds: '${time.parse(variationGenEndTime) - time.parse(variationGenStartTime)}'
          - variationGenTimeoutUsageRatio: '${variationGenDurationSeconds / variationGenTimeoutSeconds}'
          - variationGenTimedOut: '${variationGenDurationSeconds >= variationGenTimeoutSeconds}'
        next: emit_variation_gen_metrics_failed

    - emit_variation_gen_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            job: ${variationGenJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${variationGenTimeoutSeconds}
            duration_seconds: ${variationGenDurationSeconds}
            timeout_usage_ratio: ${variationGenTimeoutUsageRatio}
            timed_out: ${variationGenTimedOut}
            status: "FAILED"
            start_time: ${variationGenStartTime}
            end_time: ${variationGenEndTime}
          severity: "ERROR"
        next: log_variation_gen_error

    - log_variation_gen_error:
        call: sys.log
        args:
          text: ${errorMsg}
          severity: "ERROR"
        next: raise_variation_gen_error

    - raise_variation_gen_error:
        raise: ${errorMsg}

    # =========================================================================
    # Check if any assets were generated before proceeding
    # =========================================================================

    - check_variation_assets_exist:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: '${variationAssetsPrefix + "/variation_assets.json"}'
            alt: "media"
          result: variationAssetsJsonRaw
        except:
          as: e
          steps:
            - no_assets_generated_missing_file:
                call: sys.log
                args:
                  text: '${"No variation assets were generated for scene " + sceneId + " - pipeline complete"}'
                  severity: "INFO"
                next: set_pipeline_status_no_assets
        next: parse_variation_assets_json

    - parse_variation_assets_json:
        assign:
          - variationAssetsJson: ${json.decode(variationAssetsJsonRaw)}
          - variationAssetCount: '${len(default(map.get(variationAssetsJson, "objects"), []))}'
        next: variation_assets_count_switch

    - variation_assets_count_switch:
        switch:
          - condition: ${variationAssetCount > 0}
            next: init_simready_metrics
        next: no_assets_generated

    - no_assets_generated:
        call: sys.log
        args:
          text: '${"No variation asset objects were generated for scene " + sceneId + " - skipping variation simready/refresh"}'
          severity: "INFO"
        next: set_pipeline_status_no_assets

    - set_pipeline_status_no_assets:
        assign:
          - pipelineStatus: "SUCCESS_NO_ASSETS"
          - variationAssetCount: 0
        next: ensure_at_least_one_isaac_pass

    # =========================================================================
    # Stage 2: Add physics properties to variation assets
    # =========================================================================

    - init_simready_metrics:
        assign:
          - simreadyStartTime: '${time.format(sys.now())}'
        next: emit_simready_metrics_start

    - emit_simready_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "variation-assets-pipeline"
            job: ${simreadyJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${simreadyTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${simreadyStartTime}
          severity: "INFO"
        next: run_simready_job

    - run_simready_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + simreadyJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: '${sceneId + "_variation"}'
                      - name: ASSETS_PREFIX
                        value: ${variationAssetsPrefix}
                      - name: SIMREADY_PHYSICS_MODE
                        value: "deterministic"
                      - name: PROGRESS_MARKER_PATH
                        value: ${variationAssetsProgressMarker}
                      - name: RESUME_FROM_PROGRESS
                        value: '${if(resumeFromProgress, "true", "false")}'
              timeout: '${string(simreadyTimeoutSeconds) + "s"}'
          result: simreadyExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_simready_retry_exhausted:
                call: sys.log
                args:
                  data:
                    bp_metric: "job_retry_exhausted"
                    workflow: "variation-assets-pipeline"
                    job: ${simreadyJobName}
                    scene_id: ${sceneId}
                    retry_max: 5
                    error: ${e.message}
                  severity: "ERROR"
            - log_simready_job_error:
                call: sys.log
                args:
                  text: '${"Failed to start simready job after retries: " + e.message}'
                  severity: "ERROR"
            - list_variation_simready_outputs_for_cleanup:
                call: googleapis.storage.v1.objects.list
                args:
                  bucket: ${bucket}
                  prefix: ${variationAssetsPrefix + "/"}
                  maxResults: 1000
                result: variationSimreadyCleanupList
            - delete_variation_simready_outputs_for_cleanup:
                for:
                  value: variationSimreadyCleanupItem
                  in: ${default(variationSimreadyCleanupList.items, [])}
                  steps:
                    - delete_variation_simready_output:
                        call: googleapis.storage.v1.objects.delete
                        args:
                          bucket: ${bucket}
                          object: ${variationSimreadyCleanupItem.name}
            - write_variation_simready_failure_marker:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${variationSimreadyFailedMarker}
                  uploadType: "media"
                  body: ${json.encode({
                    "scene_id": sceneId,
                    "job_name": simreadyJobName,
                    "status": "failed",
                    "timestamp": time.format(sys.now()),
                    "error": {
                      "code": "variation_simready_start_failed",
                      "message": e.message,
                      "type": "workflow_failure",
                      "stack_trace": null
                    },
                    "context": {
                      "workflow_execution_id": sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID"),
                      "attempt_number": 1,
                      "config_context": {
                        "variation_assets_prefix": variationAssetsPrefix
                      }
                    }
                  })}
            - raise_simready_job_error:
                raise: ${e}
        next: set_simready_execution_name

    - set_simready_execution_name:
        assign:
          - simreadyExecutionName: '${if(simreadyExec.metadata != null and simreadyExec.metadata.name != null, simreadyExec.metadata.name, simreadyExec.name)}'
        next: wait_for_simready

    - wait_for_simready:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${simreadyExecutionName}
        result: simreadyStatus
        next: check_simready_status

    - check_simready_status:
        assign:
          - simreadyState: '${if(simreadyStatus.state != null, simreadyStatus.state, if(simreadyStatus.status != null, simreadyStatus.status.state, null))}'
          - simreadyFailedCount: '${if(simreadyStatus.failedCount != null, simreadyStatus.failedCount, if(simreadyStatus.status != null, simreadyStatus.status.failedCount, null))}'
          - simreadySucceededCount: '${if(simreadyStatus.succeededCount != null, simreadyStatus.succeededCount, if(simreadyStatus.status != null, simreadyStatus.status.succeededCount, null))}'
        next: simready_status_switch

    - simready_status_switch:
        switch:
          - condition: '${simreadyState == "FAILED" or (simreadyFailedCount != null and simreadyFailedCount > 0)}'
            next: simready_failed
          - condition: '${simreadyState == "SUCCEEDED" or (simreadySucceededCount != null and simreadySucceededCount > 0)}'
            next: log_simready_complete
        next: wait_simready_poll

    - wait_simready_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_simready

    - log_simready_complete:
        assign:
          - simreadyEndTime: '${time.format(sys.now())}'
          - simreadyDurationSeconds: '${time.parse(simreadyEndTime) - time.parse(simreadyStartTime)}'
          - simreadyTimeoutUsageRatio: '${simreadyDurationSeconds / simreadyTimeoutSeconds}'
          - simreadyTimedOut: '${simreadyDurationSeconds >= simreadyTimeoutSeconds}'
        next: emit_simready_metrics_complete

    - emit_simready_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            job: ${simreadyJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${simreadyTimeoutSeconds}
            duration_seconds: ${simreadyDurationSeconds}
            timeout_usage_ratio: ${simreadyTimeoutUsageRatio}
            timed_out: ${simreadyTimedOut}
            status: "SUCCEEDED"
            start_time: ${simreadyStartTime}
            end_time: ${simreadyEndTime}
          severity: "INFO"
        next: log_simready_complete_message

    - log_simready_complete_message:
        call: sys.log
        args:
          text: '${"Simready job completed for scene " + sceneId + " variation assets"}'
          severity: "INFO"
        next: update_progress_after_simready

    - update_progress_after_simready:
        try:
          call: googleapis.storage.v1.objects.insert
          args:
            bucket: ${bucket}
            name: ${variationAssetsProgressMarker}
            uploadType: "media"
            body: ${json.encode({
              "scene_id": sceneId,
              "variation_assets_prefix": variationAssetsPrefix,
              "updated_at": time.format(sys.now()),
              "stages_completed": ["variation_gen", "simready"],
              "variation_asset_count": variationAssetCount
            })}
        except:
          as: progressErr
          steps:
            - log_progress_update_warning:
                call: sys.log
                args:
                  text: '${"WARNING: Failed to update progress marker after simready for " + sceneId + ": " + progressErr.message}'
                  severity: "WARNING"
        next: init_isaac_refresh_gate

    - simready_failed:
        assign:
          - simreadyEndTime: '${time.format(sys.now())}'
          - simreadyDurationSeconds: '${time.parse(simreadyEndTime) - time.parse(simreadyStartTime)}'
          - simreadyTimeoutUsageRatio: '${simreadyDurationSeconds / simreadyTimeoutSeconds}'
          - simreadyTimedOut: '${simreadyDurationSeconds >= simreadyTimeoutSeconds}'
        next: emit_simready_metrics_failed

    - emit_simready_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            job: ${simreadyJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${simreadyTimeoutSeconds}
            duration_seconds: ${simreadyDurationSeconds}
            timeout_usage_ratio: ${simreadyTimeoutUsageRatio}
            timed_out: ${simreadyTimedOut}
            status: "FAILED"
            start_time: ${simreadyStartTime}
            end_time: ${simreadyEndTime}
          severity: "WARNING"
        next: log_simready_failed_message

    - log_simready_failed_message:
        call: sys.log
        args:
          text: '${"WARNING: Simready job failed for scene " + sceneId + " variation assets - assets may not have physics properties"}'
          severity: "WARNING"
        next: ensure_at_least_one_isaac_pass

    - init_isaac_refresh_gate:
        assign:
          - isaacRefreshState: "SKIPPED"
        next: stage3_isaac_refresh_switch

    - stage3_isaac_refresh_switch:
        switch:
          - condition: '${enableStage3IsaacRefresh and variationAssetCount > 0}'
            next: init_isaac_refresh_metrics
        next: ensure_at_least_one_isaac_pass

    - init_isaac_refresh_metrics:
        assign:
          - isaacRefreshStartTime: '${time.format(sys.now())}'
        next: emit_isaac_refresh_metrics_start

    - emit_isaac_refresh_metrics_start:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "start"
            workflow: "variation-assets-pipeline"
            job: ${isaacLabJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${isaacLabTimeoutSeconds}
            duration_seconds: 0
            timeout_usage_ratio: 0
            timed_out: false
            status: "STARTED"
            start_time: ${isaacRefreshStartTime}
            mode: "refresh_only"
          severity: "INFO"
        next: run_isaac_refresh_job

    - run_isaac_refresh_job:
        try:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + isaacLabJobName}'
            body:
              overrides:
                containerOverrides:
                  - env:
                      - name: BUCKET
                        value: ${bucket}
                      - name: SCENE_ID
                        value: ${sceneId}
                      - name: ASSETS_PREFIX
                        value: ${assetsPrefix}
                      - name: USD_PREFIX
                        value: ${usdPrefix}
                      - name: REPLICATOR_PREFIX
                        value: ${replicatorPrefix}
                      - name: ISAAC_LAB_PREFIX
                        value: ${isaacLabPrefix}
                      - name: VARIATION_ASSETS_PREFIX
                        value: ${variationAssetsPrefix}
                      - name: ISAAC_REFRESH_ONLY
                        value: "true"
                      - name: RUN_RUNTIME_VALIDATION
                        value: "false"
              timeout: '${string(isaacLabTimeoutSeconds) + "s"}'
          result: isaacRefreshExec
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 5  # default per policy_configs/retry_policy.yaml
          backoff:
            initial_delay: 1
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_isaac_refresh_start_error:
                call: sys.log
                args:
                  text: '${"WARNING: Failed to start Isaac refresh job after retries for scene " + sceneId + ": " + e.message}'
                  severity: "WARNING"
            - set_isaac_refresh_failed_on_start:
                assign:
                  - isaacRefreshState: "FAILED"
        next: check_isaac_refresh_start_failure

    - check_isaac_refresh_start_failure:
        switch:
          - condition: '${isaacRefreshState == "FAILED"}'
            next: ensure_at_least_one_isaac_pass
        next: set_isaac_refresh_execution_name

    - set_isaac_refresh_execution_name:
        assign:
          - isaacRefreshExecutionName: '${if(isaacRefreshExec.metadata != null and isaacRefreshExec.metadata.name != null, isaacRefreshExec.metadata.name, isaacRefreshExec.name)}'
        next: wait_for_isaac_refresh

    - wait_for_isaac_refresh:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${isaacRefreshExecutionName}
        result: isaacRefreshStatus
        next: check_isaac_refresh_status

    - check_isaac_refresh_status:
        assign:
          - isaacRefreshJobState: '${if(isaacRefreshStatus.state != null, isaacRefreshStatus.state, if(isaacRefreshStatus.status != null, isaacRefreshStatus.status.state, null))}'
          - isaacRefreshFailedCount: '${if(isaacRefreshStatus.failedCount != null, isaacRefreshStatus.failedCount, if(isaacRefreshStatus.status != null, isaacRefreshStatus.status.failedCount, null))}'
          - isaacRefreshSucceededCount: '${if(isaacRefreshStatus.succeededCount != null, isaacRefreshStatus.succeededCount, if(isaacRefreshStatus.status != null, isaacRefreshStatus.status.succeededCount, null))}'
        next: isaac_refresh_status_switch

    - isaac_refresh_status_switch:
        switch:
          - condition: '${isaacRefreshJobState == "FAILED" or (isaacRefreshFailedCount != null and isaacRefreshFailedCount > 0)}'
            next: isaac_refresh_failed
          - condition: '${isaacRefreshJobState == "SUCCEEDED" or (isaacRefreshSucceededCount != null and isaacRefreshSucceededCount > 0)}'
            next: log_isaac_refresh_complete
        next: wait_isaac_refresh_poll

    - wait_isaac_refresh_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_isaac_refresh

    - log_isaac_refresh_complete:
        assign:
          - isaacRefreshEndTime: '${time.format(sys.now())}'
          - isaacRefreshDurationSeconds: '${time.parse(isaacRefreshEndTime) - time.parse(isaacRefreshStartTime)}'
          - isaacRefreshTimeoutUsageRatio: '${isaacRefreshDurationSeconds / isaacLabTimeoutSeconds}'
          - isaacRefreshTimedOut: '${isaacRefreshDurationSeconds >= isaacLabTimeoutSeconds}'
          - isaacRefreshState: "SUCCEEDED"
        next: emit_isaac_refresh_metrics_complete

    - emit_isaac_refresh_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            job: ${isaacLabJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${isaacLabTimeoutSeconds}
            duration_seconds: ${isaacRefreshDurationSeconds}
            timeout_usage_ratio: ${isaacRefreshTimeoutUsageRatio}
            timed_out: ${isaacRefreshTimedOut}
            status: "SUCCEEDED"
            start_time: ${isaacRefreshStartTime}
            end_time: ${isaacRefreshEndTime}
            mode: "refresh_only"
          severity: "INFO"
        next: log_isaac_refresh_complete_message

    - log_isaac_refresh_complete_message:
        call: sys.log
        args:
          text: '${"Isaac refresh-only pass completed for scene " + sceneId}'
          severity: "INFO"
        next: verify_isaac_refresh_marker

    - verify_isaac_refresh_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${isaacLabRefreshCompleteObject}
          result: isaacRefreshMarkerObject
        except:
          as: e
          steps:
            - log_isaac_refresh_marker_missing:
                call: sys.log
                args:
                  text: '${"WARNING: Isaac refresh marker missing for scene " + sceneId + ": " + e.message}'
                  severity: "WARNING"
            - set_isaac_refresh_failed_missing_marker:
                assign:
                  - isaacRefreshState: "FAILED"
        next: ensure_at_least_one_isaac_pass

    - isaac_refresh_failed:
        assign:
          - isaacRefreshEndTime: '${time.format(sys.now())}'
          - isaacRefreshDurationSeconds: '${time.parse(isaacRefreshEndTime) - time.parse(isaacRefreshStartTime)}'
          - isaacRefreshTimeoutUsageRatio: '${isaacRefreshDurationSeconds / isaacLabTimeoutSeconds}'
          - isaacRefreshTimedOut: '${isaacRefreshDurationSeconds >= isaacLabTimeoutSeconds}'
          - isaacRefreshState: "FAILED"
        next: emit_isaac_refresh_metrics_failed

    - emit_isaac_refresh_metrics_failed:
        call: sys.log
        args:
          data:
            bp_metric: "job_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            job: ${isaacLabJobName}
            scene_id: ${sceneId}
            timeout_seconds: ${isaacLabTimeoutSeconds}
            duration_seconds: ${isaacRefreshDurationSeconds}
            timeout_usage_ratio: ${isaacRefreshTimeoutUsageRatio}
            timed_out: ${isaacRefreshTimedOut}
            status: "FAILED"
            start_time: ${isaacRefreshStartTime}
            end_time: ${isaacRefreshEndTime}
            mode: "refresh_only"
          severity: "WARNING"
        next: ensure_at_least_one_isaac_pass

    - ensure_at_least_one_isaac_pass:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: '${isaacLabPrefix + "/.isaac_lab_complete"}'
          result: isaacBaselineMarker
        except:
          as: e
          steps:
            - set_isaac_baseline_missing:
                assign:
                  - isaacBaselinePresent: false
        next: set_isaac_baseline_present

    - set_isaac_baseline_present:
        assign:
          - isaacBaselinePresent: '${default(isaacBaselinePresent, true)}'
        next: enforce_isaac_required_gate

    - enforce_isaac_required_gate:
        switch:
          - condition: '${requireIsaac and not isaacBaselinePresent and isaacRefreshState != "SUCCEEDED"}'
            next: fail_missing_required_isaac
        next: finalize_isaac_success_path

    - finalize_isaac_success_path:
        switch:
          - condition: '${pipelineStatus == "SUCCESS_NO_ASSETS"}'
            next: write_completion_marker
        next: set_pipeline_status_success

    - set_pipeline_status_success:
        assign:
          - pipelineStatus: "SUCCESS"
        next: write_completion_marker

    - fail_missing_required_isaac:
        assign:
          - pipelineStatus: "FAILED_REQUIRED_ISAAC"
          - errorMsg: '${"No successful Isaac pass for scene " + sceneId + " (baseline_present=" + string(isaacBaselinePresent) + ", refresh_state=" + isaacRefreshState + ", require_isaac=true)"}'
        next: raise_missing_required_isaac

    - raise_missing_required_isaac:
        raise: ${errorMsg}

    # =========================================================================
    # Write completion marker and finish
    # =========================================================================

    - write_completion_marker:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: '${variationAssetsPrefix + "/.variation_pipeline_complete"}'
          body:
            contentType: "text/plain"
          uploadType: "media"
          data: '${"Completed at " + time.format(sys.now())}'
        result: markerResult
        next: finalize_pipeline_metrics

    - finalize_pipeline_metrics:
        assign:
          - pipelineEndTime: '${time.format(sys.now())}'
          - pipelineDurationSeconds: '${time.parse(pipelineEndTime) - time.parse(pipelineStartTime)}'
          - pipelineTimeoutUsageRatio: '${pipelineDurationSeconds / pipelineTimeoutSeconds}'
          - pipelineTimedOut: '${pipelineDurationSeconds >= pipelineTimeoutSeconds}'
        next: emit_pipeline_metrics_complete

    - emit_pipeline_metrics_complete:
        call: sys.log
        args:
          data:
            bp_metric: "pipeline_invocation"
            event: "complete"
            workflow: "variation-assets-pipeline"
            scene_id: ${sceneId}
            timeout_seconds: ${pipelineTimeoutSeconds}
            duration_seconds: ${pipelineDurationSeconds}
            timeout_usage_ratio: ${pipelineTimeoutUsageRatio}
            timed_out: ${pipelineTimedOut}
            status: ${pipelineStatus}
            start_time: ${pipelineStartTime}
            end_time: ${pipelineEndTime}
          severity: "INFO"
        next: pipeline_metrics_complete_switch

    - pipeline_metrics_complete_switch:
        switch:
          - condition: '${pipelineStatus == "SUCCESS_NO_ASSETS"}'
            next: done_no_assets
        next: done

    # =========================================================================
    # Completion states
    # =========================================================================

    - done:
        return:
          status: "SUCCESS"
          scene_id: ${sceneId}
          message: '${"Variation assets pipeline completed for scene " + sceneId}'
          variation_gen_execution: ${variationGenExec.name}
          simready_execution: ${simreadyExec.name}
          isaac_refresh_execution: ${isaacRefreshExecutionName}
          outputs:
            variation_assets: '${variationAssetsPrefix}'
            assets_json: '${variationAssetsPrefix + "/variation_assets.json"}'

    - done_no_assets:
        return:
          status: "SUCCESS_NO_ASSETS"
          scene_id: ${sceneId}
          message: '${"No variation assets to generate for scene " + sceneId}'
          variation_gen_execution: ${variationGenExec.name}

    - skip:
        return:
          status: "SKIPPED"
          message: '${"Not a replicator completion marker: " + object}'
