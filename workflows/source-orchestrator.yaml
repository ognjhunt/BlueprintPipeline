# source-orchestrator.yaml
#
# Text-first source orchestrator.
#
# Trigger:
#   GCS object finalized for scenes/{scene_id}/prompts/scene_request.json
#
# Behavior:
#   - source_mode=text: run text Stage 1 jobs, then Stage 2-5
#   - source_mode=image: delegate to image compatibility path
#   - source_mode=auto: prefer text, fallback to image when configured and available
#
# Stage 2-5 remains canonical and unchanged:
#   - usd-assembly-pipeline
#   - variation-assets-pipeline
#   - genie-sim-export-pipeline
#   - arena-export-pipeline (required by default; env-tunable)

main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - objectGeneration: '${if(event.data.generation != null, string(event.data.generation), "0")}'
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: ${default(sys.get_env("WORKFLOW_REGION"), "us-central1")}
          - defaultSourceMode: '${text.lower(default(sys.get_env("DEFAULT_SOURCE_MODE"), "text"))}'
          - textBackendDefault: '${text.lower(default(sys.get_env("TEXT_BACKEND_DEFAULT"), "sage"))}'
          - textBackendAllowlist: '${text.lower(default(sys.get_env("TEXT_BACKEND_ALLOWLIST"), "internal,scenesmith,sage,hybrid_serial"))}'
          - textGenRuntime: '${text.lower(default(sys.get_env("TEXT_GEN_RUNTIME"), "vm"))}'
          - textSceneGenJobName: '${default(sys.get_env("TEXT_SCENE_GEN_JOB_NAME"), "text-scene-gen-job")}'
          - textSceneAdapterJobName: '${default(sys.get_env("TEXT_SCENE_ADAPTER_JOB_NAME"), "text-scene-adapter-job")}'
          - textGenStandardProfile: '${default(sys.get_env("TEXT_GEN_STANDARD_PROFILE"), "standard_v1")}'
          - textGenPremiumProfile: '${default(sys.get_env("TEXT_GEN_PREMIUM_PROFILE"), "premium_v1")}'
          - textGenUseLlm: '${text.lower(default(sys.get_env("TEXT_GEN_USE_LLM"), "true"))}'
          - textGenLlmMaxAttempts: '${default(sys.get_env("TEXT_GEN_LLM_MAX_ATTEMPTS"), "3")}'
          - textGenLlmRetryBackoffSeconds: '${default(sys.get_env("TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS"), "2")}'
          - textAssetRetrievalEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_RETRIEVAL_ENABLED"), "true"))}'
          - textAssetLibraryPrefixes: '${default(sys.get_env("TEXT_ASSET_LIBRARY_PREFIXES"), "scenes")}'
          - textAssetLibraryMaxFiles: '${default(sys.get_env("TEXT_ASSET_LIBRARY_MAX_FILES"), "2500")}'
          - textAssetLibraryMinScore: '${default(sys.get_env("TEXT_ASSET_LIBRARY_MIN_SCORE"), "0.25")}'
          - textAssetRetrievalMode: '${text.lower(default(sys.get_env("TEXT_ASSET_RETRIEVAL_MODE"), "ann_shadow"))}'
          - textAssetAnnEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_ANN_ENABLED"), "true"))}'
          - textAssetAnnTopK: '${default(sys.get_env("TEXT_ASSET_ANN_TOP_K"), "40")}'
          - textAssetAnnMinScore: '${default(sys.get_env("TEXT_ASSET_ANN_MIN_SCORE"), "0.28")}'
          - textAssetAnnMaxRerank: '${default(sys.get_env("TEXT_ASSET_ANN_MAX_RERANK"), "20")}'
          - textAssetAnnNamespace: '${default(sys.get_env("TEXT_ASSET_ANN_NAMESPACE"), "assets-v1")}'
          - textAssetLexicalFallbackEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_LEXICAL_FALLBACK_ENABLED"), "true"))}'
          - textAssetRolloutStatePrefix: '${default(sys.get_env("TEXT_ASSET_ROLLOUT_STATE_PREFIX"), "automation/asset_retrieval_rollout")}'
          - textAssetRolloutMinDecisions: '${default(sys.get_env("TEXT_ASSET_ROLLOUT_MIN_DECISIONS"), "500")}'
          - textAssetRolloutMinHitRate: '${default(sys.get_env("TEXT_ASSET_ROLLOUT_MIN_HIT_RATE"), "0.95")}'
          - textAssetRolloutMaxErrorRate: '${default(sys.get_env("TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE"), "0.01")}'
          - textAssetRolloutMaxP95Ms: '${default(sys.get_env("TEXT_ASSET_ROLLOUT_MAX_P95_MS"), "400")}'
          - textAssetEmbeddingQueuePrefix: '${default(sys.get_env("TEXT_ASSET_EMBEDDING_QUEUE_PREFIX"), "automation/asset_embedding/queue")}'
          - textAssetEmbeddingProcessedPrefix: '${default(sys.get_env("TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX"), "automation/asset_embedding/processed")}'
          - textAssetEmbeddingFailedPrefix: '${default(sys.get_env("TEXT_ASSET_EMBEDDING_FAILED_PREFIX"), "automation/asset_embedding/failed")}'
          - textAssetEmbeddingModel: '${default(sys.get_env("TEXT_ASSET_EMBEDDING_MODEL"), "text-embedding-3-small")}'
          - vectorStoreProvider: '${default(sys.get_env("VECTOR_STORE_PROVIDER"), "vertex")}'
          - vectorStoreProjectId: '${default(sys.get_env("VECTOR_STORE_PROJECT_ID"), projectId)}'
          - vectorStoreLocation: '${default(sys.get_env("VECTOR_STORE_LOCATION"), region)}'
          - vectorStoreNamespace: '${default(sys.get_env("VECTOR_STORE_NAMESPACE"), "assets-v1")}'
          - vectorStoreDimension: '${default(sys.get_env("VECTOR_STORE_DIMENSION"), "1536")}'
          - vertexIndexEndpoint: '${default(sys.get_env("VERTEX_INDEX_ENDPOINT"), "")}'
          - vertexDeployedIndexId: '${default(sys.get_env("VERTEX_DEPLOYED_INDEX_ID"), "")}'
          - textAssetCatalogEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_CATALOG_ENABLED"), "true"))}'
          - textAssetReplicationEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_REPLICATION_ENABLED"), "true"))}'
          - textAssetReplicationQueuePrefix: '${default(sys.get_env("TEXT_ASSET_REPLICATION_QUEUE_PREFIX"), "automation/asset_replication/queue")}'
          - textAssetReplicationTarget: '${default(sys.get_env("TEXT_ASSET_REPLICATION_TARGET"), "backblaze_b2")}'
          - textAssetReplicationTargetPrefix: '${default(sys.get_env("TEXT_ASSET_REPLICATION_TARGET_PREFIX"), "assets")}'
          - textAssetGenerationEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_GENERATION_ENABLED"), "true"))}'
          - textAssetGenerationProvider: '${text.lower(default(sys.get_env("TEXT_ASSET_GENERATION_PROVIDER"), "sam3d"))}'
          - textAssetGenerationProviderChain: '${text.lower(default(sys.get_env("TEXT_ASSET_GENERATION_PROVIDER_CHAIN"), "sam3d,hunyuan3d"))}'
          - textAssetGeneratedCacheEnabled: '${text.lower(default(sys.get_env("TEXT_ASSET_GENERATED_CACHE_ENABLED"), "true"))}'
          - textAssetGeneratedCachePrefix: '${default(sys.get_env("TEXT_ASSET_GENERATED_CACHE_PREFIX"), "asset-library/generated-text")}'
          - textSam3dApiHost: '${default(sys.get_env("TEXT_SAM3D_API_HOST"), "")}'
          - textSam3dTextEndpoints: '${default(sys.get_env("TEXT_SAM3D_TEXT_ENDPOINTS"), "/openapi/v1/text-to-3d,/v1/text-to-3d")}'
          - textSam3dTimeoutSeconds: '${default(sys.get_env("TEXT_SAM3D_TIMEOUT_SECONDS"), "1800")}'
          - textSam3dPollSeconds: '${default(sys.get_env("TEXT_SAM3D_POLL_SECONDS"), "10")}'
          - textHunyuanApiHost: '${default(sys.get_env("TEXT_HUNYUAN_API_HOST"), "")}'
          - textHunyuanTextEndpoints: '${default(sys.get_env("TEXT_HUNYUAN_TEXT_ENDPOINTS"), "/openapi/v1/text-to-3d,/v1/text-to-3d")}'
          - textHunyuanTimeoutSeconds: '${default(sys.get_env("TEXT_HUNYUAN_TIMEOUT_SECONDS"), "1800")}'
          - textHunyuanPollSeconds: '${default(sys.get_env("TEXT_HUNYUAN_POLL_SECONDS"), "10")}'
          - textGenMaxSeeds: '${int(default(sys.get_env("TEXT_GEN_MAX_SEEDS"), "16"))}'
          - textGenEnableImageFallback: '${text.lower(default(sys.get_env("TEXT_GEN_ENABLE_IMAGE_FALLBACK"), "true")) == "true"}'
          - arenaExportRequired: '${text.lower(default(sys.get_env("ARENA_EXPORT_REQUIRED"), "true")) == "true"}'
          - imagePathMode: '${text.lower(default(sys.get_env("IMAGE_PATH_MODE"), "orchestrator"))}'
          - imageOrchestratorWorkflow: '${default(sys.get_env("IMAGE_ORCHESTRATOR_WORKFLOW_NAME"), "image-to-scene-orchestrator")}'
          - imageLegacyWorkflow: '${default(sys.get_env("IMAGE_LEGACY_WORKFLOW_NAME"), "image-to-scene-pipeline")}'
          - imageLegacyWaitSeconds: '${int(default(sys.get_env("IMAGE_LEGACY_CHAIN_WAIT_SECONDS"), "7200"))}'
          - textVmName: '${default(sys.get_env("TEXT_GEN_VM_NAME"), "isaac-sim-ubuntu")}'
          - textVmZone: '${default(sys.get_env("TEXT_GEN_VM_ZONE"), "us-east1-c")}'
          - textVmRepoDir: '${default(sys.get_env("TEXT_GEN_VM_REPO_DIR"), "~/BlueprintPipeline")}'
          - textVmTimeoutSeconds: '${int(default(sys.get_env("TEXT_GEN_VM_TIMEOUT_SECONDS"), "2400"))}'
          - sageRuntimeMode: '${text.lower(default(sys.get_env("SAGE_RUNTIME_MODE"), "cloudrun"))}'
          - sageServerUrl: '${default(sys.get_env("SAGE_SERVER_URL"), "")}'
          - sageTimeoutSeconds: '${default(sys.get_env("SAGE_TIMEOUT_SECONDS"), "900")}'
          - scenesmithRuntimeMode: '${text.lower(default(sys.get_env("SCENESMITH_RUNTIME_MODE"), "cloudrun"))}'
          - scenesmithServerUrl: '${default(sys.get_env("SCENESMITH_SERVER_URL"), "")}'
          - scenesmithTimeoutSeconds: '${default(sys.get_env("SCENESMITH_TIMEOUT_SECONDS"), "1800")}'
          - textSageActionDemoEnabled: '${text.lower(default(sys.get_env("TEXT_SAGE_ACTION_DEMO_ENABLED"), "false"))}'
          - workflowName: "source-orchestrator"
          - startTime: '${time.format(sys.now())}'
          - fallbackUsed: false
          - completedVariants: 0
          - cloudrunFallbackCount: 0
          - lockAcquired: false
          - requestSourceMode: "unknown"
          - requestTextBackend: "sage"
          - qualityTier: "standard"
          - providerPolicy: "openai_primary"
          - errorCode: ""
          - errorMsg: ""
          - failedStage: ""
        next: filter_prompt_requests

    - filter_prompt_requests:
        switch:
          - condition: '${text.match_regex(object, "^scenes/[^/]+/prompts/scene_request\\.json$")}'
            next: derive
        next: skip

    - derive:
        assign:
          - parts: '${text.split(object, "/")}'
          - sceneId: ${parts[1]}
          - scenePrefix: '${"scenes/" + sceneId}'
          - completionMarker: '${scenePrefix + "/.source_orchestrator_complete"}'
          - failureMarker: '${scenePrefix + "/.source_orchestrator_failed"}'
          - variantsIndexObject: '${scenePrefix + "/variants/index.json"}'
          - geniesimCompleteObject: '${scenePrefix + "/geniesim/.geniesim_complete"}'
          - lockObject: '${scenePrefix + "/locks/source-orchestrator-" + objectGeneration + ".lock"}'
        next: acquire_lock

    - acquire_lock:
        try:
          call: googleapis.storage.v1.objects.insert
          args:
            bucket: ${bucket}
            name: ${lockObject}
            uploadType: "media"
            ifGenerationMatch: 0
            body: '${json.encode({
              "scene_id": sceneId,
              "workflow": workflowName,
              "input_object": object,
              "input_generation": objectGeneration,
              "timestamp": time.format(sys.now())
            })}'
          result: lockInsertResult
        except:
          as: lockErr
          steps:
            - lock_conflict_switch:
                switch:
                  - condition: '${lockErr.code == 412 or lockErr.code == 409}'
                    next: skip_duplicate_generation
                next: set_lock_acquire_error
            - set_lock_acquire_error:
                assign:
                  - errorCode: "lock_acquire_failed"
                  - errorMsg: '${"Failed to acquire source orchestrator lock for scene " + sceneId + ": " + lockErr.message}'
                  - failedStage: "lock_acquisition"
                next: write_failure_and_raise
        next: set_lock_acquired

    - skip_duplicate_generation:
        return:
          status: "SKIPPED"
          scene_id: ${sceneId}
          message: '${"Duplicate event for generation " + objectGeneration + " (lock exists at " + lockObject + ")"}'

    - set_lock_acquired:
        assign:
          - lockAcquired: true
        next: clear_previous_failure_marker

    - clear_previous_failure_marker:
        try:
          call: googleapis.storage.v1.objects.delete
          args:
            bucket: ${bucket}
            object: ${failureMarker}
        except:
          as: deleteFailureErr
          steps:
            - ignore_missing_failure_marker:
                switch:
                  - condition: '${deleteFailureErr.code == 404}'
                    next: read_request
            - log_failure_marker_delete_warning:
                call: sys.log
                args:
                  text: '${"Failed to clear prior failure marker: " + deleteFailureErr.message}'
                  severity: "WARNING"
        next: read_request

    - read_request:
        call: googleapis.storage.v1.objects.get
        args:
          bucket: ${bucket}
          object: ${object}
          alt: "media"
        result: requestRaw
        next: parse_request_payload

    - parse_request_payload:
        try:
          assign:
            - sceneRequest: '${json.decode(requestRaw)}'
        except:
          as: requestDecodeErr
          steps:
            - set_request_decode_error:
                assign:
                  - errorCode: "invalid_scene_request"
                  - errorMsg: '${"scene_request.json is not valid JSON for scene " + sceneId + ": " + requestDecodeErr.message}'
                  - failedStage: "source_request_validation"
                next: write_failure_and_raise
        next: parse_request_typed

    - parse_request_typed:
        try:
          assign:
            - requestSchemaVersion: '${string(default(map.get(sceneRequest, "schema_version"), ""))}'
            - requestSceneId: '${string(default(map.get(sceneRequest, "scene_id"), ""))}'
            - requestSourceMode: '${text.lower(string(default(map.get(sceneRequest, "source_mode"), defaultSourceMode)))}'
            - requestTextBackendRaw: '${text.lower(string(default(map.get(sceneRequest, "text_backend"), textBackendDefault)))}'
            - requestTextBackend: '${if(requestTextBackendRaw == "", textBackendDefault, requestTextBackendRaw)}'
            - primarySourceMode: '${if(requestSourceMode == "auto", "text", requestSourceMode)}'
            - qualityTier: '${text.lower(string(default(map.get(sceneRequest, "quality_tier"), "standard")))}'
            - providerPolicy: '${string(default(map.get(sceneRequest, "provider_policy"), "openai_primary"))}'
            - seedCount: '${int(default(map.get(sceneRequest, "seed_count"), 1))}'
            - prompt: '${string(default(map.get(sceneRequest, "prompt"), ""))}'
            - constraints: '${default(map.get(sceneRequest, "constraints"), {})}'
            - fallbackConfig: '${default(map.get(sceneRequest, "fallback"), {})}'
            - allowImageFallbackRaw: '${default(map.get(fallbackConfig, "allow_image_fallback"), true)}'
            - allowImageFallbackString: '${text.lower(string(allowImageFallbackRaw))}'
            - allowImageFallbackRequest: '${allowImageFallbackString != "false" and allowImageFallbackString != "0" and allowImageFallbackString != "no" and allowImageFallbackString != "off"}'
            - allowImageFallback: '${allowImageFallbackRequest and textGenEnableImageFallback}'
            - imagePayload: '${default(map.get(sceneRequest, "image"), {})}'
            - imageGcsUri: '${string(default(map.get(imagePayload, "gcs_uri"), ""))}'
            - imageGeneration: '${if(map.get(imagePayload, "generation") != null, string(map.get(imagePayload, "generation")), objectGeneration)}'
            - imageObjectCandidate: '${if(imageGcsUri == "", "", if(text.match_regex(imageGcsUri, "^gs://"), if(text.match_regex(imageGcsUri, "^gs://" + bucket + "/"), text.replace_all(imageGcsUri, "gs://" + bucket + "/", ""), ""), imageGcsUri))}'
        except:
          as: requestParseErr
          steps:
            - set_request_parse_error:
                assign:
                  - errorCode: "invalid_scene_request"
                  - errorMsg: '${"scene_request.json parse failure for scene " + sceneId + ": " + requestParseErr.message}'
                  - failedStage: "source_request_validation"
                next: write_failure_and_raise
        next: validate_request

    - validate_request:
        switch:
          - condition: '${requestSchemaVersion != "v1"}'
            next: invalid_request
          - condition: '${requestSceneId == "" or requestSceneId != sceneId}'
            next: invalid_request
          - condition: '${requestSourceMode != "text" and requestSourceMode != "image" and requestSourceMode != "auto"}'
            next: invalid_request
          - condition: '${requestSourceMode != "image" and (requestTextBackend != "internal" and requestTextBackend != "scenesmith" and requestTextBackend != "sage" and requestTextBackend != "hybrid_serial")}'
            next: invalid_request
          - condition: '${requestSourceMode != "image" and not(text.match_regex("," + textBackendAllowlist + ",", ".*," + requestTextBackend + ",.*"))}'
            next: invalid_request
          - condition: '${qualityTier != "standard" and qualityTier != "premium"}'
            next: invalid_request
          - condition: '${providerPolicy != "openai_primary"}'
            next: invalid_request
          - condition: '${(requestSourceMode == "text" or requestSourceMode == "auto") and prompt == ""}'
            next: invalid_request
          - condition: '${requestSourceMode == "image" and imageGcsUri == ""}'
            next: invalid_request
          - condition: '${seedCount < 1}'
            next: invalid_request
          - condition: '${seedCount > textGenMaxSeeds}'
            next: invalid_request
        next: source_mode_switch

    - invalid_request:
        assign:
          - errorCode: "invalid_scene_request"
          - errorMsg: '${"scene_request.json validation failed for scene " + sceneId}'
          - failedStage: "source_request_validation"
        next: write_failure_and_raise

    - source_mode_switch:
        switch:
          - condition: '${primarySourceMode == "image"}'
            next: run_image_mode
        next: init_text_mode

    - run_image_mode:
        switch:
          - condition: '${imageObjectCandidate != "" and text.match_regex(imageObjectCandidate, "^scenes/[^/]+/images/[^/]+\\.([Pp][Nn][Gg]|[Jj][Pp][Ee]?[Gg])$")}'
            next: delegate_image_mode
        next: invalid_image_path

    - invalid_image_path:
        assign:
          - errorCode: "invalid_image_uri"
          - errorMsg: '${"Image source_mode requested but image.gcs_uri is invalid or not in bucket " + bucket + ": " + imageGcsUri}'
          - failedStage: "source_request_validation"
        next: write_failure_and_raise

    - delegate_image_mode:
        call: run_image_path_compat
        args:
          projectId: ${projectId}
          region: ${region}
          bucket: ${bucket}
          imageObject: ${imageObjectCandidate}
          generation: ${imageGeneration}
          imagePathMode: ${imagePathMode}
          imageOrchestratorWorkflow: ${imageOrchestratorWorkflow}
          imageLegacyWorkflow: ${imageLegacyWorkflow}
          geniesimCompleteObject: ${geniesimCompleteObject}
          legacyWaitTimeoutSeconds: ${imageLegacyWaitSeconds}
        result: imageResult
        next: write_completion_marker_image

    - write_completion_marker_image:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${completionMarker}
          uploadType: "media"
          body: '${json.encode({
            "scene_id": sceneId,
            "status": "completed",
            "source_type": "image",
            "requested_source_mode": requestSourceMode,
            "requested_text_backend": requestTextBackend,
            "seed_count": seedCount,
            "fallback_used": false,
            "text_gen_runtime": textGenRuntime,
            "image_path_mode": imageResult.mode,
            "image_workflow": imageResult.workflow_name,
            "timestamp": time.format(sys.now())
          })}'
        next: release_lock_before_done_image

    - release_lock_before_done_image:
        call: release_source_lock_if_needed
        args:
          bucket: ${bucket}
          lockObject: ${lockObject}
          lockAcquired: ${lockAcquired}
        next: done_image

    - done_image:
        return:
          status: "SUCCESS"
          source_type: "image"
          scene_id: ${sceneId}
          seed_count: ${seedCount}
          fallback_used: false
          image_path_mode: ${imageResult.mode}
          image_workflow: ${imageResult.workflow_name}

    - init_text_mode:
        assign:
          - seedIndex: 1
          - variantsEntriesJson: ""
        next: text_seed_loop_check

    - text_seed_loop_check:
        switch:
          - condition: '${seedIndex <= seedCount}'
            next: text_seed_prepare
        next: write_variants_index

    - text_seed_prepare:
        assign:
          - seedSuffix: '${if(seedIndex < 10, "00" + string(seedIndex), if(seedIndex < 100, "0" + string(seedIndex), string(seedIndex)))}'
          - childSceneId: '${if(seedCount > 1, sceneId + "-s" + seedSuffix, sceneId)}'
          - childScenePrefix: '${"scenes/" + childSceneId}'
          - childRequestObject: '${if(seedCount > 1, childScenePrefix + "/internal/scene_request.generated.json", object)}'
          - shouldWriteChildRequest: '${seedCount > 1}'
          - childTextgenPrefix: '${childScenePrefix + "/textgen"}'
          - childAssetsPrefix: '${childScenePrefix + "/assets"}'
          - childLayoutPrefix: '${childScenePrefix + "/layout"}'
          - childSegPrefix: '${childScenePrefix + "/seg"}'
        next: process_text_seed

    # NOTE: Fail-fast fallback behavior — if ANY seed fails in this loop,
    # the except block jumps to fallback_to_image_mode (when enabled).
    # Remaining seeds are NOT retried individually. The image path replaces
    # the entire text generation for the parent scene_id.
    - process_text_seed:
        try:
          steps:
            - maybe_write_child_request:
                switch:
                  - condition: ${shouldWriteChildRequest}
                    next: write_child_request
                next: run_text_stage1_for_child
            - write_child_request:
                call: googleapis.storage.v1.objects.insert
                args:
                  bucket: ${bucket}
                  name: ${childRequestObject}
                  uploadType: "media"
                  body: '${json.encode({
                    "schema_version": "v1",
                    "scene_id": childSceneId,
                    "source_mode": "text",
                    "text_backend": requestTextBackend,
                    "prompt": prompt,
                    "quality_tier": qualityTier,
                    "seed_count": 1,
                    "constraints": constraints,
                    "provider_policy": providerPolicy,
                    "fallback": {"allow_image_fallback": allowImageFallback}
                  })}'
                next: run_text_stage1_for_child
            - run_text_stage1_for_child:
                call: run_text_stage1_for_child
                args:
                  projectId: ${projectId}
                  region: ${region}
                  bucket: ${bucket}
                  childSceneId: ${childSceneId}
                  childRequestObject: ${childRequestObject}
                  childTextgenPrefix: ${childTextgenPrefix}
                  childAssetsPrefix: ${childAssetsPrefix}
                  childLayoutPrefix: ${childLayoutPrefix}
                  childSegPrefix: ${childSegPrefix}
                  seedIndex: ${seedIndex}
                  textGenRuntime: ${textGenRuntime}
                  textGenMaxSeeds: ${textGenMaxSeeds}
                  textGenStandardProfile: ${textGenStandardProfile}
                  textGenPremiumProfile: ${textGenPremiumProfile}
                  textGenUseLlm: ${textGenUseLlm}
                  textGenLlmMaxAttempts: ${textGenLlmMaxAttempts}
                  textGenLlmRetryBackoffSeconds: ${textGenLlmRetryBackoffSeconds}
                  textAssetRetrievalEnabled: ${textAssetRetrievalEnabled}
                  textAssetLibraryPrefixes: ${textAssetLibraryPrefixes}
                  textAssetLibraryMaxFiles: ${textAssetLibraryMaxFiles}
                  textAssetLibraryMinScore: ${textAssetLibraryMinScore}
                  textAssetRetrievalMode: ${textAssetRetrievalMode}
                  textAssetAnnEnabled: ${textAssetAnnEnabled}
                  textAssetAnnTopK: ${textAssetAnnTopK}
                  textAssetAnnMinScore: ${textAssetAnnMinScore}
                  textAssetAnnMaxRerank: ${textAssetAnnMaxRerank}
                  textAssetAnnNamespace: ${textAssetAnnNamespace}
                  textAssetLexicalFallbackEnabled: ${textAssetLexicalFallbackEnabled}
                  textAssetRolloutStatePrefix: ${textAssetRolloutStatePrefix}
                  textAssetRolloutMinDecisions: ${textAssetRolloutMinDecisions}
                  textAssetRolloutMinHitRate: ${textAssetRolloutMinHitRate}
                  textAssetRolloutMaxErrorRate: ${textAssetRolloutMaxErrorRate}
                  textAssetRolloutMaxP95Ms: ${textAssetRolloutMaxP95Ms}
                  textAssetEmbeddingQueuePrefix: ${textAssetEmbeddingQueuePrefix}
                  textAssetEmbeddingProcessedPrefix: ${textAssetEmbeddingProcessedPrefix}
                  textAssetEmbeddingFailedPrefix: ${textAssetEmbeddingFailedPrefix}
                  textAssetEmbeddingModel: ${textAssetEmbeddingModel}
                  vectorStoreProvider: ${vectorStoreProvider}
                  vectorStoreProjectId: ${vectorStoreProjectId}
                  vectorStoreLocation: ${vectorStoreLocation}
                  vectorStoreNamespace: ${vectorStoreNamespace}
                  vectorStoreDimension: ${vectorStoreDimension}
                  vertexIndexEndpoint: ${vertexIndexEndpoint}
                  vertexDeployedIndexId: ${vertexDeployedIndexId}
                  textAssetCatalogEnabled: ${textAssetCatalogEnabled}
                  textAssetReplicationEnabled: ${textAssetReplicationEnabled}
                  textAssetReplicationQueuePrefix: ${textAssetReplicationQueuePrefix}
                  textAssetReplicationTarget: ${textAssetReplicationTarget}
                  textAssetReplicationTargetPrefix: ${textAssetReplicationTargetPrefix}
                  textAssetGenerationEnabled: ${textAssetGenerationEnabled}
                  textAssetGenerationProvider: ${textAssetGenerationProvider}
                  textAssetGenerationProviderChain: ${textAssetGenerationProviderChain}
                  textAssetGeneratedCacheEnabled: ${textAssetGeneratedCacheEnabled}
                  textAssetGeneratedCachePrefix: ${textAssetGeneratedCachePrefix}
                  textSam3dApiHost: ${textSam3dApiHost}
                  textSam3dTextEndpoints: ${textSam3dTextEndpoints}
                  textSam3dTimeoutSeconds: ${textSam3dTimeoutSeconds}
                  textSam3dPollSeconds: ${textSam3dPollSeconds}
                  textHunyuanApiHost: ${textHunyuanApiHost}
                  textHunyuanTextEndpoints: ${textHunyuanTextEndpoints}
                  textHunyuanTimeoutSeconds: ${textHunyuanTimeoutSeconds}
                  textHunyuanPollSeconds: ${textHunyuanPollSeconds}
                  textVmName: ${textVmName}
                  textVmZone: ${textVmZone}
                  textVmRepoDir: ${textVmRepoDir}
                  textVmTimeoutSeconds: ${textVmTimeoutSeconds}
                result: textStageResult
                next: maybe_count_runtime_fallback
            - maybe_count_runtime_fallback:
                switch:
                  - condition: '${default(textStageResult.fallback_to_cloudrun, false)}'
                    next: increment_runtime_fallback_count
                next: run_downstream_for_child
            - increment_runtime_fallback_count:
                assign:
                  - cloudrunFallbackCount: ${cloudrunFallbackCount + 1}
                next: run_downstream_for_child
            - run_downstream_for_child:
                call: run_stage2_to_stage5
                args:
                  projectId: ${projectId}
                  region: ${region}
                  bucket: ${bucket}
                  sceneId: ${childSceneId}
                  arenaExportRequired: ${arenaExportRequired}
                  imagePathMode: ${imagePathMode}
                result: downstreamStatus
                next: append_variant_entry
            - append_variant_entry:
                assign:
                  - variantEntryJson: '${"{\"scene_id\":\"" + childSceneId + "\",\"seed\":" + string(seedIndex) + "}"}'
                  - variantsEntriesJson: '${variantsEntriesJson + if(seedIndex > 1, ",", "") + variantEntryJson}'
                  - completedVariants: ${completedVariants + 1}
        except:
          as: textSeedErr
          steps:
            - log_text_seed_failure:
                call: sys.log
                args:
                  text: '${"Text source failed for child " + childSceneId + ": " + textSeedErr.message}'
                  severity: "ERROR"
            - maybe_fallback_switch:
                switch:
                  - condition: '${allowImageFallback and imageObjectCandidate != "" and text.match_regex(imageObjectCandidate, "^scenes/[^/]+/images/[^/]+\\.([Pp][Nn][Gg]|[Jj][Pp][Ee]?[Gg])$")}'
                    next: fallback_to_image_mode
            - set_text_failure_error:
                assign:
                  - errorCode: "text_stage_failed"
                  - errorMsg: '${"text source failed for scene " + childSceneId + ": " + textSeedErr.message}'
                  - failedStage: "text_source_generation"
                next: write_failure_and_raise
        next: increment_seed

    - increment_seed:
        assign:
          - seedIndex: ${seedIndex + 1}
        next: text_seed_loop_check

    - fallback_to_image_mode:
        call: run_image_path_compat
        args:
          projectId: ${projectId}
          region: ${region}
          bucket: ${bucket}
          imageObject: ${imageObjectCandidate}
          generation: ${imageGeneration}
          imagePathMode: ${imagePathMode}
          imageOrchestratorWorkflow: ${imageOrchestratorWorkflow}
          imageLegacyWorkflow: ${imageLegacyWorkflow}
          geniesimCompleteObject: ${geniesimCompleteObject}
          legacyWaitTimeoutSeconds: ${imageLegacyWaitSeconds}
        result: imageFallbackResult
        next: write_completion_marker_fallback

    - write_completion_marker_fallback:
        assign:
          - fallbackUsed: true
        next: write_completion_marker_fallback_object

    - write_completion_marker_fallback_object:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${completionMarker}
          uploadType: "media"
          body: '${json.encode({
            "scene_id": sceneId,
            "status": "completed",
            "source_type": "image_fallback",
            "requested_source_mode": requestSourceMode,
            "requested_text_backend": requestTextBackend,
            "seed_count": seedCount,
            "completed_variants": completedVariants,
            "fallback_used": true,
            "fallback_image_object": imageObjectCandidate,
            "text_gen_runtime": textGenRuntime,
            "image_path_mode": imageFallbackResult.mode,
            "image_workflow": imageFallbackResult.workflow_name,
            "timestamp": time.format(sys.now())
          })}'
        next: release_lock_before_done_fallback

    - release_lock_before_done_fallback:
        call: release_source_lock_if_needed
        args:
          bucket: ${bucket}
          lockObject: ${lockObject}
          lockAcquired: ${lockAcquired}
        next: done_fallback

    - done_fallback:
        return:
          status: "SUCCESS"
          source_type: "image_fallback"
          scene_id: ${sceneId}
          seed_count: ${seedCount}
          completed_variants: ${completedVariants}
          fallback_used: true
          image_path_mode: ${imageFallbackResult.mode}
          image_workflow: ${imageFallbackResult.workflow_name}

    - write_variants_index:
        switch:
          - condition: '${seedCount > 1}'
            next: write_variants_index_object
        next: write_completion_marker_text

    - write_variants_index_object:
        assign:
          - variantsIndexJson: '${"{\"schema_version\":\"v1\",\"scene_id\":\"" + sceneId + "\",\"source_mode\":\"" + requestSourceMode + "\",\"text_backend\":\"" + requestTextBackend + "\",\"quality_tier\":\"" + qualityTier + "\",\"provider_policy\":\"" + providerPolicy + "\",\"seed_count\":" + string(seedCount) + ",\"variants\":[" + variantsEntriesJson + "]}"}'
        next: upload_variants_index

    - upload_variants_index:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${variantsIndexObject}
          uploadType: "media"
          body: ${variantsIndexJson}
        next: write_completion_marker_text

    - write_completion_marker_text:
        call: googleapis.storage.v1.objects.insert
        args:
          bucket: ${bucket}
          name: ${completionMarker}
          uploadType: "media"
          body: '${json.encode({
            "scene_id": sceneId,
            "status": "completed",
            "source_type": "text",
            "requested_source_mode": requestSourceMode,
            "requested_text_backend": requestTextBackend,
            "quality_tier": qualityTier,
            "provider_policy": providerPolicy,
            "seed_count": seedCount,
            "completed_variants": completedVariants,
            "fallback_used": false,
            "text_gen_runtime": textGenRuntime,
            "cloudrun_fallback_count": cloudrunFallbackCount,
            "timestamp": time.format(sys.now())
          })}'
        next: release_lock_before_done_text

    - release_lock_before_done_text:
        call: release_source_lock_if_needed
        args:
          bucket: ${bucket}
          lockObject: ${lockObject}
          lockAcquired: ${lockAcquired}
        next: done_text

    - done_text:
        return:
          status: "SUCCESS"
          source_type: "text"
          scene_id: ${sceneId}
          seed_count: ${seedCount}
          completed_variants: ${completedVariants}
          fallback_used: false
          cloudrun_fallback_count: ${cloudrunFallbackCount}

    - write_failure_and_raise:
        assign:
          - failureBody:
              scene_id: ${sceneId}
              status: "failed"
              timestamp: '${time.format(sys.now())}'
              input_object: ${object}
              input_generation: ${objectGeneration}
              source_mode: ${requestSourceMode}
              text_backend: ${requestTextBackend}
              failed_stage: ${failedStage}
              error:
                code: ${errorCode}
                message: ${errorMsg}
                type: "source_orchestrator_failure"
              context:
                workflow_execution_id: '${sys.get_env("GOOGLE_CLOUD_WORKFLOW_EXECUTION_ID")}'
                completed_variants: ${completedVariants}
                fallback_used: ${fallbackUsed}
                lock_object: ${lockObject}
                lock_acquired: ${lockAcquired}
        next: write_failure_marker

    - write_failure_marker:
        try:
          call: googleapis.storage.v1.objects.insert
          args:
            bucket: ${bucket}
            name: ${failureMarker}
            uploadType: "media"
            body: '${json.encode(failureBody)}'
        except:
          as: writeFailureErr
          steps:
            - log_failure_marker_write_error:
                call: sys.log
                args:
                  text: '${"Failed to write source orchestrator failure marker: " + writeFailureErr.message}'
                  severity: "WARNING"
        next: release_lock_before_raise

    - release_lock_before_raise:
        call: release_source_lock_if_needed
        args:
          bucket: ${bucket}
          lockObject: ${lockObject}
          lockAcquired: ${lockAcquired}
        next: raise_failure

    - raise_failure:
        raise: '${"[" + failedStage + "] " + errorMsg}'

    - skip:
        return:
          status: "SKIPPED"
          message: '${"Not a scene_request trigger: " + object}'


run_cloud_run_job_and_wait:
  params: [projectId, region, jobName, timeoutSeconds, envVars]
  steps:
    - run_job:
        call: googleapis.run.v2.projects.locations.jobs.run
        args:
          name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + jobName}'
          body:
            overrides:
              containerOverrides:
                - env: ${envVars}
            timeout: '${string(timeoutSeconds) + "s"}'
        result: jobExec
        next: set_execution_name

    - set_execution_name:
        assign:
          - executionName: '${if(jobExec.metadata != null and jobExec.metadata.name != null, jobExec.metadata.name, jobExec.name)}'
        next: wait_for_job

    - wait_for_job:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${executionName}
        result: jobStatus
        next: check_job_status

    - check_job_status:
        assign:
          - jobState: '${if(jobStatus.state != null, jobStatus.state, if(jobStatus.status != null, jobStatus.status.state, null))}'
          - jobFailedCount: '${if(jobStatus.failedCount != null, jobStatus.failedCount, if(jobStatus.status != null, jobStatus.status.failedCount, null))}'
          - jobSucceededCount: '${if(jobStatus.succeededCount != null, jobStatus.succeededCount, if(jobStatus.status != null, jobStatus.status.succeededCount, null))}'
        next: job_status_switch

    - job_status_switch:
        switch:
          - condition: '${jobState == "FAILED" or (jobFailedCount != null and jobFailedCount > 0)}'
            next: raise_job_failed
          - condition: '${jobState == "SUCCEEDED" or (jobSucceededCount != null and jobSucceededCount > 0)}'
            next: return_job_success
        next: wait_poll

    - wait_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_job

    - raise_job_failed:
        raise: '${"Cloud Run job failed: " + jobName + " (" + executionName + ")"}'

    - return_job_success:
        return:
          execution_name: ${executionName}
          state: ${jobState}


run_workflow_and_wait:
  params: [projectId, region, workflowName, argument, pollIntervalSeconds]
  steps:
    - call_workflow:
        call: googleapis.workflowexecutions.v1.projects.locations.workflows.executions.create
        args:
          parent: '${"projects/" + projectId + "/locations/" + region + "/workflows/" + workflowName}'
          body:
            argument: '${json.encode(argument)}'
        result: workflowExecution
        next: poll_workflow

    - poll_workflow:
        call: googleapis.workflowexecutions.v1.projects.locations.workflows.executions.get
        args:
          name: ${workflowExecution.name}
        result: workflowStatus
        next: workflow_status_switch

    - workflow_status_switch:
        switch:
          - condition: '${workflowStatus.state == "SUCCEEDED"}'
            next: return_workflow_success
          - condition: '${workflowStatus.state == "FAILED" or workflowStatus.state == "CANCELLED"}'
            next: raise_workflow_failed
        next: wait_workflow_poll

    - wait_workflow_poll:
        call: sys.sleep
        args:
          seconds: ${pollIntervalSeconds}
        next: poll_workflow

    - raise_workflow_failed:
        raise: '${"Sub-workflow failed: " + workflowName + " (" + workflowStatus.state + ")"}'

    - return_workflow_success:
        return:
          name: ${workflowExecution.name}
          state: ${workflowStatus.state}
          result: '${if(default(workflowStatus.result, "") == "", {}, json.decode(workflowStatus.result))}'


run_stage2_to_stage5:
  params: [projectId, region, bucket, sceneId, arenaExportRequired, imagePathMode]
  steps:
    - derive:
        assign:
          - scenePrefix: '${"scenes/" + sceneId}'
          - geniesimState: "SKIPPED"
          - arenaState: "SKIPPED"
        next: validate_stage1_outputs

    # Pre-Stage 2: validate that Stage 1 produced the required scene_manifest.json
    - validate_stage1_outputs:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: '${scenePrefix + "/assets/scene_manifest.json"}'
          result: manifestCheck
        except:
          as: e
          steps:
            - log_manifest_missing:
                call: sys.log
                args:
                  text: '${"FATAL: scene_manifest.json missing for " + sceneId + " at " + scenePrefix + "/assets/scene_manifest.json — Stage 1 output incomplete, cannot proceed to Stage 2"}'
                  severity: "ERROR"
            - raise_manifest_missing:
                raise: '${"Stage 1 output incomplete: scene_manifest.json missing for " + sceneId}'
        next: run_stage2

    - run_stage2:
        call: run_workflow_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          workflowName: "usd-assembly-pipeline"
          pollIntervalSeconds: 30
          argument:
            data:
              bucket: ${bucket}
              name: '${scenePrefix + "/assets/.regen3d_complete"}'
            interactive_failure_policy: "hybrid_strict"
            require_replicator: true
            require_isaac: true
        result: usdResult
        next: run_stage3

    - run_stage3:
        call: run_workflow_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          workflowName: "variation-assets-pipeline"
          pollIntervalSeconds: 30
          argument:
            data:
              bucket: ${bucket}
              name: '${scenePrefix + "/replicator/.replicator_complete"}'
            enable_stage3_isaac_refresh: true
            require_isaac: true
        result: variationResult
        next: downstream_execution_mode_switch

    - downstream_execution_mode_switch:
        switch:
          - condition: '${imagePathMode == "legacy_chain"}'
            next: delegate_stage4_stage5_to_eventarc
        next: run_stage4

    - delegate_stage4_stage5_to_eventarc:
        assign:
          - geniesimState: "DELEGATED_TO_EVENTARC"
          - arenaState: "DELEGATED_TO_EVENTARC"
        next: return_summary

    - run_stage4:
        call: run_workflow_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          workflowName: "genie-sim-export-pipeline"
          pollIntervalSeconds: 30
          argument:
            data:
              bucket: ${bucket}
              name: '${scenePrefix + "/variation_assets/.variation_pipeline_complete"}'
        result: geniesimResult
        next: set_stage4_success

    - set_stage4_success:
        assign:
          - geniesimState: "SUCCEEDED"
        next: run_stage5_requirement_switch

    - run_stage5_requirement_switch:
        switch:
          - condition: ${arenaExportRequired}
            next: run_stage5_required
        next: run_stage5_non_blocking

    - run_stage5_required:
        call: run_workflow_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          workflowName: "arena-export-pipeline"
          pollIntervalSeconds: 30
          argument:
            data:
              bucket: ${bucket}
              name: '${scenePrefix + "/geniesim/.geniesim_complete"}'
        result: arenaRequiredResult
        next: set_required_arena_status

    - set_required_arena_status:
        assign:
          - arenaRequiredStatus: '${default(map.get(default(arenaRequiredResult.result, {}), "status"), "UNKNOWN")}'
        next: required_stage5_status_switch

    - required_stage5_status_switch:
        switch:
          - condition: '${arenaRequiredStatus == "SUCCESS"}'
            next: return_required_stage5_success
        next: raise_required_stage5_non_success

    - return_required_stage5_success:
        assign:
          - arenaState: "SUCCEEDED"
        next: return_summary

    - raise_required_stage5_non_success:
        raise: '${"Arena export returned non-success status for scene " + sceneId + " (status=" + arenaRequiredStatus + ", required=true)"}'

    - run_stage5_non_blocking:
        try:
          call: run_workflow_and_wait
          args:
            projectId: ${projectId}
            region: ${region}
            workflowName: "arena-export-pipeline"
            pollIntervalSeconds: 30
            argument:
              data:
                bucket: ${bucket}
                name: '${scenePrefix + "/geniesim/.geniesim_complete"}'
          result: arenaResult
        except:
          as: arenaErr
          steps:
            - log_arena_warning:
                call: sys.log
                args:
                  text: '${"[source-orchestrator] arena export non-blocking failure for " + sceneId + ": " + arenaErr.message}'
                  severity: "WARNING"
            - set_arena_failed:
                assign:
                  - arenaState: "FAILED"
                next: return_summary
        next: set_non_blocking_arena_status

    - set_non_blocking_arena_status:
        assign:
          - arenaStatus: '${default(map.get(default(arenaResult.result, {}), "status"), "UNKNOWN")}'
        next: non_blocking_stage5_status_switch

    - non_blocking_stage5_status_switch:
        switch:
          - condition: '${arenaStatus == "SUCCESS"}'
            next: set_non_blocking_arena_success
          - condition: '${arenaStatus == "SKIPPED"}'
            next: set_non_blocking_arena_skipped
        next: log_non_blocking_arena_non_success

    - set_non_blocking_arena_success:
        assign:
          - arenaState: "SUCCEEDED"
        next: return_summary

    - set_non_blocking_arena_skipped:
        assign:
          - arenaState: "SKIPPED"
        next: return_summary

    - log_non_blocking_arena_non_success:
        call: sys.log
        args:
          text: '${"[source-orchestrator] arena export non-blocking returned non-success status for " + sceneId + ": " + arenaStatus}'
          severity: "WARNING"
        next: set_non_blocking_arena_failed

    - set_non_blocking_arena_failed:
        assign:
          - arenaState: "FAILED"
        next: return_summary

    - return_summary:
        return:
          scene_id: ${sceneId}
          usd_assembly: "SUCCEEDED"
          variation_assets: "SUCCEEDED"
          geniesim_export: ${geniesimState}
          arena_export: ${arenaState}
          arena_required: ${arenaExportRequired}


run_text_stage1_for_child:
  params: [projectId, region, bucket, childSceneId, childRequestObject, childTextgenPrefix, childAssetsPrefix, childLayoutPrefix, childSegPrefix, seedIndex, textGenRuntime, textGenMaxSeeds, textGenStandardProfile, textGenPremiumProfile, textGenUseLlm, textGenLlmMaxAttempts, textGenLlmRetryBackoffSeconds, textAssetRetrievalEnabled, textAssetLibraryPrefixes, textAssetLibraryMaxFiles, textAssetLibraryMinScore, textAssetRetrievalMode, textAssetAnnEnabled, textAssetAnnTopK, textAssetAnnMinScore, textAssetAnnMaxRerank, textAssetAnnNamespace, textAssetLexicalFallbackEnabled, textAssetRolloutStatePrefix, textAssetRolloutMinDecisions, textAssetRolloutMinHitRate, textAssetRolloutMaxErrorRate, textAssetRolloutMaxP95Ms, textAssetEmbeddingQueuePrefix, textAssetEmbeddingProcessedPrefix, textAssetEmbeddingFailedPrefix, textAssetEmbeddingModel, vectorStoreProvider, vectorStoreProjectId, vectorStoreLocation, vectorStoreNamespace, vectorStoreDimension, vertexIndexEndpoint, vertexDeployedIndexId, textAssetCatalogEnabled, textAssetReplicationEnabled, textAssetReplicationQueuePrefix, textAssetReplicationTarget, textAssetReplicationTargetPrefix, textAssetGenerationEnabled, textAssetGenerationProvider, textAssetGenerationProviderChain, textAssetGeneratedCacheEnabled, textAssetGeneratedCachePrefix, textSam3dApiHost, textSam3dTextEndpoints, textSam3dTimeoutSeconds, textSam3dPollSeconds, textHunyuanApiHost, textHunyuanTextEndpoints, textHunyuanTimeoutSeconds, textHunyuanPollSeconds, textVmName, textVmZone, textVmRepoDir, textVmTimeoutSeconds]
  steps:
    - runtime_switch:
        switch:
          - condition: '${textGenRuntime == "vm"}'
            next: run_vm_first
          - condition: '${textGenRuntime == "cloudrun"}'
            next: run_cloudrun_direct
        next: invalid_runtime

    - run_vm_first:
        try:
          call: run_text_jobs_on_vm
          args:
            projectId: ${projectId}
            region: ${region}
            bucket: ${bucket}
            childSceneId: ${childSceneId}
            childRequestObject: ${childRequestObject}
            childTextgenPrefix: ${childTextgenPrefix}
            childAssetsPrefix: ${childAssetsPrefix}
            childLayoutPrefix: ${childLayoutPrefix}
            childSegPrefix: ${childSegPrefix}
            seedIndex: ${seedIndex}
            textGenMaxSeeds: ${textGenMaxSeeds}
            textGenStandardProfile: ${textGenStandardProfile}
            textGenPremiumProfile: ${textGenPremiumProfile}
            textGenUseLlm: ${textGenUseLlm}
            textGenLlmMaxAttempts: ${textGenLlmMaxAttempts}
            textGenLlmRetryBackoffSeconds: ${textGenLlmRetryBackoffSeconds}
            textAssetRetrievalEnabled: ${textAssetRetrievalEnabled}
            textAssetLibraryPrefixes: ${textAssetLibraryPrefixes}
            textAssetLibraryMaxFiles: ${textAssetLibraryMaxFiles}
            textAssetLibraryMinScore: ${textAssetLibraryMinScore}
            textAssetRetrievalMode: ${textAssetRetrievalMode}
            textAssetAnnEnabled: ${textAssetAnnEnabled}
            textAssetAnnTopK: ${textAssetAnnTopK}
            textAssetAnnMinScore: ${textAssetAnnMinScore}
            textAssetAnnMaxRerank: ${textAssetAnnMaxRerank}
            textAssetAnnNamespace: ${textAssetAnnNamespace}
            textAssetLexicalFallbackEnabled: ${textAssetLexicalFallbackEnabled}
            textAssetRolloutStatePrefix: ${textAssetRolloutStatePrefix}
            textAssetRolloutMinDecisions: ${textAssetRolloutMinDecisions}
            textAssetRolloutMinHitRate: ${textAssetRolloutMinHitRate}
            textAssetRolloutMaxErrorRate: ${textAssetRolloutMaxErrorRate}
            textAssetRolloutMaxP95Ms: ${textAssetRolloutMaxP95Ms}
            textAssetEmbeddingQueuePrefix: ${textAssetEmbeddingQueuePrefix}
            textAssetEmbeddingProcessedPrefix: ${textAssetEmbeddingProcessedPrefix}
            textAssetEmbeddingFailedPrefix: ${textAssetEmbeddingFailedPrefix}
            textAssetEmbeddingModel: ${textAssetEmbeddingModel}
            vectorStoreProvider: ${vectorStoreProvider}
            vectorStoreProjectId: ${vectorStoreProjectId}
            vectorStoreLocation: ${vectorStoreLocation}
            vectorStoreNamespace: ${vectorStoreNamespace}
            vectorStoreDimension: ${vectorStoreDimension}
            vertexIndexEndpoint: ${vertexIndexEndpoint}
            vertexDeployedIndexId: ${vertexDeployedIndexId}
            textAssetCatalogEnabled: ${textAssetCatalogEnabled}
            textAssetReplicationEnabled: ${textAssetReplicationEnabled}
            textAssetReplicationQueuePrefix: ${textAssetReplicationQueuePrefix}
            textAssetReplicationTarget: ${textAssetReplicationTarget}
            textAssetReplicationTargetPrefix: ${textAssetReplicationTargetPrefix}
            textAssetGenerationEnabled: ${textAssetGenerationEnabled}
            textAssetGenerationProvider: ${textAssetGenerationProvider}
            textAssetGenerationProviderChain: ${textAssetGenerationProviderChain}
            textAssetGeneratedCacheEnabled: ${textAssetGeneratedCacheEnabled}
            textAssetGeneratedCachePrefix: ${textAssetGeneratedCachePrefix}
            textSam3dApiHost: ${textSam3dApiHost}
            textSam3dTextEndpoints: ${textSam3dTextEndpoints}
            textSam3dTimeoutSeconds: ${textSam3dTimeoutSeconds}
            textSam3dPollSeconds: ${textSam3dPollSeconds}
            textHunyuanApiHost: ${textHunyuanApiHost}
            textHunyuanTextEndpoints: ${textHunyuanTextEndpoints}
            textHunyuanTimeoutSeconds: ${textHunyuanTimeoutSeconds}
            textHunyuanPollSeconds: ${textHunyuanPollSeconds}
            textVmName: ${textVmName}
            textVmZone: ${textVmZone}
            textVmRepoDir: ${textVmRepoDir}
            textVmTimeoutSeconds: ${textVmTimeoutSeconds}
          result: vmResult
        except:
          as: vmErr
          steps:
            - set_vm_err_message:
                assign:
                  - vmErrMessage: '${string(vmErr.message)}'
            - vm_error_switch:
                switch:
                  - condition: '${text.match_regex(vmErrMessage, "^\\[vm_transient\\].*")}'
                    next: run_cloudrun_after_vm_error
                next: rethrow_vm_error
            - rethrow_vm_error:
                raise: ${vmErrMessage}
        next: return_vm_result

    - run_cloudrun_after_vm_error:
        call: run_text_jobs_on_cloudrun
        args:
          projectId: ${projectId}
          region: ${region}
          bucket: ${bucket}
          childSceneId: ${childSceneId}
          childRequestObject: ${childRequestObject}
          childTextgenPrefix: ${childTextgenPrefix}
          childAssetsPrefix: ${childAssetsPrefix}
          childLayoutPrefix: ${childLayoutPrefix}
          childSegPrefix: ${childSegPrefix}
          seedIndex: ${seedIndex}
          textGenMaxSeeds: ${textGenMaxSeeds}
          textGenStandardProfile: ${textGenStandardProfile}
          textGenPremiumProfile: ${textGenPremiumProfile}
          textGenUseLlm: ${textGenUseLlm}
          textGenLlmMaxAttempts: ${textGenLlmMaxAttempts}
          textGenLlmRetryBackoffSeconds: ${textGenLlmRetryBackoffSeconds}
          textAssetRetrievalEnabled: ${textAssetRetrievalEnabled}
          textAssetLibraryPrefixes: ${textAssetLibraryPrefixes}
          textAssetLibraryMaxFiles: ${textAssetLibraryMaxFiles}
          textAssetLibraryMinScore: ${textAssetLibraryMinScore}
          textAssetRetrievalMode: ${textAssetRetrievalMode}
          textAssetAnnEnabled: ${textAssetAnnEnabled}
          textAssetAnnTopK: ${textAssetAnnTopK}
          textAssetAnnMinScore: ${textAssetAnnMinScore}
          textAssetAnnMaxRerank: ${textAssetAnnMaxRerank}
          textAssetAnnNamespace: ${textAssetAnnNamespace}
          textAssetLexicalFallbackEnabled: ${textAssetLexicalFallbackEnabled}
          textAssetRolloutStatePrefix: ${textAssetRolloutStatePrefix}
          textAssetRolloutMinDecisions: ${textAssetRolloutMinDecisions}
          textAssetRolloutMinHitRate: ${textAssetRolloutMinHitRate}
          textAssetRolloutMaxErrorRate: ${textAssetRolloutMaxErrorRate}
          textAssetRolloutMaxP95Ms: ${textAssetRolloutMaxP95Ms}
          textAssetEmbeddingQueuePrefix: ${textAssetEmbeddingQueuePrefix}
          textAssetEmbeddingProcessedPrefix: ${textAssetEmbeddingProcessedPrefix}
          textAssetEmbeddingFailedPrefix: ${textAssetEmbeddingFailedPrefix}
          textAssetEmbeddingModel: ${textAssetEmbeddingModel}
          vectorStoreProvider: ${vectorStoreProvider}
          vectorStoreProjectId: ${vectorStoreProjectId}
          vectorStoreLocation: ${vectorStoreLocation}
          vectorStoreNamespace: ${vectorStoreNamespace}
          vectorStoreDimension: ${vectorStoreDimension}
          vertexIndexEndpoint: ${vertexIndexEndpoint}
          vertexDeployedIndexId: ${vertexDeployedIndexId}
          textAssetCatalogEnabled: ${textAssetCatalogEnabled}
          textAssetReplicationEnabled: ${textAssetReplicationEnabled}
          textAssetReplicationQueuePrefix: ${textAssetReplicationQueuePrefix}
          textAssetReplicationTarget: ${textAssetReplicationTarget}
          textAssetReplicationTargetPrefix: ${textAssetReplicationTargetPrefix}
          textAssetGenerationEnabled: ${textAssetGenerationEnabled}
          textAssetGenerationProvider: ${textAssetGenerationProvider}
          textAssetGenerationProviderChain: ${textAssetGenerationProviderChain}
          textAssetGeneratedCacheEnabled: ${textAssetGeneratedCacheEnabled}
          textAssetGeneratedCachePrefix: ${textAssetGeneratedCachePrefix}
          textSam3dApiHost: ${textSam3dApiHost}
          textSam3dTextEndpoints: ${textSam3dTextEndpoints}
          textSam3dTimeoutSeconds: ${textSam3dTimeoutSeconds}
          textSam3dPollSeconds: ${textSam3dPollSeconds}
          textHunyuanApiHost: ${textHunyuanApiHost}
          textHunyuanTextEndpoints: ${textHunyuanTextEndpoints}
          textHunyuanTimeoutSeconds: ${textHunyuanTimeoutSeconds}
          textHunyuanPollSeconds: ${textHunyuanPollSeconds}
        result: cloudrunFallbackResult
        next: return_cloudrun_fallback

    - return_vm_result:
        return:
          runtime_used: "vm"
          fallback_to_cloudrun: false

    - return_cloudrun_fallback:
        return:
          runtime_used: "cloudrun"
          fallback_to_cloudrun: true
          fallback_reason: ${vmErrMessage}

    - run_cloudrun_direct:
        call: run_text_jobs_on_cloudrun
        args:
          projectId: ${projectId}
          region: ${region}
          bucket: ${bucket}
          childSceneId: ${childSceneId}
          childRequestObject: ${childRequestObject}
          childTextgenPrefix: ${childTextgenPrefix}
          childAssetsPrefix: ${childAssetsPrefix}
          childLayoutPrefix: ${childLayoutPrefix}
          childSegPrefix: ${childSegPrefix}
          seedIndex: ${seedIndex}
          textGenMaxSeeds: ${textGenMaxSeeds}
          textGenStandardProfile: ${textGenStandardProfile}
          textGenPremiumProfile: ${textGenPremiumProfile}
          textGenUseLlm: ${textGenUseLlm}
          textGenLlmMaxAttempts: ${textGenLlmMaxAttempts}
          textGenLlmRetryBackoffSeconds: ${textGenLlmRetryBackoffSeconds}
          textAssetRetrievalEnabled: ${textAssetRetrievalEnabled}
          textAssetLibraryPrefixes: ${textAssetLibraryPrefixes}
          textAssetLibraryMaxFiles: ${textAssetLibraryMaxFiles}
          textAssetLibraryMinScore: ${textAssetLibraryMinScore}
          textAssetRetrievalMode: ${textAssetRetrievalMode}
          textAssetAnnEnabled: ${textAssetAnnEnabled}
          textAssetAnnTopK: ${textAssetAnnTopK}
          textAssetAnnMinScore: ${textAssetAnnMinScore}
          textAssetAnnMaxRerank: ${textAssetAnnMaxRerank}
          textAssetAnnNamespace: ${textAssetAnnNamespace}
          textAssetLexicalFallbackEnabled: ${textAssetLexicalFallbackEnabled}
          textAssetRolloutStatePrefix: ${textAssetRolloutStatePrefix}
          textAssetRolloutMinDecisions: ${textAssetRolloutMinDecisions}
          textAssetRolloutMinHitRate: ${textAssetRolloutMinHitRate}
          textAssetRolloutMaxErrorRate: ${textAssetRolloutMaxErrorRate}
          textAssetRolloutMaxP95Ms: ${textAssetRolloutMaxP95Ms}
          textAssetEmbeddingQueuePrefix: ${textAssetEmbeddingQueuePrefix}
          textAssetEmbeddingProcessedPrefix: ${textAssetEmbeddingProcessedPrefix}
          textAssetEmbeddingFailedPrefix: ${textAssetEmbeddingFailedPrefix}
          textAssetEmbeddingModel: ${textAssetEmbeddingModel}
          vectorStoreProvider: ${vectorStoreProvider}
          vectorStoreProjectId: ${vectorStoreProjectId}
          vectorStoreLocation: ${vectorStoreLocation}
          vectorStoreNamespace: ${vectorStoreNamespace}
          vectorStoreDimension: ${vectorStoreDimension}
          vertexIndexEndpoint: ${vertexIndexEndpoint}
          vertexDeployedIndexId: ${vertexDeployedIndexId}
          textAssetCatalogEnabled: ${textAssetCatalogEnabled}
          textAssetReplicationEnabled: ${textAssetReplicationEnabled}
          textAssetReplicationQueuePrefix: ${textAssetReplicationQueuePrefix}
          textAssetReplicationTarget: ${textAssetReplicationTarget}
          textAssetReplicationTargetPrefix: ${textAssetReplicationTargetPrefix}
          textAssetGenerationEnabled: ${textAssetGenerationEnabled}
          textAssetGenerationProvider: ${textAssetGenerationProvider}
          textAssetGenerationProviderChain: ${textAssetGenerationProviderChain}
          textAssetGeneratedCacheEnabled: ${textAssetGeneratedCacheEnabled}
          textAssetGeneratedCachePrefix: ${textAssetGeneratedCachePrefix}
          textSam3dApiHost: ${textSam3dApiHost}
          textSam3dTextEndpoints: ${textSam3dTextEndpoints}
          textSam3dTimeoutSeconds: ${textSam3dTimeoutSeconds}
          textSam3dPollSeconds: ${textSam3dPollSeconds}
          textHunyuanApiHost: ${textHunyuanApiHost}
          textHunyuanTextEndpoints: ${textHunyuanTextEndpoints}
          textHunyuanTimeoutSeconds: ${textHunyuanTimeoutSeconds}
          textHunyuanPollSeconds: ${textHunyuanPollSeconds}
        result: cloudrunResult
        next: return_cloudrun_direct

    - return_cloudrun_direct:
        return:
          runtime_used: "cloudrun"
          fallback_to_cloudrun: false

    - invalid_runtime:
        raise: '${"Unsupported TEXT_GEN_RUNTIME: " + textGenRuntime}'


run_text_jobs_on_cloudrun:
  params: [projectId, region, bucket, childSceneId, childRequestObject, childTextgenPrefix, childAssetsPrefix, childLayoutPrefix, childSegPrefix, seedIndex, textGenMaxSeeds, textGenStandardProfile, textGenPremiumProfile, textGenUseLlm, textGenLlmMaxAttempts, textGenLlmRetryBackoffSeconds, textAssetRetrievalEnabled, textAssetLibraryPrefixes, textAssetLibraryMaxFiles, textAssetLibraryMinScore, textAssetRetrievalMode, textAssetAnnEnabled, textAssetAnnTopK, textAssetAnnMinScore, textAssetAnnMaxRerank, textAssetAnnNamespace, textAssetLexicalFallbackEnabled, textAssetRolloutStatePrefix, textAssetRolloutMinDecisions, textAssetRolloutMinHitRate, textAssetRolloutMaxErrorRate, textAssetRolloutMaxP95Ms, textAssetEmbeddingQueuePrefix, textAssetEmbeddingProcessedPrefix, textAssetEmbeddingFailedPrefix, textAssetEmbeddingModel, vectorStoreProvider, vectorStoreProjectId, vectorStoreLocation, vectorStoreNamespace, vectorStoreDimension, vertexIndexEndpoint, vertexDeployedIndexId, textAssetCatalogEnabled, textAssetReplicationEnabled, textAssetReplicationQueuePrefix, textAssetReplicationTarget, textAssetReplicationTargetPrefix, textAssetGenerationEnabled, textAssetGenerationProvider, textAssetGenerationProviderChain, textAssetGeneratedCacheEnabled, textAssetGeneratedCachePrefix, textSam3dApiHost, textSam3dTextEndpoints, textSam3dTimeoutSeconds, textSam3dPollSeconds, textHunyuanApiHost, textHunyuanTextEndpoints, textHunyuanTimeoutSeconds, textHunyuanPollSeconds]
  steps:
    - run_text_gen_job:
        call: run_cloud_run_job_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          jobName: '${default(sys.get_env("TEXT_SCENE_GEN_JOB_NAME"), "text-scene-gen-job")}'
          timeoutSeconds: 1800
          envVars:
            - name: BUCKET
              value: ${bucket}
            - name: SCENE_ID
              value: ${childSceneId}
            - name: REQUEST_OBJECT
              value: ${childRequestObject}
            - name: TEXTGEN_PREFIX
              value: ${childTextgenPrefix}
            - name: TEXT_SEED
              value: '${string(seedIndex)}'
            - name: DEFAULT_SOURCE_MODE
              value: "text"
            - name: TEXT_GEN_MAX_SEEDS
              value: '${string(textGenMaxSeeds)}'
            - name: TEXT_GEN_STANDARD_PROFILE
              value: ${textGenStandardProfile}
            - name: TEXT_GEN_PREMIUM_PROFILE
              value: ${textGenPremiumProfile}
            - name: TEXT_GEN_USE_LLM
              value: ${textGenUseLlm}
            - name: TEXT_GEN_LLM_MAX_ATTEMPTS
              value: ${textGenLlmMaxAttempts}
            - name: TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS
              value: ${textGenLlmRetryBackoffSeconds}
            - name: TEXT_GEN_RUNTIME
              value: "cloudrun"
            - name: TEXT_BACKEND_DEFAULT
              value: '${default(sys.get_env("TEXT_BACKEND_DEFAULT"), "sage")}'
            - name: TEXT_BACKEND_ALLOWLIST
              value: '${default(sys.get_env("TEXT_BACKEND_ALLOWLIST"), "internal,scenesmith,sage,hybrid_serial")}'
            - name: SAGE_RUNTIME_MODE
              value: '${default(sys.get_env("SAGE_RUNTIME_MODE"), "cloudrun")}'
            - name: SAGE_SERVER_URL
              value: '${default(sys.get_env("SAGE_SERVER_URL"), "")}'
            - name: SAGE_TIMEOUT_SECONDS
              value: '${default(sys.get_env("SAGE_TIMEOUT_SECONDS"), "900")}'
            - name: SCENESMITH_RUNTIME_MODE
              value: '${default(sys.get_env("SCENESMITH_RUNTIME_MODE"), "cloudrun")}'
            - name: SCENESMITH_SERVER_URL
              value: '${default(sys.get_env("SCENESMITH_SERVER_URL"), "")}'
            - name: SCENESMITH_TIMEOUT_SECONDS
              value: '${default(sys.get_env("SCENESMITH_TIMEOUT_SECONDS"), "1800")}'
            - name: TEXT_SAGE_ACTION_DEMO_ENABLED
              value: '${default(sys.get_env("TEXT_SAGE_ACTION_DEMO_ENABLED"), "false")}'
        result: textGenStatus
        next: run_text_adapter_job

    - run_text_adapter_job:
        call: run_cloud_run_job_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          jobName: '${default(sys.get_env("TEXT_SCENE_ADAPTER_JOB_NAME"), "text-scene-adapter-job")}'
          timeoutSeconds: 1800
          envVars:
            - name: BUCKET
              value: ${bucket}
            - name: SCENE_ID
              value: ${childSceneId}
            - name: REQUEST_OBJECT
              value: ${childRequestObject}
            - name: TEXTGEN_PREFIX
              value: ${childTextgenPrefix}
            - name: ASSETS_PREFIX
              value: ${childAssetsPrefix}
            - name: LAYOUT_PREFIX
              value: ${childLayoutPrefix}
            - name: SEG_PREFIX
              value: ${childSegPrefix}
            - name: TEXT_ASSET_RETRIEVAL_ENABLED
              value: ${textAssetRetrievalEnabled}
            - name: TEXT_ASSET_LIBRARY_PREFIXES
              value: ${textAssetLibraryPrefixes}
            - name: TEXT_ASSET_LIBRARY_MAX_FILES
              value: ${textAssetLibraryMaxFiles}
            - name: TEXT_ASSET_LIBRARY_MIN_SCORE
              value: ${textAssetLibraryMinScore}
            - name: TEXT_ASSET_RETRIEVAL_MODE
              value: ${textAssetRetrievalMode}
            - name: TEXT_ASSET_ANN_ENABLED
              value: ${textAssetAnnEnabled}
            - name: TEXT_ASSET_ANN_TOP_K
              value: ${textAssetAnnTopK}
            - name: TEXT_ASSET_ANN_MIN_SCORE
              value: ${textAssetAnnMinScore}
            - name: TEXT_ASSET_ANN_MAX_RERANK
              value: ${textAssetAnnMaxRerank}
            - name: TEXT_ASSET_ANN_NAMESPACE
              value: ${textAssetAnnNamespace}
            - name: TEXT_ASSET_LEXICAL_FALLBACK_ENABLED
              value: ${textAssetLexicalFallbackEnabled}
            - name: TEXT_ASSET_ROLLOUT_STATE_PREFIX
              value: ${textAssetRolloutStatePrefix}
            - name: TEXT_ASSET_ROLLOUT_MIN_DECISIONS
              value: ${textAssetRolloutMinDecisions}
            - name: TEXT_ASSET_ROLLOUT_MIN_HIT_RATE
              value: ${textAssetRolloutMinHitRate}
            - name: TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE
              value: ${textAssetRolloutMaxErrorRate}
            - name: TEXT_ASSET_ROLLOUT_MAX_P95_MS
              value: ${textAssetRolloutMaxP95Ms}
            - name: TEXT_ASSET_EMBEDDING_QUEUE_PREFIX
              value: ${textAssetEmbeddingQueuePrefix}
            - name: TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX
              value: ${textAssetEmbeddingProcessedPrefix}
            - name: TEXT_ASSET_EMBEDDING_FAILED_PREFIX
              value: ${textAssetEmbeddingFailedPrefix}
            - name: TEXT_ASSET_EMBEDDING_MODEL
              value: ${textAssetEmbeddingModel}
            - name: VECTOR_STORE_PROVIDER
              value: ${vectorStoreProvider}
            - name: VECTOR_STORE_PROJECT_ID
              value: ${vectorStoreProjectId}
            - name: VECTOR_STORE_LOCATION
              value: ${vectorStoreLocation}
            - name: VECTOR_STORE_NAMESPACE
              value: ${vectorStoreNamespace}
            - name: VECTOR_STORE_DIMENSION
              value: ${vectorStoreDimension}
            - name: VERTEX_INDEX_ENDPOINT
              value: ${vertexIndexEndpoint}
            - name: VERTEX_DEPLOYED_INDEX_ID
              value: ${vertexDeployedIndexId}
            - name: TEXT_ASSET_CATALOG_ENABLED
              value: ${textAssetCatalogEnabled}
            - name: TEXT_ASSET_REPLICATION_ENABLED
              value: ${textAssetReplicationEnabled}
            - name: TEXT_ASSET_REPLICATION_QUEUE_PREFIX
              value: ${textAssetReplicationQueuePrefix}
            - name: TEXT_ASSET_REPLICATION_TARGET
              value: ${textAssetReplicationTarget}
            - name: TEXT_ASSET_REPLICATION_TARGET_PREFIX
              value: ${textAssetReplicationTargetPrefix}
            - name: TEXT_ASSET_GENERATION_ENABLED
              value: ${textAssetGenerationEnabled}
            - name: TEXT_ASSET_GENERATION_PROVIDER
              value: ${textAssetGenerationProvider}
            - name: TEXT_ASSET_GENERATION_PROVIDER_CHAIN
              value: ${textAssetGenerationProviderChain}
            - name: TEXT_ASSET_GENERATED_CACHE_ENABLED
              value: ${textAssetGeneratedCacheEnabled}
            - name: TEXT_ASSET_GENERATED_CACHE_PREFIX
              value: ${textAssetGeneratedCachePrefix}
            - name: TEXT_SAM3D_API_HOST
              value: ${textSam3dApiHost}
            - name: TEXT_SAM3D_TEXT_ENDPOINTS
              value: ${textSam3dTextEndpoints}
            - name: TEXT_SAM3D_TIMEOUT_SECONDS
              value: ${textSam3dTimeoutSeconds}
            - name: TEXT_SAM3D_POLL_SECONDS
              value: ${textSam3dPollSeconds}
            - name: TEXT_HUNYUAN_API_HOST
              value: ${textHunyuanApiHost}
            - name: TEXT_HUNYUAN_TEXT_ENDPOINTS
              value: ${textHunyuanTextEndpoints}
            - name: TEXT_HUNYUAN_TIMEOUT_SECONDS
              value: ${textHunyuanTimeoutSeconds}
            - name: TEXT_HUNYUAN_POLL_SECONDS
              value: ${textHunyuanPollSeconds}
        result: textAdapterStatus
        next: return_result

    - return_result:
        return:
          status: "SUCCEEDED"
          runtime_used: "cloudrun"


run_text_jobs_on_vm:
  params: [projectId, region, bucket, childSceneId, childRequestObject, childTextgenPrefix, childAssetsPrefix, childLayoutPrefix, childSegPrefix, seedIndex, textGenMaxSeeds, textGenStandardProfile, textGenPremiumProfile, textGenUseLlm, textGenLlmMaxAttempts, textGenLlmRetryBackoffSeconds, textAssetRetrievalEnabled, textAssetLibraryPrefixes, textAssetLibraryMaxFiles, textAssetLibraryMinScore, textAssetRetrievalMode, textAssetAnnEnabled, textAssetAnnTopK, textAssetAnnMinScore, textAssetAnnMaxRerank, textAssetAnnNamespace, textAssetLexicalFallbackEnabled, textAssetRolloutStatePrefix, textAssetRolloutMinDecisions, textAssetRolloutMinHitRate, textAssetRolloutMaxErrorRate, textAssetRolloutMaxP95Ms, textAssetEmbeddingQueuePrefix, textAssetEmbeddingProcessedPrefix, textAssetEmbeddingFailedPrefix, textAssetEmbeddingModel, vectorStoreProvider, vectorStoreProjectId, vectorStoreLocation, vectorStoreNamespace, vectorStoreDimension, vertexIndexEndpoint, vertexDeployedIndexId, textAssetCatalogEnabled, textAssetReplicationEnabled, textAssetReplicationQueuePrefix, textAssetReplicationTarget, textAssetReplicationTargetPrefix, textAssetGenerationEnabled, textAssetGenerationProvider, textAssetGenerationProviderChain, textAssetGeneratedCacheEnabled, textAssetGeneratedCachePrefix, textSam3dApiHost, textSam3dTextEndpoints, textSam3dTimeoutSeconds, textSam3dPollSeconds, textHunyuanApiHost, textHunyuanTextEndpoints, textHunyuanTimeoutSeconds, textHunyuanPollSeconds, textVmName, textVmZone, textVmRepoDir, textVmTimeoutSeconds]
  steps:
    - run_text_jobs_via_cloud_build:
        try:
          call: googleapis.cloudbuild.v1.projects.builds.create
          args:
            projectId: ${projectId}
            body:
              steps:
                - name: "gcr.io/google.com/cloudsdktool/cloud-sdk"
                  entrypoint: "bash"
                  env:
                    - '${"PROJECT_ID=" + projectId}'
                    - '${"VM_NAME=" + textVmName}'
                    - '${"VM_ZONE=" + textVmZone}'
                    - '${"VM_REPO_DIR=" + textVmRepoDir}'
                    - '${"BUCKET=" + bucket}'
                    - '${"SCENE_ID=" + childSceneId}'
                    - '${"REQUEST_OBJECT=" + childRequestObject}'
                    - '${"TEXTGEN_PREFIX=" + childTextgenPrefix}'
                    - '${"TEXT_SEED=" + string(seedIndex)}'
                    - '${"TEXT_GEN_MAX_SEEDS=" + string(textGenMaxSeeds)}'
                    - '${"TEXT_GEN_STANDARD_PROFILE=" + textGenStandardProfile}'
                    - '${"TEXT_GEN_PREMIUM_PROFILE=" + textGenPremiumProfile}'
                    - '${"TEXT_GEN_USE_LLM=" + textGenUseLlm}'
                    - '${"TEXT_GEN_LLM_MAX_ATTEMPTS=" + textGenLlmMaxAttempts}'
                    - '${"TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS=" + textGenLlmRetryBackoffSeconds}'
                    - '${"TEXT_BACKEND_DEFAULT=" + default(sys.get_env("TEXT_BACKEND_DEFAULT"), "sage")}'
                    - '${"TEXT_BACKEND_ALLOWLIST=" + default(sys.get_env("TEXT_BACKEND_ALLOWLIST"), "internal,scenesmith,sage,hybrid_serial")}'
                    - '${"SAGE_RUNTIME_MODE=" + default(sys.get_env("SAGE_RUNTIME_MODE"), "cloudrun")}'
                    - '${"SAGE_SERVER_URL=" + default(sys.get_env("SAGE_SERVER_URL"), "")}'
                    - '${"SAGE_TIMEOUT_SECONDS=" + default(sys.get_env("SAGE_TIMEOUT_SECONDS"), "900")}'
                    - '${"SCENESMITH_RUNTIME_MODE=" + default(sys.get_env("SCENESMITH_RUNTIME_MODE"), "cloudrun")}'
                    - '${"SCENESMITH_SERVER_URL=" + default(sys.get_env("SCENESMITH_SERVER_URL"), "")}'
                    - '${"SCENESMITH_TIMEOUT_SECONDS=" + default(sys.get_env("SCENESMITH_TIMEOUT_SECONDS"), "1800")}'
                    - '${"TEXT_SAGE_ACTION_DEMO_ENABLED=" + default(sys.get_env("TEXT_SAGE_ACTION_DEMO_ENABLED"), "false")}'
                    - '${"TEXT_ASSET_RETRIEVAL_ENABLED=" + textAssetRetrievalEnabled}'
                    - '${"TEXT_ASSET_LIBRARY_PREFIXES=" + textAssetLibraryPrefixes}'
                    - '${"TEXT_ASSET_LIBRARY_MAX_FILES=" + textAssetLibraryMaxFiles}'
                    - '${"TEXT_ASSET_LIBRARY_MIN_SCORE=" + textAssetLibraryMinScore}'
                    - '${"TEXT_ASSET_RETRIEVAL_MODE=" + textAssetRetrievalMode}'
                    - '${"TEXT_ASSET_ANN_ENABLED=" + textAssetAnnEnabled}'
                    - '${"TEXT_ASSET_ANN_TOP_K=" + textAssetAnnTopK}'
                    - '${"TEXT_ASSET_ANN_MIN_SCORE=" + textAssetAnnMinScore}'
                    - '${"TEXT_ASSET_ANN_MAX_RERANK=" + textAssetAnnMaxRerank}'
                    - '${"TEXT_ASSET_ANN_NAMESPACE=" + textAssetAnnNamespace}'
                    - '${"TEXT_ASSET_LEXICAL_FALLBACK_ENABLED=" + textAssetLexicalFallbackEnabled}'
                    - '${"TEXT_ASSET_ROLLOUT_STATE_PREFIX=" + textAssetRolloutStatePrefix}'
                    - '${"TEXT_ASSET_ROLLOUT_MIN_DECISIONS=" + textAssetRolloutMinDecisions}'
                    - '${"TEXT_ASSET_ROLLOUT_MIN_HIT_RATE=" + textAssetRolloutMinHitRate}'
                    - '${"TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE=" + textAssetRolloutMaxErrorRate}'
                    - '${"TEXT_ASSET_ROLLOUT_MAX_P95_MS=" + textAssetRolloutMaxP95Ms}'
                    - '${"TEXT_ASSET_EMBEDDING_QUEUE_PREFIX=" + textAssetEmbeddingQueuePrefix}'
                    - '${"TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX=" + textAssetEmbeddingProcessedPrefix}'
                    - '${"TEXT_ASSET_EMBEDDING_FAILED_PREFIX=" + textAssetEmbeddingFailedPrefix}'
                    - '${"TEXT_ASSET_EMBEDDING_MODEL=" + textAssetEmbeddingModel}'
                    - '${"VECTOR_STORE_PROVIDER=" + vectorStoreProvider}'
                    - '${"VECTOR_STORE_PROJECT_ID=" + vectorStoreProjectId}'
                    - '${"VECTOR_STORE_LOCATION=" + vectorStoreLocation}'
                    - '${"VECTOR_STORE_NAMESPACE=" + vectorStoreNamespace}'
                    - '${"VECTOR_STORE_DIMENSION=" + vectorStoreDimension}'
                    - '${"VERTEX_INDEX_ENDPOINT=" + vertexIndexEndpoint}'
                    - '${"VERTEX_DEPLOYED_INDEX_ID=" + vertexDeployedIndexId}'
                    - '${"TEXT_ASSET_CATALOG_ENABLED=" + textAssetCatalogEnabled}'
                    - '${"TEXT_ASSET_REPLICATION_ENABLED=" + textAssetReplicationEnabled}'
                    - '${"TEXT_ASSET_REPLICATION_QUEUE_PREFIX=" + textAssetReplicationQueuePrefix}'
                    - '${"TEXT_ASSET_REPLICATION_TARGET=" + textAssetReplicationTarget}'
                    - '${"TEXT_ASSET_REPLICATION_TARGET_PREFIX=" + textAssetReplicationTargetPrefix}'
                    - '${"TEXT_ASSET_GENERATION_ENABLED=" + textAssetGenerationEnabled}'
                    - '${"TEXT_ASSET_GENERATION_PROVIDER=" + textAssetGenerationProvider}'
                    - '${"TEXT_ASSET_GENERATION_PROVIDER_CHAIN=" + textAssetGenerationProviderChain}'
                    - '${"TEXT_ASSET_GENERATED_CACHE_ENABLED=" + textAssetGeneratedCacheEnabled}'
                    - '${"TEXT_ASSET_GENERATED_CACHE_PREFIX=" + textAssetGeneratedCachePrefix}'
                    - '${"TEXT_SAM3D_API_HOST=" + textSam3dApiHost}'
                    - '${"TEXT_SAM3D_TEXT_ENDPOINTS=" + textSam3dTextEndpoints}'
                    - '${"TEXT_SAM3D_TIMEOUT_SECONDS=" + textSam3dTimeoutSeconds}'
                    - '${"TEXT_SAM3D_POLL_SECONDS=" + textSam3dPollSeconds}'
                    - '${"TEXT_HUNYUAN_API_HOST=" + textHunyuanApiHost}'
                    - '${"TEXT_HUNYUAN_TEXT_ENDPOINTS=" + textHunyuanTextEndpoints}'
                    - '${"TEXT_HUNYUAN_TIMEOUT_SECONDS=" + textHunyuanTimeoutSeconds}'
                    - '${"TEXT_HUNYUAN_POLL_SECONDS=" + textHunyuanPollSeconds}'
                    - '${"ASSETS_PREFIX=" + childAssetsPrefix}'
                    - '${"LAYOUT_PREFIX=" + childLayoutPrefix}'
                    - '${"SEG_PREFIX=" + childSegPrefix}'
                  args:
                    - "-c"
                    - |
                      set -euo pipefail

                      BUCKET_Q=$(printf '%q' "${BUCKET}")
                      SCENE_ID_Q=$(printf '%q' "${SCENE_ID}")
                      REQUEST_OBJECT_Q=$(printf '%q' "${REQUEST_OBJECT}")
                      TEXTGEN_PREFIX_Q=$(printf '%q' "${TEXTGEN_PREFIX}")
                      TEXT_SEED_Q=$(printf '%q' "${TEXT_SEED}")
                      TEXT_GEN_MAX_SEEDS_Q=$(printf '%q' "${TEXT_GEN_MAX_SEEDS}")
                      TEXT_GEN_STANDARD_PROFILE_Q=$(printf '%q' "${TEXT_GEN_STANDARD_PROFILE}")
                      TEXT_GEN_PREMIUM_PROFILE_Q=$(printf '%q' "${TEXT_GEN_PREMIUM_PROFILE}")
                      TEXT_GEN_USE_LLM_Q=$(printf '%q' "${TEXT_GEN_USE_LLM}")
                      TEXT_GEN_LLM_MAX_ATTEMPTS_Q=$(printf '%q' "${TEXT_GEN_LLM_MAX_ATTEMPTS}")
                      TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS_Q=$(printf '%q' "${TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS}")
                      TEXT_BACKEND_DEFAULT_Q=$(printf '%q' "${TEXT_BACKEND_DEFAULT}")
                      TEXT_BACKEND_ALLOWLIST_Q=$(printf '%q' "${TEXT_BACKEND_ALLOWLIST}")
                      SAGE_RUNTIME_MODE_Q=$(printf '%q' "${SAGE_RUNTIME_MODE}")
                      SAGE_SERVER_URL_Q=$(printf '%q' "${SAGE_SERVER_URL}")
                      SAGE_TIMEOUT_SECONDS_Q=$(printf '%q' "${SAGE_TIMEOUT_SECONDS}")
                      SCENESMITH_RUNTIME_MODE_Q=$(printf '%q' "${SCENESMITH_RUNTIME_MODE}")
                      SCENESMITH_SERVER_URL_Q=$(printf '%q' "${SCENESMITH_SERVER_URL}")
                      SCENESMITH_TIMEOUT_SECONDS_Q=$(printf '%q' "${SCENESMITH_TIMEOUT_SECONDS}")
                      TEXT_SAGE_ACTION_DEMO_ENABLED_Q=$(printf '%q' "${TEXT_SAGE_ACTION_DEMO_ENABLED}")
                      TEXT_ASSET_RETRIEVAL_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_RETRIEVAL_ENABLED}")
                      TEXT_ASSET_LIBRARY_PREFIXES_Q=$(printf '%q' "${TEXT_ASSET_LIBRARY_PREFIXES}")
                      TEXT_ASSET_LIBRARY_MAX_FILES_Q=$(printf '%q' "${TEXT_ASSET_LIBRARY_MAX_FILES}")
                      TEXT_ASSET_LIBRARY_MIN_SCORE_Q=$(printf '%q' "${TEXT_ASSET_LIBRARY_MIN_SCORE}")
                      TEXT_ASSET_RETRIEVAL_MODE_Q=$(printf '%q' "${TEXT_ASSET_RETRIEVAL_MODE}")
                      TEXT_ASSET_ANN_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_ANN_ENABLED}")
                      TEXT_ASSET_ANN_TOP_K_Q=$(printf '%q' "${TEXT_ASSET_ANN_TOP_K}")
                      TEXT_ASSET_ANN_MIN_SCORE_Q=$(printf '%q' "${TEXT_ASSET_ANN_MIN_SCORE}")
                      TEXT_ASSET_ANN_MAX_RERANK_Q=$(printf '%q' "${TEXT_ASSET_ANN_MAX_RERANK}")
                      TEXT_ASSET_ANN_NAMESPACE_Q=$(printf '%q' "${TEXT_ASSET_ANN_NAMESPACE}")
                      TEXT_ASSET_LEXICAL_FALLBACK_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_LEXICAL_FALLBACK_ENABLED}")
                      TEXT_ASSET_ROLLOUT_STATE_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_ROLLOUT_STATE_PREFIX}")
                      TEXT_ASSET_ROLLOUT_MIN_DECISIONS_Q=$(printf '%q' "${TEXT_ASSET_ROLLOUT_MIN_DECISIONS}")
                      TEXT_ASSET_ROLLOUT_MIN_HIT_RATE_Q=$(printf '%q' "${TEXT_ASSET_ROLLOUT_MIN_HIT_RATE}")
                      TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE_Q=$(printf '%q' "${TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE}")
                      TEXT_ASSET_ROLLOUT_MAX_P95_MS_Q=$(printf '%q' "${TEXT_ASSET_ROLLOUT_MAX_P95_MS}")
                      TEXT_ASSET_EMBEDDING_QUEUE_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_EMBEDDING_QUEUE_PREFIX}")
                      TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX}")
                      TEXT_ASSET_EMBEDDING_FAILED_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_EMBEDDING_FAILED_PREFIX}")
                      TEXT_ASSET_EMBEDDING_MODEL_Q=$(printf '%q' "${TEXT_ASSET_EMBEDDING_MODEL}")
                      VECTOR_STORE_PROVIDER_Q=$(printf '%q' "${VECTOR_STORE_PROVIDER}")
                      VECTOR_STORE_PROJECT_ID_Q=$(printf '%q' "${VECTOR_STORE_PROJECT_ID}")
                      VECTOR_STORE_LOCATION_Q=$(printf '%q' "${VECTOR_STORE_LOCATION}")
                      VECTOR_STORE_NAMESPACE_Q=$(printf '%q' "${VECTOR_STORE_NAMESPACE}")
                      VECTOR_STORE_DIMENSION_Q=$(printf '%q' "${VECTOR_STORE_DIMENSION}")
                      VERTEX_INDEX_ENDPOINT_Q=$(printf '%q' "${VERTEX_INDEX_ENDPOINT}")
                      VERTEX_DEPLOYED_INDEX_ID_Q=$(printf '%q' "${VERTEX_DEPLOYED_INDEX_ID}")
                      TEXT_ASSET_CATALOG_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_CATALOG_ENABLED}")
                      TEXT_ASSET_REPLICATION_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_REPLICATION_ENABLED}")
                      TEXT_ASSET_REPLICATION_QUEUE_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_REPLICATION_QUEUE_PREFIX}")
                      TEXT_ASSET_REPLICATION_TARGET_Q=$(printf '%q' "${TEXT_ASSET_REPLICATION_TARGET}")
                      TEXT_ASSET_REPLICATION_TARGET_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_REPLICATION_TARGET_PREFIX}")
                      TEXT_ASSET_GENERATION_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_GENERATION_ENABLED}")
                      TEXT_ASSET_GENERATION_PROVIDER_Q=$(printf '%q' "${TEXT_ASSET_GENERATION_PROVIDER}")
                      TEXT_ASSET_GENERATION_PROVIDER_CHAIN_Q=$(printf '%q' "${TEXT_ASSET_GENERATION_PROVIDER_CHAIN}")
                      TEXT_ASSET_GENERATED_CACHE_ENABLED_Q=$(printf '%q' "${TEXT_ASSET_GENERATED_CACHE_ENABLED}")
                      TEXT_ASSET_GENERATED_CACHE_PREFIX_Q=$(printf '%q' "${TEXT_ASSET_GENERATED_CACHE_PREFIX}")
                      TEXT_SAM3D_API_HOST_Q=$(printf '%q' "${TEXT_SAM3D_API_HOST}")
                      TEXT_SAM3D_TEXT_ENDPOINTS_Q=$(printf '%q' "${TEXT_SAM3D_TEXT_ENDPOINTS}")
                      TEXT_SAM3D_TIMEOUT_SECONDS_Q=$(printf '%q' "${TEXT_SAM3D_TIMEOUT_SECONDS}")
                      TEXT_SAM3D_POLL_SECONDS_Q=$(printf '%q' "${TEXT_SAM3D_POLL_SECONDS}")
                      TEXT_HUNYUAN_API_HOST_Q=$(printf '%q' "${TEXT_HUNYUAN_API_HOST}")
                      TEXT_HUNYUAN_TEXT_ENDPOINTS_Q=$(printf '%q' "${TEXT_HUNYUAN_TEXT_ENDPOINTS}")
                      TEXT_HUNYUAN_TIMEOUT_SECONDS_Q=$(printf '%q' "${TEXT_HUNYUAN_TIMEOUT_SECONDS}")
                      TEXT_HUNYUAN_POLL_SECONDS_Q=$(printf '%q' "${TEXT_HUNYUAN_POLL_SECONDS}")
                      ASSETS_PREFIX_Q=$(printf '%q' "${ASSETS_PREFIX}")
                      LAYOUT_PREFIX_Q=$(printf '%q' "${LAYOUT_PREFIX}")
                      SEG_PREFIX_Q=$(printf '%q' "${SEG_PREFIX}")

                      REMOTE_CMD="cd ${VM_REPO_DIR} && BUCKET=${BUCKET_Q} SCENE_ID=${SCENE_ID_Q} REQUEST_OBJECT=${REQUEST_OBJECT_Q} TEXTGEN_PREFIX=${TEXTGEN_PREFIX_Q} TEXT_SEED=${TEXT_SEED_Q} DEFAULT_SOURCE_MODE=text TEXT_GEN_MAX_SEEDS=${TEXT_GEN_MAX_SEEDS_Q} TEXT_GEN_STANDARD_PROFILE=${TEXT_GEN_STANDARD_PROFILE_Q} TEXT_GEN_PREMIUM_PROFILE=${TEXT_GEN_PREMIUM_PROFILE_Q} TEXT_GEN_USE_LLM=${TEXT_GEN_USE_LLM_Q} TEXT_GEN_LLM_MAX_ATTEMPTS=${TEXT_GEN_LLM_MAX_ATTEMPTS_Q} TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS=${TEXT_GEN_LLM_RETRY_BACKOFF_SECONDS_Q} TEXT_BACKEND_DEFAULT=${TEXT_BACKEND_DEFAULT_Q} TEXT_BACKEND_ALLOWLIST=${TEXT_BACKEND_ALLOWLIST_Q} SAGE_RUNTIME_MODE=${SAGE_RUNTIME_MODE_Q} SAGE_SERVER_URL=${SAGE_SERVER_URL_Q} SAGE_TIMEOUT_SECONDS=${SAGE_TIMEOUT_SECONDS_Q} SCENESMITH_RUNTIME_MODE=${SCENESMITH_RUNTIME_MODE_Q} SCENESMITH_SERVER_URL=${SCENESMITH_SERVER_URL_Q} SCENESMITH_TIMEOUT_SECONDS=${SCENESMITH_TIMEOUT_SECONDS_Q} TEXT_SAGE_ACTION_DEMO_ENABLED=${TEXT_SAGE_ACTION_DEMO_ENABLED_Q} TEXT_GEN_RUNTIME=vm python text-scene-gen-job/generate_text_scene.py && BUCKET=${BUCKET_Q} SCENE_ID=${SCENE_ID_Q} REQUEST_OBJECT=${REQUEST_OBJECT_Q} TEXTGEN_PREFIX=${TEXTGEN_PREFIX_Q} ASSETS_PREFIX=${ASSETS_PREFIX_Q} LAYOUT_PREFIX=${LAYOUT_PREFIX_Q} SEG_PREFIX=${SEG_PREFIX_Q} TEXT_ASSET_RETRIEVAL_ENABLED=${TEXT_ASSET_RETRIEVAL_ENABLED_Q} TEXT_ASSET_LIBRARY_PREFIXES=${TEXT_ASSET_LIBRARY_PREFIXES_Q} TEXT_ASSET_LIBRARY_MAX_FILES=${TEXT_ASSET_LIBRARY_MAX_FILES_Q} TEXT_ASSET_LIBRARY_MIN_SCORE=${TEXT_ASSET_LIBRARY_MIN_SCORE_Q} TEXT_ASSET_RETRIEVAL_MODE=${TEXT_ASSET_RETRIEVAL_MODE_Q} TEXT_ASSET_ANN_ENABLED=${TEXT_ASSET_ANN_ENABLED_Q} TEXT_ASSET_ANN_TOP_K=${TEXT_ASSET_ANN_TOP_K_Q} TEXT_ASSET_ANN_MIN_SCORE=${TEXT_ASSET_ANN_MIN_SCORE_Q} TEXT_ASSET_ANN_MAX_RERANK=${TEXT_ASSET_ANN_MAX_RERANK_Q} TEXT_ASSET_ANN_NAMESPACE=${TEXT_ASSET_ANN_NAMESPACE_Q} TEXT_ASSET_LEXICAL_FALLBACK_ENABLED=${TEXT_ASSET_LEXICAL_FALLBACK_ENABLED_Q} TEXT_ASSET_ROLLOUT_STATE_PREFIX=${TEXT_ASSET_ROLLOUT_STATE_PREFIX_Q} TEXT_ASSET_ROLLOUT_MIN_DECISIONS=${TEXT_ASSET_ROLLOUT_MIN_DECISIONS_Q} TEXT_ASSET_ROLLOUT_MIN_HIT_RATE=${TEXT_ASSET_ROLLOUT_MIN_HIT_RATE_Q} TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE=${TEXT_ASSET_ROLLOUT_MAX_ERROR_RATE_Q} TEXT_ASSET_ROLLOUT_MAX_P95_MS=${TEXT_ASSET_ROLLOUT_MAX_P95_MS_Q} TEXT_ASSET_EMBEDDING_QUEUE_PREFIX=${TEXT_ASSET_EMBEDDING_QUEUE_PREFIX_Q} TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX=${TEXT_ASSET_EMBEDDING_PROCESSED_PREFIX_Q} TEXT_ASSET_EMBEDDING_FAILED_PREFIX=${TEXT_ASSET_EMBEDDING_FAILED_PREFIX_Q} TEXT_ASSET_EMBEDDING_MODEL=${TEXT_ASSET_EMBEDDING_MODEL_Q} VECTOR_STORE_PROVIDER=${VECTOR_STORE_PROVIDER_Q} VECTOR_STORE_PROJECT_ID=${VECTOR_STORE_PROJECT_ID_Q} VECTOR_STORE_LOCATION=${VECTOR_STORE_LOCATION_Q} VECTOR_STORE_NAMESPACE=${VECTOR_STORE_NAMESPACE_Q} VECTOR_STORE_DIMENSION=${VECTOR_STORE_DIMENSION_Q} VERTEX_INDEX_ENDPOINT=${VERTEX_INDEX_ENDPOINT_Q} VERTEX_DEPLOYED_INDEX_ID=${VERTEX_DEPLOYED_INDEX_ID_Q} TEXT_ASSET_CATALOG_ENABLED=${TEXT_ASSET_CATALOG_ENABLED_Q} TEXT_ASSET_REPLICATION_ENABLED=${TEXT_ASSET_REPLICATION_ENABLED_Q} TEXT_ASSET_REPLICATION_QUEUE_PREFIX=${TEXT_ASSET_REPLICATION_QUEUE_PREFIX_Q} TEXT_ASSET_REPLICATION_TARGET=${TEXT_ASSET_REPLICATION_TARGET_Q} TEXT_ASSET_REPLICATION_TARGET_PREFIX=${TEXT_ASSET_REPLICATION_TARGET_PREFIX_Q} TEXT_ASSET_GENERATION_ENABLED=${TEXT_ASSET_GENERATION_ENABLED_Q} TEXT_ASSET_GENERATION_PROVIDER=${TEXT_ASSET_GENERATION_PROVIDER_Q} TEXT_ASSET_GENERATION_PROVIDER_CHAIN=${TEXT_ASSET_GENERATION_PROVIDER_CHAIN_Q} TEXT_ASSET_GENERATED_CACHE_ENABLED=${TEXT_ASSET_GENERATED_CACHE_ENABLED_Q} TEXT_ASSET_GENERATED_CACHE_PREFIX=${TEXT_ASSET_GENERATED_CACHE_PREFIX_Q} TEXT_SAM3D_API_HOST=${TEXT_SAM3D_API_HOST_Q} TEXT_SAM3D_TEXT_ENDPOINTS=${TEXT_SAM3D_TEXT_ENDPOINTS_Q} TEXT_SAM3D_TIMEOUT_SECONDS=${TEXT_SAM3D_TIMEOUT_SECONDS_Q} TEXT_SAM3D_POLL_SECONDS=${TEXT_SAM3D_POLL_SECONDS_Q} TEXT_HUNYUAN_API_HOST=${TEXT_HUNYUAN_API_HOST_Q} TEXT_HUNYUAN_TEXT_ENDPOINTS=${TEXT_HUNYUAN_TEXT_ENDPOINTS_Q} TEXT_HUNYUAN_TIMEOUT_SECONDS=${TEXT_HUNYUAN_TIMEOUT_SECONDS_Q} TEXT_HUNYUAN_POLL_SECONDS=${TEXT_HUNYUAN_POLL_SECONDS_Q} python text-scene-adapter-job/adapt_text_scene.py"

                      gcloud compute ssh "${VM_NAME}" \
                        --project="${PROJECT_ID}" \
                        --zone="${VM_ZONE}" \
                        --command="${REMOTE_CMD}"
              timeout: '${string(textVmTimeoutSeconds + 600) + "s"}'
              options:
                logging: CLOUD_LOGGING_ONLY
          result: vmBuild
        except:
          as: vmStartErr
          steps:
            - raise_vm_start_transient:
                raise: '${"[vm_transient] Failed to start VM text stage via Cloud Build: " + vmStartErr.message}'
        next: init_vm_build_poll

    - init_vm_build_poll:
        assign:
          - vmBuildId: '${if(vmBuild.metadata != null and vmBuild.metadata.build != null and vmBuild.metadata.build.id != null, vmBuild.metadata.build.id, if(vmBuild.id != null, vmBuild.id, ""))}'
          - vmBuildPollStartTime: '${time.format(sys.now())}'
        next: ensure_vm_build_id

    - ensure_vm_build_id:
        switch:
          - condition: '${vmBuildId == ""}'
            next: missing_vm_build_id
        next: check_vm_build_status

    - missing_vm_build_id:
        raise: '${"[vm_transient] VM text stage Cloud Build returned no build ID for scene " + childSceneId}'

    - check_vm_build_status:
        call: googleapis.cloudbuild.v1.projects.builds.get
        args:
          projectId: ${projectId}
          id: ${vmBuildId}
        result: vmBuildStatus
        next: vm_build_status_switch

    - vm_build_status_switch:
        switch:
          - condition: '${vmBuildStatus.status == "SUCCESS"}'
            next: return_vm_build_success
          - condition: '${vmBuildStatus.status == "TIMEOUT" or vmBuildStatus.status == "INTERNAL_ERROR" or vmBuildStatus.status == "EXPIRED" or vmBuildStatus.status == "CANCELLED"}'
            next: raise_vm_build_transient
          - condition: '${vmBuildStatus.status == "FAILURE"}'
            next: raise_vm_build_non_transient
        next: check_vm_build_timeout

    - check_vm_build_timeout:
        assign:
          - vmBuildPollNow: '${time.format(sys.now())}'
          - vmBuildPollElapsedSeconds: '${time.parse(vmBuildPollNow) - time.parse(vmBuildPollStartTime)}'
        next: vm_build_timeout_switch

    - vm_build_timeout_switch:
        switch:
          - condition: '${vmBuildPollElapsedSeconds >= textVmTimeoutSeconds}'
            next: raise_vm_build_transient_timeout
        next: wait_vm_build_poll

    - wait_vm_build_poll:
        call: sys.sleep
        args:
          seconds: 20
        next: check_vm_build_status

    - raise_vm_build_transient:
        raise: '${"[vm_transient] VM text stage build unstable for scene " + childSceneId + " (build " + vmBuildId + ", status=" + vmBuildStatus.status + ")"}'

    - raise_vm_build_transient_timeout:
        raise: '${"[vm_transient] VM text stage build polling timed out for scene " + childSceneId + " (build " + vmBuildId + ")"}'

    - raise_vm_build_non_transient:
        raise: '${"[vm_non_transient] VM text stage build failed for scene " + childSceneId + " (build " + vmBuildId + ")"}'

    - return_vm_build_success:
        return:
          status: "SUCCEEDED"
          runtime_used: "vm"
          build_id: ${vmBuildId}


run_image_path_compat:
  params: [projectId, region, bucket, imageObject, generation, imagePathMode, imageOrchestratorWorkflow, imageLegacyWorkflow, geniesimCompleteObject, legacyWaitTimeoutSeconds]
  steps:
    - mode_switch:
        switch:
          - condition: '${imagePathMode == "orchestrator"}'
            next: run_orchestrator_workflow
          - condition: '${imagePathMode == "legacy_chain"}'
            next: run_legacy_workflow
        next: invalid_image_mode

    - run_orchestrator_workflow:
        call: run_workflow_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          workflowName: ${imageOrchestratorWorkflow}
          pollIntervalSeconds: 30
          argument:
            data:
              bucket: ${bucket}
              name: ${imageObject}
              generation: ${generation}
        result: orchestratorResult
        next: return_orchestrator_result

    - return_orchestrator_result:
        return:
          mode: "orchestrator"
          workflow_name: ${imageOrchestratorWorkflow}
          workflow_execution: ${orchestratorResult.name}
          waited_for_downstream: false

    - run_legacy_workflow:
        call: run_workflow_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          workflowName: ${imageLegacyWorkflow}
          pollIntervalSeconds: 30
          argument:
            data:
              bucket: ${bucket}
              name: ${imageObject}
              generation: ${generation}
        result: legacyWorkflowResult
        next: wait_for_legacy_downstream

    - wait_for_legacy_downstream:
        call: wait_for_gcs_marker
        args:
          bucket: ${bucket}
          object: ${geniesimCompleteObject}
          timeoutSeconds: ${legacyWaitTimeoutSeconds}
          pollIntervalSeconds: 30
        result: legacyDownstreamMarker
        next: return_legacy_result

    - return_legacy_result:
        return:
          mode: "legacy_chain"
          workflow_name: ${imageLegacyWorkflow}
          workflow_execution: ${legacyWorkflowResult.name}
          waited_for_downstream: true
          downstream_marker: ${geniesimCompleteObject}

    - invalid_image_mode:
        raise: '${"Unsupported IMAGE_PATH_MODE: " + imagePathMode}'


wait_for_gcs_marker:
  params: [bucket, object, timeoutSeconds, pollIntervalSeconds]
  steps:
    - init_timer:
        assign:
          - waitStartTime: '${time.format(sys.now())}'
        next: poll_marker

    - poll_marker:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${object}
            alt: "media"
          result: markerPayload
        except:
          as: markerErr
          steps:
            - marker_not_found_switch:
                switch:
                  - condition: '${markerErr.code == 404}'
                    next: check_wait_timeout
                next: marker_read_error
            - marker_read_error:
                raise: '${"Failed to read marker " + object + ": " + markerErr.message}'
        next: return_marker

    - check_wait_timeout:
        assign:
          - waitNow: '${time.format(sys.now())}'
          - waitElapsedSeconds: '${time.parse(waitNow) - time.parse(waitStartTime)}'
        next: wait_timeout_switch

    - wait_timeout_switch:
        switch:
          - condition: '${waitElapsedSeconds >= timeoutSeconds}'
            next: wait_timeout_error
        next: wait_before_poll

    - wait_before_poll:
        call: sys.sleep
        args:
          seconds: ${pollIntervalSeconds}
        next: poll_marker

    - wait_timeout_error:
        raise: '${"Timed out waiting for marker " + object + " after " + string(timeoutSeconds) + " seconds"}'

    - return_marker:
        return:
          object: ${object}
          payload: ${markerPayload}


release_source_lock_if_needed:
  params: [bucket, lockObject, lockAcquired]
  steps:
    - release_switch:
        switch:
          - condition: ${lockAcquired}
            next: delete_lock
        next: return_not_released

    - delete_lock:
        try:
          call: googleapis.storage.v1.objects.delete
          args:
            bucket: ${bucket}
            object: ${lockObject}
        except:
          as: lockDeleteErr
          steps:
            - ignore_missing_lock:
                switch:
                  - condition: '${lockDeleteErr.code == 404}'
                    next: return_released
            - log_lock_delete_warning:
                call: sys.log
                args:
                  text: '${"Failed to release source lock " + lockObject + ": " + lockDeleteErr.message}'
                  severity: "WARNING"
        next: return_released

    - return_released:
        return:
          released: true

    - return_not_released:
        return:
          released: false
