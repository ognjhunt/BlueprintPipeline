main:
  params: [event]
  steps:
    - log_event:
        call: sys.log
        args:
          text: ${event}
          severity: "INFO"
        next: extract

    - extract:
        assign:
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - projectId: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}
          - region: "us-central1"
        next: filter_image

    # Kick off only when a single RGB lands under scenes/<sceneId>/images/
    - filter_image:
        switch:
          - condition: ${text.match_regex(object, "(?i)^scenes/[^/]+/images/[^/]+\\.(png|jpg|jpeg)$")}
            next: derive
        next: skip

    - derive:
        assign:
          - parts: ${text.split(object, "/")}
          - sceneId: ${parts[1]}
          - imagesPrefix: ${text.replace_all(object, "/[^/]+$", "")}
          - segPrefix: ${"scenes/" + sceneId + "/seg"}
          - datasetYaml: ${segPrefix + "/dataset/data.yaml"}
          - da3Geom: ${"scenes/" + sceneId + "/da3/da3_geom.npz"}
          - layoutPrefix: ${"scenes/" + sceneId + "/layout"}
          - layoutJson: ${layoutPrefix + "/scene_layout.json"}
          - scaledLayout: ${layoutPrefix + "/scene_layout_scaled.json"}
          - segDatasetPrefix: ${"scenes/" + sceneId + "/seg/dataset"}
          - multiviewPrefix: ${"scenes/" + sceneId + "/multiview"}
          - assetsPrefix: ${"scenes/" + sceneId + "/assets"}
          - locksPrefix: ${"scenes/" + sceneId + "/_locks"}
          - dataAttempts: 0
          - da3Attempts: 0
          - layoutAttempts: 0
          - scaledAttempts: 0
          - multiviewAttempts: 0
          - assetsAttempts: 0
        next: run_seg_job

    - run_seg_job:
        call: run_job_with_lock
        args:
          bucket: ${bucket}
          projectId: ${projectId}
          region: ${region}
          jobName: "seg-job"
          lockObject: ${locksPrefix + "/seg.json"}
          overrides:
            containerOverrides:
              - env:
                  - name: BUCKET
                    value: ${bucket}
                  - name: IMAGES_PREFIX
                    value: ${imagesPrefix}
                  - name: SEG_PREFIX
                    value: ${segPrefix}
          dedupeContext:
            eventId: ${event.id}
            eventType: ${event.type}
            metageneration: ${event.data.metageneration}
            dedupeToken: ${locksPrefix + "/seg.json"}
        result: segResult
        next: handle_seg_result

    - handle_seg_result:
        switch:
          - condition: ${segResult.skipped}
            next: done_locked
        next: wait_for_data_yaml

    - wait_for_data_yaml:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${datasetYaml}
          result: dataObj
        except:
          as: e
          steps:
            - handle_data_error:
                next: retry_data_yaml
        next: run_da3_job

    - retry_data_yaml:
        switch:
          - condition: ${dataAttempts < 60}
            next: bump_data_attempt
        next: fail_data_yaml

    - bump_data_attempt:
        assign:
          - dataAttempts: ${dataAttempts + 1}
        next: sleep_data_yaml

    - sleep_data_yaml:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_data_yaml

    - fail_data_yaml:
        raise: ${"data.yaml not found at " + datasetYaml}

    - run_da3_job:
        call: run_job_with_lock
        args:
          bucket: ${bucket}
          projectId: ${projectId}
          region: ${region}
          jobName: "scene-da3-job"
          lockObject: ${locksPrefix + "/scene-da3.json"}
          overrides:
            containerOverrides:
              - env:
                  - name: BUCKET
                    value: ${bucket}
                  - name: SCENE_ID
                    value: ${sceneId}
                  - name: DATASET_PREFIX
                    value: ${segDatasetPrefix}
                  - name: OUT_PREFIX
                    value: ${"scenes/" + sceneId + "/da3"}
          dedupeContext:
            eventId: ${event.id}
            eventType: ${event.type}
            metageneration: ${event.data.metageneration}
            dedupeToken: ${locksPrefix + "/scene-da3.json"}
        result: da3Result
        next: handle_da3_result

    - handle_da3_result:
        switch:
          - condition: ${da3Result.skipped}
            next: done_locked
        next: wait_for_da3_geom

    - wait_for_da3_geom:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${da3Geom}
          result: da3Obj
        except:
          as: e
          steps:
            - handle_da3_error:
                next: retry_da3_geom
        next: run_layout_job

    - retry_da3_geom:
        switch:
          - condition: ${da3Attempts < 60}
            next: bump_da3_attempt
        next: fail_da3_geom

    - bump_da3_attempt:
        assign:
          - da3Attempts: ${da3Attempts + 1}
        next: sleep_da3_geom

    - sleep_da3_geom:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_da3_geom

    - fail_da3_geom:
        raise: ${"da3_geom.npz not found at " + da3Geom}

    - run_layout_job:
        call: run_job_with_lock
        args:
          bucket: ${bucket}
          projectId: ${projectId}
          region: ${region}
          jobName: "layout-job"
          lockObject: ${locksPrefix + "/layout.json"}
          overrides:
            containerOverrides:
              - env:
                  - name: BUCKET
                    value: ${bucket}
                  - name: SCENE_ID
                    value: ${sceneId}
                  - name: DA3_PREFIX
                    value: ${"scenes/" + sceneId + "/da3"}
                  - name: SEG_DATASET_PREFIX
                    value: ${segDatasetPrefix}
                  - name: LAYOUT_PREFIX
                    value: ${layoutPrefix}
          dedupeContext:
            eventId: ${event.id}
            eventType: ${event.type}
            metageneration: ${event.data.metageneration}
            dedupeToken: ${locksPrefix + "/layout.json"}
        result: layoutResult
        next: handle_layout_result

    - handle_layout_result:
        switch:
          - condition: ${layoutResult.skipped}
            next: done_locked
        next: wait_for_layout_json

    - wait_for_layout_json:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${layoutJson}
          result: layoutObj
        except:
          as: e
          steps:
            - handle_layout_error:
                next: retry_layout_json
        next: run_scale_job

    - retry_layout_json:
        switch:
          - condition: ${layoutAttempts < 60}
            next: bump_layout_attempt
        next: fail_layout_json

    - bump_layout_attempt:
        assign:
          - layoutAttempts: ${layoutAttempts + 1}
        next: sleep_layout_json

    - sleep_layout_json:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_layout_json

    - fail_layout_json:
        raise: ${"scene_layout.json not found at " + layoutJson}

    - run_scale_job:
        call: run_job_with_lock
        args:
          bucket: ${bucket}
          projectId: ${projectId}
          region: ${region}
          jobName: "scale-job"
          lockObject: ${locksPrefix + "/scale.json"}
          overrides:
            containerOverrides:
              - env:
                  - name: BUCKET
                    value: ${bucket}
                  - name: SCENE_ID
                    value: ${sceneId}
                  - name: LAYOUT_PREFIX
                    value: ${layoutPrefix}
          dedupeContext:
            eventId: ${event.id}
            eventType: ${event.type}
            metageneration: ${event.data.metageneration}
            dedupeToken: ${locksPrefix + "/scale.json"}
        result: scaleResult
        next: handle_scale_result

    - handle_scale_result:
        switch:
          - condition: ${scaleResult.skipped}
            next: done_locked
        next: wait_for_scaled_layout

    - wait_for_scaled_layout:
        try:
          call: googleapis.storage.v1.objects.get
          args:
            bucket: ${bucket}
            object: ${scaledLayout}
          result: scaledObj
        except:
          as: e
          steps:
            - handle_scale_error:
                next: retry_scaled_layout
        next: run_multiview_job

    - retry_scaled_layout:
        switch:
          - condition: ${scaledAttempts < 60}
            next: bump_scaled_attempt
        next: fail_scaled_layout

    - bump_scaled_attempt:
        assign:
          - scaledAttempts: ${scaledAttempts + 1}
        next: sleep_scaled_layout

    - sleep_scaled_layout:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_scaled_layout

    - fail_scaled_layout:
        raise: ${"scene_layout_scaled.json not found at " + scaledLayout}

    - run_multiview_job:
        call: run_job_with_lock
        args:
          bucket: ${bucket}
          projectId: ${projectId}
          region: ${region}
          jobName: "multiview-job"
          lockObject: ${locksPrefix + "/multiview.json"}
          overrides:
            containerOverrides:
              - env:
                  - name: BUCKET
                    value: ${bucket}
                  - name: SCENE_ID
                    value: ${sceneId}
                  - name: LAYOUT_PREFIX
                    value: ${layoutPrefix}
                  - name: SEG_DATASET_PREFIX
                    value: ${segDatasetPrefix}
                  - name: MULTIVIEW_PREFIX
                    value: ${multiviewPrefix}
                  - name: ENABLE_GEMINI_VIEWS
                    value: "true"
                  - name: VIEWS_PER_OBJECT
                    value: "1"
          dedupeContext:
            eventId: ${event.id}
            eventType: ${event.type}
            metageneration: ${event.data.metageneration}
            dedupeToken: ${locksPrefix + "/multiview.json"}
        result: mvResult
        next: handle_multiview_result

    - handle_multiview_result:
        switch:
          - condition: ${mvResult.skipped}
            next: done_locked
        next: wait_for_multiview

    - wait_for_multiview:
        try:
          call: googleapis.storage.v1.objects.list
          args:
            bucket: ${bucket}
            prefix: ${multiviewPrefix + "/obj_"}
            maxResults: 1
          result: mvList
        except:
          as: e
          steps:
            - handle_mv_error:
                next: retry_multiview
        next: check_multiview

    - check_multiview:
        switch:
          - condition: ${len(mvList.items or []) > 0}
            next: run_sam3d
        next: retry_multiview

    - retry_multiview:
        switch:
          - condition: ${multiviewAttempts < 60}
            next: bump_multiview_attempt
        next: fail_multiview

    - bump_multiview_attempt:
        assign:
          - multiviewAttempts: ${multiviewAttempts + 1}
        next: sleep_multiview

    - sleep_multiview:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_multiview

    - fail_multiview:
        raise: ${"No multiview crops found under " + multiviewPrefix}

    # Note: We skip assets-plan-job as it is not in your list of successfully deployed jobs.
    # We jump straight to SAM3D assuming simple 1-to-1 asset recon.

    - run_sam3d:
        call: run_job_with_lock
        args:
          bucket: ${bucket}
          projectId: ${projectId}
          region: ${region}
          jobName: "sam3d-job"
          lockObject: ${locksPrefix + "/sam3d.json"}
          overrides:
            containerOverrides:
              - env:
                  - name: BUCKET
                    value: ${bucket}
                  - name: SCENE_ID
                    value: ${sceneId}
                  - name: ASSETS_PREFIX
                    value: ${assetsPrefix}
                  - name: LAYOUT_PREFIX
                    value: ${layoutPrefix}
                  - name: MULTIVIEW_PREFIX
                    value: ${multiviewPrefix}
          dedupeContext:
            eventId: ${event.id}
            eventType: ${event.type}
            metageneration: ${event.data.metageneration}
            dedupeToken: ${locksPrefix + "/sam3d.json"}
        result: sam3dResult
        next: handle_sam3d_result

    - handle_sam3d_result:
        switch:
          - condition: ${sam3dResult.skipped}
            next: done_locked
        next: done

    - done:
        return: ${"full pipeline started from " + object}

    - done_locked:
        return: ${"ingest locked for " + object}

    - skip:
        return: ${"ingest skip " + object}

subworkflows:
  run_job_with_lock:
    params: [bucket, lockObject, projectId, region, jobName, overrides, dedupeContext, maxAttempts]
    steps:
      - init:
          assign:
            - attempts: 0
            - resolvedMaxAttempts: ${maxAttempts or 60}
            - resolvedDedupeContext:
                eventId: ${(dedupeContext and dedupeContext.eventId) or ""}
                eventType: ${(dedupeContext and dedupeContext.eventType) or ""}
                metageneration: ${(dedupeContext and dedupeContext.metageneration) or ""}
                dedupeToken: ${(dedupeContext and dedupeContext.dedupeToken) or lockObject}

      - log_dedupe_context:
          call: sys.log
          args:
            text: '${"Dedupe context for " + jobName + ":eventId=" + resolvedDedupeContext.eventId + ", eventType=" + resolvedDedupeContext.eventType + ", metageneration=" + resolvedDedupeContext.metageneration + ", dedupeToken=" + resolvedDedupeContext.dedupeToken}'
            severity: "INFO"

      - check_lock:
          try:
            call: googleapis.storage.v1.objects.get
            args:
              bucket: ${bucket}
              object: ${lockObject}
            result: existingLock
            next: locked
          except:
            as: e
            steps:
              - create_lock:
                  call: googleapis.storage.v1.objects.insert
                  args:
                    bucket: ${bucket}
                    name: ${lockObject}
                    media:
                      string: ${text.encode_to_base64(text.stringify({"createdAt":sys.now(),"job":jobName}))}
                      contentType: "application/json"

      - log_job_launch:
          call: sys.log
          args:
            text: ${"Launching job " + jobName + " with dedupeToken=" + resolvedDedupeContext.dedupeToken}
            severity: "INFO"

      - start_job:
          call: googleapis.run.v2.projects.locations.jobs.run
          args:
            name: ${"projects/" + projectId + "/locations/" + region + "/jobs/" + jobName}
            body:
              overrides: ${overrides}
          result: execution

      - poll_execution:
          call: googleapis.run.v2.projects.locations.executions.get
          args:
            name: ${execution.name}
          result: execStatus
          next: check_state

      - check_state:
          switch:
            - condition: ${execStatus.state in ["SUCCEEDED", "FAILED", "CANCELLED"]}
              next: clear_lock
            - condition: ${attempts >= resolvedMaxAttempts}
              next: clear_lock
          next: bump_attempts

      - bump_attempts:
          assign:
            - attempts: ${attempts + 1}
          next: sleep_execution

      - sleep_execution:
          call: sys.sleep
          args:
            seconds: 10
          next: poll_execution

      - clear_lock:
          try:
            call: googleapis.storage.v1.objects.delete
            args:
              bucket: ${bucket}
              object: ${lockObject}
          except:
            as: deleteErr
            steps:
              - log_delete_err:
                  call: sys.log
                  args:
                    text: ${"Failed to delete lock " + lockObject + ":" + deleteErr.message}
                    severity: "WARNING"
          next: return_result

      - return_result:
          return:
            skipped: false
            execution: ${execution}
            finalState: ${execStatus.state}

      - locked:
          steps:
            - log_duplicate_skip:
                call: sys.log
                args:
                  text: ${"Duplicate detected for dedupeToken=" + resolvedDedupeContext.dedupeToken + "; skipping eventId=" + resolvedDedupeContext.eventId}
                  severity: "INFO"
          return:
            skipped: true
