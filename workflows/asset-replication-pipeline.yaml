# asset-replication-pipeline.yaml
#
# Trigger:
#   GCS object finalized events in PRIMARY_BUCKET.
# Internal filter:
#   automation/asset_replication/queue/*.json
#
# Behavior:
#   - Runs asset-replication-job for each queue object.
#   - Waits for completion and fails on job failure.

main:
  params: [event]
  steps:
    - init:
        assign:
          - projectId: '${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}'
          - region: ${default(sys.get_env("WORKFLOW_REGION"), "us-central1")}
          - bucket: ${event.data.bucket}
          - object: ${event.data.name}
          - replicationJobName: '${default(sys.get_env("ASSET_REPLICATION_JOB_NAME"), "asset-replication-job")}'
          - queuePrefix: '${default(sys.get_env("TEXT_ASSET_REPLICATION_QUEUE_PREFIX"), "automation/asset_replication/queue")}'
        next: filter_queue_objects

    - filter_queue_objects:
        switch:
          - condition: '${text.match_regex(object, "^automation/asset_replication/queue/.+\\.json$")}'
            next: run_replication_job
        next: skip

    - run_replication_job:
        call: run_cloud_run_job_and_wait
        args:
          projectId: ${projectId}
          region: ${region}
          jobName: ${replicationJobName}
          timeoutSeconds: 3600
          envVars:
            - name: BUCKET
              value: ${bucket}
            - name: QUEUE_OBJECT
              value: ${object}
            - name: TEXT_ASSET_REPLICATION_QUEUE_PREFIX
              value: ${queuePrefix}
        result: replicationResult
        next: done

    - done:
        return:
          status: "SUCCESS"
          queue_object: ${object}
          job_execution: ${replicationResult.execution_name}

    - skip:
        return:
          status: "SKIPPED"
          reason: '${"Not a replication queue object: " + object}'


run_cloud_run_job_and_wait:
  params: [projectId, region, jobName, timeoutSeconds, envVars]
  steps:
    - run_job:
        call: googleapis.run.v2.projects.locations.jobs.run
        args:
          name: '${"projects/" + projectId + "/locations/" + region + "/jobs/" + jobName}'
          body:
            overrides:
              containerOverrides:
                - env: ${envVars}
            timeout: '${string(timeoutSeconds) + "s"}'
        result: jobExec
        next: set_execution_name

    - set_execution_name:
        assign:
          - executionName: '${if(jobExec.metadata != null and jobExec.metadata.name != null, jobExec.metadata.name, jobExec.name)}'
        next: wait_for_job

    - wait_for_job:
        call: googleapis.run.v2.projects.locations.jobs.executions.get
        args:
          name: ${executionName}
        result: jobStatus
        next: check_job_status

    - check_job_status:
        assign:
          - jobState: '${if(jobStatus.state != null, jobStatus.state, if(jobStatus.status != null, jobStatus.status.state, null))}'
          - jobFailedCount: '${if(jobStatus.failedCount != null, jobStatus.failedCount, if(jobStatus.status != null, jobStatus.status.failedCount, null))}'
          - jobSucceededCount: '${if(jobStatus.succeededCount != null, jobStatus.succeededCount, if(jobStatus.status != null, jobStatus.status.succeededCount, null))}'
        next: job_status_switch

    - job_status_switch:
        switch:
          - condition: '${jobState == "FAILED" or (jobFailedCount != null and jobFailedCount > 0)}'
            next: raise_job_failed
          - condition: '${jobState == "SUCCEEDED" or (jobSucceededCount != null and jobSucceededCount > 0)}'
            next: return_job_success
        next: wait_poll

    - wait_poll:
        call: sys.sleep
        args:
          seconds: 10
        next: wait_for_job

    - raise_job_failed:
        raise: '${"Cloud Run job failed: " + jobName + " (" + executionName + ")"}'

    - return_job_success:
        return:
          execution_name: ${executionName}
          state: ${jobState}
